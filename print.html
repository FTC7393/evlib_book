<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FTC Programming with ElectronVolts</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="intro/ftc_framework.html"><strong aria-hidden="true">1.2.</strong> The FTC Framework</a></li><li class="chapter-item expanded "><a href="intro/evlib.html"><strong aria-hidden="true">1.3.</strong> The ElectronVolts Library</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Starting Out</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="starter/program/index.html"><strong aria-hidden="true">2.1.</strong> A Starter Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="starter/program/config.html"><strong aria-hidden="true">2.1.1.</strong> Robot Config</a></li><li class="chapter-item expanded "><a href="starter/program/tele_op.html"><strong aria-hidden="true">2.1.2.</strong> TeleOp Program</a></li><li class="chapter-item expanded "><a href="starter/program/install.html"><strong aria-hidden="true">2.1.3.</strong> Compile and Install</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Operation Mode Primer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Auto Primer</div></li></ol></li><li class="chapter-item expanded "><a href="opmodes/index.html"><strong aria-hidden="true">3.</strong> Operation Modes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="opmodes/base.html"><strong aria-hidden="true">3.1.</strong> Base Operation Mode</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> The State Machine</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Hardware</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Version Control</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Metaprogramming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Logger</div></li><li class="chapter-item expanded "><a href="metaprogramming/options.html"><strong aria-hidden="true">7.2.</strong> Setting Options</a></li></ol></li><li class="chapter-item expanded "><a href="evlib/Home.html"><strong aria-hidden="true">8.</strong> Evlib</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Robot-Configuration.html"><strong aria-hidden="true">8.1.</strong> Robot Configuration</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Dependencies</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">FTC Programming with ElectronVolts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Building working, successful, and long-lasting code is hard. Moving requirements and new features basically make every year a surgical process, carefully transposing what code warks and cutting off what doesn't. Fortunately for FTC programmers, libraries are here to provide some stability and a more reasonable starting point.</p>
<p>This tutorial teaches two libraries together: The Qualcomm framework that all FTC teams are <em>required</em> to use, and the ElectronVolts library written by Team 7393, a step above the Qualcomm framework. However, this tutorial leans heavily into the ElectronVolts library, so if you don't want to use that, this tutorial isn't for you.</p>
<p>This book is <em>not</em> meant to teach how to do text-based programming. It also isn't meant to be a primer on how to use the robot apps; that can be found on the FTC <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki">github wiki</a>. Basically, if you don't know any, you should go study up on Java. Alternatively, if you've already know a curly-brace/c-like language, then it might work out for you to just wing it.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Note: Whenever *nix is used here, it refers to operating systems which are somehow based off Unix, like Linux, BSD, and such (excluding Apple operating systems). If you didn't understand some of those words, don't worry: You don't have to.</p>
<h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<h3 id="java"><a class="header" href="#java">Java</a></h3>
<p><em>This step can sometimes be ignored, since you'll already have Java if another app you have uses it.</em></p>
<p>To start, you must first have Java installed. Java 8 or 11 should work, and if you can get Java 16, even better. Windows or MacOS users should go to <a href="https://www.oracle.com/java/technologies/downloads/">the Oracle site</a> and follow the installation instructions for your OS. *nix users should follow the distribution-dependent instructions for installing java.</p>
<h3 id="android-studio"><a class="header" href="#android-studio">Android Studio</a></h3>
<blockquote>
<p>The editor will be an extension of your hand; the keys will sing as they slice their way through text and thought.</p>
</blockquote>
<p><em>(Andrew Hunt and David Thomas, The Pragmatic Programmer)</em></p>
<p>Android Studio is an &quot;IDE&quot;, or Integrated Development Environment. It serves the same purpose as a text editor, but has &quot;Integrations&quot;, such as code formatting or version control toolbar (TODO: Link this to version control page). The most relevant integration for FTC is donwloading programs onto Android devices.</p>
<p>To install Android Studio for Windows or MacOS computers, go to the <a href="https://developer.android.com/studio/">Android Studio</a> site and follow the installation instructions for your OS. *nix users should follow the distribution-dependent instructions for installing Android Studio.</p>
<p>You should definitely spend some time customizing and familiarizing yourself with Android Studio.</p>
<h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<h3 id="ftc-framework"><a class="header" href="#ftc-framework">FTC Framework</a></h3>
<p>Your entire project is based off the Qualcomm framework. To begin a new FTC project, copy all of the code from <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">the FTC repository</a> into your own project. You can do this by clicking the &quot;Code&quot; button, then clicking &quot;Download ZIP&quot;, as shown.</p>
<p><img src="intro/./setup_github_download.png" alt="Download from Github" /></p>
<p>It is better, though, to use Version Control to do this. This is discussed more in the Version Control section (TODO!!).</p>
<p>You can then start writing your code in (<strong>and only in</strong>) the <code>TeamCode/src/main/java</code> directory.</p>
<p>In addition, if you open the project in Android Studio and switch to Android project view as shown, you can navigate to <code>TeamCode/java</code> to get to the same directory.</p>
<p><img src="intro/./setup_android_project_view.png" alt="Android project view" /></p>
<h3 id="electronvolts-library"><a class="header" href="#electronvolts-library">ElectronVolts Library</a></h3>
<p>The latest version of the ElectronVolts library does not exist, as of yet, in its own repository. You can find a copy of it on the <a href="intro/www.example.com">ElectronVolts github page</a>, on the current year's repository and branch, in <code>TeamCode/src/main/java/ftc</code>. For example, during the 2021-2022 season, it was in <a href="https://github.com/FTC7393/FtcRobotController">FtcRobotController</a>, on branch <a href="https://github.com/FTC7393/FtcRobotController/tree/Season2021">Season2021</a>. Copy all the files in that directory to anywhere within your project's working folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-the-robot-works"><a class="header" href="#how-the-robot-works">How the robot works</a></h2>
<p>This part is review for those who've already done FTC.</p>
<p>The REV robotics core communicates over wifi with a phone, which controls the robot core. The robot core, in turn, can control connected hardware. You can read about it on the <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/The-FTC-Control-System">FTC docs page</a>.</p>
<h2 id="ftc-framework-1"><a class="header" href="#ftc-framework-1">FTC Framework</a></h2>
<p>The software on the phone is always the same; the code on the robot is what you control. Even so, there's a certain way your program must act. This is why, when writing your FTC program, you must do it within a framework.</p>
<p>For example, a wrong way to write FTC code:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = &quot;FooOp&quot;)
public class FooOp {
    public static void main(String[] args) {
        Servo s = (Servo) hardwareMap.get(&quot;myServo&quot;);
        int i = 0;

        while (true) {
            s.setPosition(i);
            i = (i + 10) % 180;
        }
    }
}
</code></pre>
<p>There are a few things wrong with this.</p>
<ul>
<li>The <code>hardwareMap</code> does not even exist, so you can't control any hardware.</li>
<li>The <code>main</code> method here will not be run at all -- Qualcomm has their own <code>main</code> code, so yours will not be run.</li>
<li>The <code>@Autonomous</code> annotation is wrong -- this class is not an &quot;Operation Mode&quot;, which is what the framework is expecting. This will probably result in some strange runtime error (TODO: Add a picture of that runtime error).</li>
</ul>
<p>Here is a correct implementation:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = &quot;FooOp&quot;)
public class FooOp extends LinearOpMode {
    @Override
    public void runOpMode() {
        Servo s = (Servo) hardwareMap.get(&quot;myServo&quot;);
        int i = 0;

        waitForStart();

        while (true) {
            s.setPosition(i);
            i = (i + 10) % 180;
        }
    }
}
</code></pre>
<p>All the problems in the previous code have been corrected here:</p>
<ul>
<li>The <code>hardwareMap</code> now exists: It exists in the superclasses of <code>FooOp</code>.</li>
<li>The <code>@Autonomous</code> annotation now makes sense: It is annotating a class which is a Linear Operation Mode. The Qualcomm framework can now correctly detect and run it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-electronvolts-library"><a class="header" href="#the-electronvolts-library">The ElectronVolts Library</a></h1>
<h4 id="what-it-is"><a class="header" href="#what-it-is">What it is:</a></h4>
<ul>
<li>A tool for writing FTC code faster</li>
<li>Classes containing boilerplate code</li>
<li>What this book is trying to get you to use</li>
</ul>
<h4 id="what-it-isnt"><a class="header" href="#what-it-isnt">What it isn't:</a></h4>
<ul>
<li>Magic</li>
<li>Required</li>
</ul>
<p>The ElectronVolts library is some code on top of the Qualcomm framework, allowing you to write your code in a stable way. However, learning <em>yet another</em> library is pretty difficult, and if the FTC library suits your purposes, it's what you should stick with. Evlib contains helpful stuff, but it only helps if used correctly. But if you struggle with these problems:</p>
<ul>
<li>Value fudging</li>
<li>Untraceable logic</li>
<li>Not knowing what's going on</li>
<li>Insanity</li>
</ul>
<p>TODO: Add concrete example of a problem</p>
<p>Maybe this library is a good fit for you. If you find it isn't, then you should stop and read the FTC provided documentation instead.</p>
<h2 id="library-structure"><a class="header" href="#library-structure">Library Structure</a></h2>
<p>The library is split up into two parts: <code>electronvolts</code> and <code>evlib</code>. The <code>electronvolts</code> code consists of helper classes which are used to make <code>evlib</code>, which is the part of the library you will be using most often. Regardless of what you use, you will need to download both and put them inside the same directory.</p>
<p>In the previous tutorial, you saw the <code>LinearOpMode</code>. There are many others that Qualcomm provides, and can be used along with the ElectronVolts library, but the ElectronVolts library contains its own, preferred Operation Modes, which you will see in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-starter-program"><a class="header" href="#a-starter-program">A Starter Program</a></h1>
<p>To start an ElectronVolts <code>TeleOp</code> project, make a new copy of the Qualcomm framework and add this into your TeamCode directory:</p>
<pre><code> java
 ├── MyRobotCfg.java
 └── MyTeleOp.java
</code></pre>
<p>Then add the ElectronVolts library into the directory like so:</p>
<pre><code> java
 ├── MyRobotCfg.java
 ├── MyTeleOp.java
 └── ftc
     ├── electronvolts
     │   └┄┄
     ├── evlib
     ┆   └┄┄
</code></pre>
<p>Once you've set up those files, you can start writing FTC code.</p>
<p>The end product should look something like below. This is just for later reference (i.e. when your code stops working); keep reading for the rest of the walkthrough.</p>
<pre><code class="language-java">MyRobotCfg.java

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}

MyTeleOp.java

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {
    DcMotor myMotor;

    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {
        myMotor = robotCfg.getMyMotor();
    }

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {
        double power = gamepad1.left_trigger - gamepad1.right_trigger;
        myMotor.setPower(power);
    }

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-config"><a class="header" href="#robot-config">Robot Config</a></h1>
<p>In order to access hardware, the Qualcomm framework provides an object called the <code>hardwareMap</code>, which is something like a TypeMap, except each type also has its own map between <code>String</code> and the hardware you want.</p>
<p>ElectronVolts takes this a step further by making the abstract class <code>RobotCfg</code>, which can be used to preload all of the names out of the <code>hardwareMap</code> and let you get it directly.</p>
<p><img src="starter/program/./config_hardware.png" alt="Hardware presented by default" /></p>
<p>(a side note: I call it hardware here, but it's really a reference to the hardware. As in, an object which you can use to control the hardware.)</p>
<p>Importantly, Robot Configs <em>decouple the hardware team from the software team</em>. When the hardware team connects a device to the Robot's brain, that change needs to be reflected in the code. If the hardware specification and the software logic are in the same place, it makes it hard for both teams to read and write. With the Robot Config, the hardware team can declare in one place what hardware they are using in their robot, and the software team only has to read from one place to figure out what hardware is being used.</p>
<p>This also means that this section is great for <em>both hardware and software team</em> to understand.</p>
<p><strong>The library is still not magic</strong>.</p>
<p>If you write code that isn't readable, then putting it all in one place won't necessarily make it better.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Start with a Robot Config like so:</p>
<pre><code class="language-java">MyRobotCfg.java

import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}

</code></pre>
<p>Right now, this config represents an empty bot. It has one brain, one phone, and that's it. This is already pretty powerful – without any custom logic, you have direct access to all the phone's sensors. This is sufficient for an abstract example, but what if we want to add motors to a bot?</p>
<p>Let's start by adding a simple DC motor to a bot, which on the robot core has been <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/Configuring-Your-Hardware">programmed</a> to be called &quot;bruh&quot;:</p>
<pre><code class="language-java">public class MyRobotCfg extends RobotCfg {
    public final DcMotor myMotor;

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }
}
</code></pre>
<p>Some code is not shown for conciseness.</p>
<p>This also works with the getter pattern, like so:</p>
<pre><code class="language-java">public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }
}
</code></pre>
<p>Now, when the software team needs the motor, and has a <code>MyRobotCfg</code>, they can call <code>myRobotCfg.getMyMotor()</code> to receive and move the motor.</p>
<p>The complete code should look like this:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}
</code></pre>
<p>This is all the code you need to move to the next step. If there are some other types of hardware you'd like to add, find them in the <a href="https://javadoc.io/doc/org.firstinspires.ftc">FTC javadoc</a>, or see some more types we've made in the <a href="starter/program/../../hardware/index.html">Hardware section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teleop-program"><a class="header" href="#teleop-program">TeleOp Program</a></h1>
<p>A TeleOp is Tele-Operation: A period of time when <em>you</em>, the human, control the robot. A TeleOp therefore needs take input from a source (in 2021, an xbox controller), and somehow transform it into actions done by the robot. That's the part you make.</p>
<p>Let's get right into it, with the following starter code:</p>
<pre><code class="language-java">MyTeleOp.java

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {
    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg();
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {}

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {}

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<p>This is a <em>lot</em> of methods, and we'll break it down more in the chapter 3. For now, we'll set the goal of moving the motor counterclockwise with the left trigger of the controller, and clockwise with the right trigger.</p>
<p>To start, we need to figure out how much the motor should move. To do this, we'll need to transform the input from the controller into an output for the motor to be able to use.</p>
<pre><code class="language-java">protected void act() {
    double power = gamepad1.left_trigger - gamepad1.right_trigger;
}
</code></pre>
<p>You can see that <code>gamepad1.left_trigger</code> is not a reference to hardware, but a value. This is another one of the ElectronVolts library's simplifications: Managing the input values. Next, we want to send this computed value to the DC motor.</p>
<pre><code class="language-java">protected void act() {
    double power = gamepad1.left_trigger - gamepad1.right_trigger;
    robotCfg.getMyMotor().setPower(power);
}
</code></pre>
<p>This is relatively straightforward. Now, after the program is initialized and the play button is pressed, the <code>act</code> function will run in a loop, so you don't have to worry about the power only being set once.</p>
<p>The completed code should look like this:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {

    DcMotor myMotor;

    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {}

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {
        double power = gamepad1.left_trigger - gamepad1.right_trigger;
        robotCfg.getMyMotor().setPower(power);
    }

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-and-install"><a class="header" href="#compile-and-install">Compile and Install</a></h1>
<p><img src="starter/program/./install_buttons.png" alt="Android Studio buttons" /></p>
<p>When using Android Studio normally, the box highlighted here will look like this. The hammer icon on the left is the &quot;build&quot; button - it compiles the code you've written using a tool called Gradle. The play button on the right triggers a &quot;deploy&quot; - it compiles your code, but also copies the compiled code into the robot, if it's connected by USB.</p>
<p>To download your code onto the REV robotics core, you must first have a USB connection between the core and the computer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation-modes"><a class="header" href="#operation-modes">Operation Modes</a></h1>
<p>Operation Modes are the entry point for your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-operation-mode"><a class="header" href="#base-operation-mode">Base Operation Mode</a></h1>
<p>The class <code>evlib.opmodes.AbstractOp</code> represents the most basic OpMode used by ElectronVolts. It moves through seven runtime stages and three utility stages.</p>
<p>Here are the seven runtime stages, in order:</p>
<ul>
<li>
<p><code>setup</code>: This method is run once when the init button is pressed.</p>
</li>
<li>
<p><code>setup_act</code>: After <code>setup</code> has run, this method is run in a loop, which exits when the play button is pressed. This method is guaranteed to not stop before it completes.</p>
</li>
<li>
<p><code>go</code>: This method is run once at the time when the play button is pressed.</p>
</li>
<li>
<p><code>pre_act</code>: This method is always run before every time <code>act</code> runs.</p>
</li>
<li>
<p><code>act</code>: After <code>go</code> has run, this method is run in a loop until the OpMode is stopped by the Driver Station or by the game time.</p>
</li>
<li>
<p><code>post_act</code>: This method is always run after every time <code>act</code> runs.</p>
</li>
<li>
<p><code>end</code>: This method is run once after the OpMode is stopped by the Driver Station or by the game timer.</p>
</li>
</ul>
<p>You usually don't need to deal with all of these directly, since those such as <code>pre_act</code> and <code>post_act</code> are meant for the the creation of custom OpModes. Others, such as <code>setup</code> and <code>act</code>, are usually for you to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>The unfortunate part about programming for the FTC robot is that to test code, you must build, download, then run; for large codebases this is often a slow process. Sometimes, there will be numbers which are not necessarily fixed, and rebuilding just before every competition and match is infeasible.</p>
<p>This collection of classes gives you a dynamic solution to this problem:</p>
<ul>
<li><code>ftc.evlib.opmodes.AbstractOptionsOp</code></li>
<li><code>ftc.evlib.util.FileUtil</code></li>
<li><code>ftc.electronvolts.util.OptionsFile</code></li>
<li><code>ftc.electronvolts.util.OptionEntry</code></li>
</ul>
<p>These classes allow you to set variables by running an <code>AbstractOptionsOp</code>, then access them later in an unrelated Opmode.</p>
<blockquote>
<p>NOTE: Option setting is an <strong>opt-in</strong> feature. An opmode for setting options is not included.</p>
</blockquote>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>You'll probably want to orient your driver hub to be landscape to use the interface</p>
<blockquote>
<p>TODO: Add picture of driver hub</p>
</blockquote>
<p>The table on the right shows a list of option names and their current values.</p>
<ul>
<li>To select an option, press dpad-up or dpad-down (navigate up or down) until you reach it (the arrows are on either side of the option).</li>
<li>For discrete variables (e.g. integers), press the left/right bumpers to modify their values (this change will be reflected on the telemetry log).</li>
<li>For approximate continuous variables (e.g. floating-points), press the left/right triggers.
<ul>
<li>The depth of the trigger press will be reflected in the rate at which the option is modified (the heavier the touch, the more the variable goes up).</li>
</ul>
</li>
<li>To save the options, press the start button
<ul>
<li><strong>The options will not save when the opmode finishes</strong></li>
</ul>
</li>
<li>To clear changes to the last save, press the reset button
<ul>
<li><strong>This will irrevocably remove all changes that are not saved</strong></li>
</ul>
</li>
</ul>
<h2 id="defining-variables"><a class="header" href="#defining-variables">Defining Variables</a></h2>
<p>You'll first want to set up two classes: An OpMode extending <code>AbstractOptionsOp</code> and an enum class implementing <code>OptionEntry</code>. Here is an example:</p>
<pre><code class="language-java">// ExampleOptions.java

import ftc.electronvolts.util.OptionEntry;

public enum ExampleOptions implements OptionEntry {

    TypeData&lt;?&gt; data;

    @Override
    public TypeData&lt;?&gt; getData {
        return data;
    }

    ExampleOptions(TypeDataBuilder&lt;?&gt; t) {
        data = t.build();
    }

}

// ExampleOptionsOp.java

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import ftc.evlib.opmodes.AbstractOptionsOp;

@TeleOp(name = &quot;Example Options Op&quot;)
public class ExampleOptionsOp extends AbstractOptionsOp {
    @Override
    protected void setImplementationSpecificDetails() {

        filename = &quot;example_options.json&quot;;
        options = ExampleOptions.class;

    }
}
</code></pre>
<p>These classes would run fine by themselves, but if you try running &quot;Example Options Op&quot; you would see nothing. To create options, you would have to define an entry in <code>ExampleOptions</code>. Let's define one that is heavily suited for this task: The alliance color. It's one you'll only know on the field, and will not necessarily have the time to set.</p>
<p>Let's say that you represent your alliance color like so:</p>
<pre><code class="language-java">// AllianceColor.java

public enum AllianceColor {
    RED,
    BLUE,
}
</code></pre>
<p>We'll define an option with these properties:</p>
<ul>
<li>It is called <code>ALLIANCE_COLOR</code></li>
<li>It stores the <code>AllianceColor</code> enum</li>
<li>We somehow tipped off the judge, so we're expecting it to mostly be red</li>
</ul>
<p>Here is the full definition:</p>
<pre><code class="language-java">ALLIANCE_COLOR(TypeDataBuilder
    .enumType(AllianceColor.class)
    .withFallback(AllianceColor.RED)
)
</code></pre>
<p>Here it is inserted into <code>ExampleOptions</code>:</p>
<pre><code class="language-java">public enum ExampleOptions implements OptionEntry {

    ALLIANCE_COLOR(TypeDataBuilder
        .enumType(AllianceColor.class)
        .withFallback(AllianceColor.RED)
    )

    TypeData&lt;?&gt; data;

    @Override
    public TypeData&lt;?&gt; getData {
        return data;
    }

    ExampleOptions(TypeDataBuilder&lt;?&gt; t) {
        data = t.build();
    }

}
</code></pre>
<p>Now if you run &quot;Example Options Op&quot; again, it will show this one option, which you can now change using the bumpers on your controller. Adding more options is as easy as adding more enum variants.</p>
<blockquote>
<p>TODO: add an image</p>
</blockquote>
<h2 id="fetching-options"><a class="header" href="#fetching-options">Fetching Options</a></h2>
<p>After you have set these options, you can programatically access them using the <code>OptionsFile</code> class. Admittedly this is not an easy thing to do, and will be the next thing to improve about the option framework.</p>
<p>To get the object containing the options, use:</p>
<pre><code class="language-java">OptionsFile file = new OptionsFile(FileUtil.getOptionsFile(&quot;example_options.json&quot;));
</code></pre>
<p>The string <code>&quot;example_options.json&quot;</code> comes from the <code>ExampleOptionsOp</code> defined before.</p>
<p>To get out the <code>AllianceColor</code>, access the object like so:</p>
<pre><code class="language-java">AllianceColor color = (AllianceColor) file.load(ExampleOptions.ALLIANCE_COLOR);
</code></pre>
<p>The cast is necessary, without it you will have a compile error.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Welcome to the EVLib wiki!</p>
<p>EVLib is designed to assist in the development of very powerful FTC autonomous programs. It provides helper mechanisms for a variety of hardware, like servo speed control.</p>
<p>For starters, check <a href="evlib/Importing-Into-Your-Project.html">this page</a> for instructions on importing into your project.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>EVLib includes the <a href="https://github.com/FTC7393/state-machine-framework/wiki">state-machine-framework</a>, so all the features of the state-machine-framework can be used from EVLib.</p>
<ul>
<li><a href="evlib/Robot-Configuration.html">robot configuration</a></li>
<li><a href="evlib/Motor-and-MotorEnc.html">the Motor interfaces</a></li>
<li><a href="evlib/Creating-Motors.html">creating motors and continuous servos</a></li>
<li><a href="evlib/NMotors.html">grouping motors</a></li>
<li><a href="evlib/Mecanum-Wheels.html">driving mecanum wheels</a></li>
<li><a href="evlib/Mecanum-Control.html">control of mecanum wheels</a></li>
<li><a href="evlib/Servo-Config.html">servo configuration</a></li>
<li><a href="evlib/Servo-Speed-Control.html">servo speed control</a></li>
<li><a href="evlib/Servo-Presets.html">servo presets</a></li>
<li><a href="evlib/AbstractOp.html">abstract opmodes</a></li>
<li><a href="evlib/AbstractTeleOp.html">abstract teleop</a></li>
<li><a href="evlib/AbstractAutoOp.html">abstract autonomous</a></li>
<li><a href="evlib/AbstractServoTuneOp.html">tuning the servo presets</a></li>
<li><a href="evlib/AbstractOptionsOp.html">selecting options for autonomous</a></li>
<li><a href="evlib/GamepadManager.html">gamepad button edge detection and joystick scaling</a></li>
<li><a href="evlib/EVStates.html">EVStates factory class</a></li>
<li><a href="evlib/EVEndConditions.html">EVEndConditions factory class</a></li>
<li><a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></li>
<li><a href="evlib/Analog-Sensors.html">analog sensors</a></li>
<li><a href="evlib/Digital-Sensors.html">digital sensors</a></li>
<li><a href="evlib/OpenCV-Frame-Grabbing.html">frame grabbing with OpenCV</a></li>
<li><a href="evlib/OpenCV-Image-Processing.html">image processing with OpenCV</a></li>
<li><a href="evlib/CalibratedLineSensor.html">line sensor</a></li>
<li><a href="evlib/DoubleLineSensor.html">double line sensor</a></li>
<li><a href="evlib/ColorSensor.html">color sensor</a></li>
<li><a href="evlib/LineFinder.html">line finder</a></li>
<li><a href="evlib/AveragedSensor.html">averaging analog sensors</a></li>
<li><a href="evlib/Telem.html">global telemetry</a></li>
<li><a href="evlib/StepTimer.html">step timer for logging</a></li>
<li><a href="evlib/FileUtil.html">file utilities</a></li>
<li>[[LineSensorArray]] that uses the i2c <a href="https://www.sparkfun.com/products/13582">SparkFun Line Follower Array</a></li>
<li><a href="evlib/Vuforia-Frame-Grabbing.html">frame grabbing with Vuforia</a></li>
<li><a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html">image processing with Vuforia</a></li>
<li>[[Joystick Recorder]] for &quot;playback&quot; in autonomous</li>
</ul>
<h2 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h2>
<ul>
<li>[[TaskWeb]] to manage executing and moving between multiple tasks on the field</li>
<li>[[Particle Detection]] for autonomous recollection</li>
<li>[[Position Tracker]] to read encoders for position info and return to a set location after driving</li>
</ul>
<p>This project depends on our <a href="https://github.com/FTC7393/state-machine-framework/">state-machine-framework</a> library. Click <a href="https://github.com/FTC7393/state-machine-framework/wiki">here</a> for the state-machine-framework wiki.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before you write an OpMode using the EVLib, you have to make a class that will retrieve the devices (such as motors, servos, and sensors) from the hardwareMap.</p>
<p>Here is an example of this configuration class:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleRobotCfg.java">/sample/v1/SampleRobotCfg.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.hardware.HardwareMap;

import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.TwoMotors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A basic configuration of a robot with 2 motors, and nothing else.
 * Its purpose is to make the same configuration available to multiple opmodes.
 */

public class SampleRobotCfg extends RobotCfg {
    /**
     * the speed of the robot at 100% power
     * you should replace this with a measured value
     */
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));

    /**
     * the drive motors of the robot
     */
    private final TwoMotors twoMotors;

    public SampleRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);

        // create the twoMotors object
        twoMotors = new TwoMotors(
                //get the left and right motors and wrap it with the EVLib Motor interface
                Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers),
                Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers),
                false, //true for speed mode, false for power mode
                MAX_SPEED
        );
    }

    /**
     * gives the opmodes access to the drive motors
     *
     * @return the drive motors
     */
    public TwoMotors getTwoMotors() {
        return twoMotors;
    }

    @Override
    public void act() {

    }

    @Override
    public void stop() {

    }
}
</code></pre>
<p>The next step is to bring the robot to life with a [[Basic TeleOp Program]]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
