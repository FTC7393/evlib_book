<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FTC Programming with ElectronVolts</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="intro/ftc_framework.html"><strong aria-hidden="true">1.2.</strong> The FTC Framework</a></li><li class="chapter-item expanded "><a href="intro/evlib.html"><strong aria-hidden="true">1.3.</strong> The ElectronVolts Library</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Starting Out</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="starter/program/index.html"><strong aria-hidden="true">2.1.</strong> A Starter Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="starter/program/config.html"><strong aria-hidden="true">2.1.1.</strong> Robot Config</a></li><li class="chapter-item expanded "><a href="starter/program/tele_op.html"><strong aria-hidden="true">2.1.2.</strong> TeleOp Program</a></li><li class="chapter-item expanded "><a href="starter/program/install.html"><strong aria-hidden="true">2.1.3.</strong> Compile and Install</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Operation Mode Primer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> Auto Primer</div></li></ol></li><li class="chapter-item expanded "><a href="opmodes/index.html"><strong aria-hidden="true">3.</strong> Operation Modes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="opmodes/base.html"><strong aria-hidden="true">3.1.</strong> Base Operation Mode</a></li><li class="chapter-item expanded "><a href="evlib/AbstractOp.html"><strong aria-hidden="true">3.2.</strong> abstract opmodes</a></li><li class="chapter-item expanded "><a href="evlib/AbstractTeleOp.html"><strong aria-hidden="true">3.3.</strong> abstract teleop</a></li><li class="chapter-item expanded "><a href="evlib/AbstractAutoOp.html"><strong aria-hidden="true">3.4.</strong> abstract autonomous</a></li><li class="chapter-item expanded "><a href="evlib/AbstractServoTuneOp.html"><strong aria-hidden="true">3.5.</strong> tuning the servo presets</a></li><li class="chapter-item expanded "><a href="evlib/AbstractOptionsOp.html"><strong aria-hidden="true">3.6.</strong> selecting options for autonomous</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> The State Machine</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/EVStates.html"><strong aria-hidden="true">4.1.</strong> EVStates factory class</a></li><li class="chapter-item expanded "><a href="evlib/EVEndConditions.html"><strong aria-hidden="true">4.2.</strong> EVEndConditions factory class</a></li><li class="chapter-item expanded "><a href="evlib/EVStateMachineBuilder.html"><strong aria-hidden="true">4.3.</strong> EVStateMachineBuilder</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Hardware</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Motors and Movement</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Motor-and-MotorEnc.html"><strong aria-hidden="true">5.1.1.</strong> the Motor interfaces</a></li><li class="chapter-item expanded "><a href="evlib/Creating-Motors.html"><strong aria-hidden="true">5.1.2.</strong> creating motors and continuous servos</a></li><li class="chapter-item expanded "><a href="evlib/NMotors.html"><strong aria-hidden="true">5.1.3.</strong> grouping motors</a></li><li class="chapter-item expanded "><a href="evlib/Mecanum-Wheels.html"><strong aria-hidden="true">5.1.4.</strong> driving mecanum wheels</a></li><li class="chapter-item expanded "><a href="evlib/Mecanum-Control.html"><strong aria-hidden="true">5.1.5.</strong> control of mecanum wheels</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Sensors</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Analog-Sensors.html"><strong aria-hidden="true">5.2.1.</strong> analog sensors</a></li><li class="chapter-item expanded "><a href="evlib/AveragedSensor.html"><strong aria-hidden="true">5.2.2.</strong> averaging analog sensors</a></li><li class="chapter-item expanded "><a href="evlib/Digital-Sensors.html"><strong aria-hidden="true">5.2.3.</strong> digital sensors</a></li><li class="chapter-item expanded "><a href="evlib/CalibratedLineSensor.html"><strong aria-hidden="true">5.2.4.</strong> line sensor</a></li><li class="chapter-item expanded "><a href="evlib/DoubleLineSensor.html"><strong aria-hidden="true">5.2.5.</strong> double line sensor</a></li><li class="chapter-item expanded "><a href="evlib/ColorSensor.html"><strong aria-hidden="true">5.2.6.</strong> color sensor</a></li><li class="chapter-item expanded "><a href="evlib/LineFinder.html"><strong aria-hidden="true">5.2.7.</strong> line finder</a></li></ol></li><li class="chapter-item expanded "><a href="evlib/GamepadManager.html"><strong aria-hidden="true">5.3.</strong> gamepad button edge detection and joystick scaling</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Version Control</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Other Control Flow and Debugging</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Telem.html"><strong aria-hidden="true">7.1.</strong> global telemetry</a></li><li class="chapter-item expanded "><a href="evlib/StepTimer.html"><strong aria-hidden="true">7.2.</strong> step timer for logging</a></li><li class="chapter-item expanded "><a href="evlib/FileUtil.html"><strong aria-hidden="true">7.3.</strong> file utilities</a></li><li class="chapter-item expanded "><a href="metaprogramming/options.html"><strong aria-hidden="true">7.4.</strong> Setting Options</a></li></ol></li><li class="chapter-item expanded "><a href="evlib/Home.html"><strong aria-hidden="true">8.</strong> Evlib [WIP]</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Importing-Into-Your-Project.html"><strong aria-hidden="true">8.1.</strong> Importing Into Your Project</a></li><li class="chapter-item expanded "><a href="evlib/Sample-Code.html"><strong aria-hidden="true">8.2.</strong> Sample Code</a></li><li class="chapter-item expanded "><a href="evlib/Using-EVLib-Minimally.html"><strong aria-hidden="true">8.3.</strong> Using EVLib Minimally</a></li><li class="chapter-item expanded "><a href="evlib/Logging-Example.html"><strong aria-hidden="true">8.4.</strong> Logging Example</a></li><li class="chapter-item expanded "><a href="evlib/Robot-Configuration.html"><strong aria-hidden="true">8.5.</strong> Robot Configuration</a></li><li class="chapter-item expanded "><a href="evlib/Basic-TeleOp-Program.html"><strong aria-hidden="true">8.6.</strong> Basic TeleOp Program</a></li><li class="chapter-item expanded "><a href="evlib/Basic-Autonomous-Program.html"><strong aria-hidden="true">8.7.</strong> Basic Autonomous Program</a></li><li class="chapter-item expanded "><a href="evlib/Customizing-StateMachineBuilder.html"><strong aria-hidden="true">8.8.</strong> Customizing StateMachineBuilder</a></li><li class="chapter-item expanded "><a href="evlib/Servo-Presets.html"><strong aria-hidden="true">8.9.</strong> Servo Presets</a></li><li class="chapter-item expanded "><a href="evlib/Adding-Servos-to-the-Configuration.html"><strong aria-hidden="true">8.10.</strong> Adding Servos to the Configuration</a></li><li class="chapter-item expanded "><a href="evlib/Adding-Servos-to-TeleOp.html"><strong aria-hidden="true">8.11.</strong> Adding Servos to TeleOp</a></li><li class="chapter-item expanded "><a href="evlib/Adding-Servos-to-Autonomous.html"><strong aria-hidden="true">8.12.</strong> Adding Servos to Autonomous</a></li><li class="chapter-item expanded "><a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html"><strong aria-hidden="true">8.13.</strong> Vuforia and OpenCV Beacon Color Detection</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="evlib/Features.html"><strong aria-hidden="true">9.</strong> Evlib Feature Index [WIP]</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">FTC Programming with ElectronVolts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Building working, successful, and long-lasting code is hard. Moving requirements and new features basically make every year a surgical process, carefully transposing what code warks and cutting off what doesn't. Fortunately for FTC programmers, libraries are here to provide some stability and a more reasonable starting point.</p>
<p>This tutorial teaches two libraries together: The Qualcomm framework that all FTC teams are <em>required</em> to use, and the ElectronVolts library written by Team 7393, a step above the Qualcomm framework. However, this tutorial leans heavily into the ElectronVolts library, so if you don't want to use that, this tutorial isn't for you.</p>
<p>This book is <em>not</em> meant to teach how to do text-based programming. It also isn't meant to be a primer on how to use the robot apps; that can be found on the FTC <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki">github wiki</a>. Basically, if you don't know any, you should go study up on Java. Alternatively, if you've already know a curly-brace/c-like language, then it might work out for you to just wing it.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Note: Whenever *nix is used here, it refers to operating systems which are somehow based off Unix, like Linux, BSD, and such (excluding Apple operating systems). If you didn't understand some of those words, don't worry: You don't have to.</p>
<h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<h3 id="java"><a class="header" href="#java">Java</a></h3>
<p><em>This step can sometimes be ignored, since you'll already have Java if another app you have uses it.</em></p>
<p>To start, you must first have Java installed. Java 8 or 11 should work, and if you can get Java 16, even better. Windows or MacOS users should go to <a href="https://www.oracle.com/java/technologies/downloads/">the Oracle site</a> and follow the installation instructions for your OS. *nix users should follow the distribution-dependent instructions for installing java.</p>
<h3 id="android-studio"><a class="header" href="#android-studio">Android Studio</a></h3>
<p>Android Studio is an &quot;IDE&quot;, or Integrated Development Environment. It serves the same purpose as a text editor, but has &quot;Integrations&quot;, such as code formatting or version control toolbar (TODO: Link this to version control page). The most relevant integration for FTC is donwloading programs onto Android devices.</p>
<p>To install Android Studio for Windows or MacOS computers, go to the <a href="https://developer.android.com/studio/">Android Studio</a> site and follow the installation instructions for your OS. *nix users should follow the distribution-dependent instructions for installing Android Studio.</p>
<p>You should definitely spend some time customizing and familiarizing yourself with Android Studio.</p>
<h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<h3 id="ftc-framework"><a class="header" href="#ftc-framework">FTC Framework</a></h3>
<p>Your entire project is based off the Qualcomm framework. To begin a new FTC project, copy all of the code from <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">the FTC repository</a> into your own project. You can do this by clicking the &quot;Code&quot; button, then clicking &quot;Download ZIP&quot;, as shown.</p>
<p><img src="intro/./setup_github_download.png" alt="Download from Github" /></p>
<p>It is better, though, to use Version Control to do this. This is discussed more in the Version Control section (TODO!!).</p>
<p>You can then start writing your code in (<strong>and only in</strong>) the <code>TeamCode/src/main/java</code> directory.</p>
<p>In addition, if you open the project in Android Studio and switch to Android project view as shown, you can navigate to <code>TeamCode/java</code> to get to the same directory.</p>
<p><img src="intro/./setup_android_project_view.png" alt="Android project view" /></p>
<h3 id="evlib"><a class="header" href="#evlib">Evlib</a></h3>
<p>The latest version of Evlib does not exist, as of yet, in its own repository. You can find a copy of it on the <a href="https://github.com/ftc7393/FtcRobotController">ElectronVolts github page</a>, on the <code>evlib-release</code> branch. Copy all the files in the <code>./Evlib</code> directory to the same location in your project, then update the <code>settings.gradle</code> file like so:</p>
<pre><code class="language-diff">  include ':FtcRobotController'
  include ':TeamCode'
+ include ':Evlib'
</code></pre>
<p>We are currently working on an alternative method to install evlib using the same method as before. Check <a href="intro/../evlib/Importing-Into-Your-Project.html">the original page</a> for updates.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-the-robot-works"><a class="header" href="#how-the-robot-works">How the robot works</a></h2>
<p>This part is review for those who've already done FTC.</p>
<p>The REV robotics core communicates over wifi with a phone, which controls the robot core. The robot core, in turn, can control connected hardware. You can read about it on the <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/The-FTC-Control-System">FTC docs page</a>.</p>
<h2 id="ftc-framework-1"><a class="header" href="#ftc-framework-1">FTC Framework</a></h2>
<p>The software on the phone is always the same; the code on the robot is what you control. Even so, there's a certain way your program must act. This is why, when writing your FTC program, you must do it within a framework.</p>
<p>For example, a wrong way to write FTC code:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = &quot;FooOp&quot;)
public class FooOp {
    public static void main(String[] args) {
        Servo s = (Servo) hardwareMap.get(&quot;myServo&quot;);
        int i = 0;

        while (true) {
            s.setPosition(i);
            i = (i + 10) % 180;
        }
    }
}
</code></pre>
<p>There are a few things wrong with this.</p>
<ul>
<li>The <code>hardwareMap</code> does not even exist, so you can't control any hardware.</li>
<li>The <code>main</code> method here will not be run at all -- Qualcomm has their own <code>main</code> code, so yours will not be run.</li>
<li>The <code>@Autonomous</code> annotation is wrong -- this class is not an &quot;Operation Mode&quot;, which is what the framework is expecting. This will probably result in some strange runtime error (TODO: Add a picture of that runtime error).</li>
</ul>
<p>Here is a correct implementation:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = &quot;FooOp&quot;)
public class FooOp extends LinearOpMode {
    @Override
    public void runOpMode() {
        Servo s = (Servo) hardwareMap.get(&quot;myServo&quot;);
        int i = 0;

        waitForStart();

        while (true) {
            s.setPosition(i);
            i = (i + 10) % 180;
        }
    }
}
</code></pre>
<p>All the problems in the previous code have been corrected here:</p>
<ul>
<li>The <code>hardwareMap</code> now exists: It exists in the superclasses of <code>FooOp</code>.</li>
<li>The <code>@Autonomous</code> annotation now makes sense: It is annotating a class which is a Linear Operation Mode. The Qualcomm framework can now correctly detect and run it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-electronvolts-library"><a class="header" href="#the-electronvolts-library">The ElectronVolts Library</a></h1>
<h4 id="what-it-is"><a class="header" href="#what-it-is">What it is:</a></h4>
<ul>
<li>A tool for writing FTC code faster</li>
<li>Classes containing boilerplate code</li>
<li>What this book is trying to get you to use</li>
</ul>
<h4 id="what-it-isnt"><a class="header" href="#what-it-isnt">What it isn't:</a></h4>
<ul>
<li>Magic</li>
<li>Required</li>
</ul>
<p>The ElectronVolts library is some code on top of the Qualcomm framework, allowing you to write your code in a stable way. However, learning <em>yet another</em> library is pretty difficult, and if the FTC library suits your purposes, it's what you should stick with. Evlib contains helpful stuff, but it only helps if used correctly. But if you struggle with these problems:</p>
<ul>
<li>Value fudging</li>
<li>Untraceable logic</li>
<li>Not knowing what's going on</li>
<li>Insanity</li>
</ul>
<p>TODO: Add concrete example of a problem</p>
<p>Maybe this library is a good fit for you. If you find it isn't, then you should stop and read the FTC provided documentation instead.</p>
<h2 id="library-structure"><a class="header" href="#library-structure">Library Structure</a></h2>
<p>The library is split up into two parts: <code>electronvolts</code> and <code>evlib</code>. The <code>electronvolts</code> code consists of helper classes which are used to make <code>evlib</code>, which is the part of the library you will be using most often. Regardless of what you use, you will need to download both and put them inside the same directory.</p>
<p>In the previous tutorial, you saw the <code>LinearOpMode</code>. There are many others that Qualcomm provides, and can be used along with the ElectronVolts library, but the ElectronVolts library contains its own, preferred Operation Modes, which you will see in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-starter-program"><a class="header" href="#a-starter-program">A Starter Program</a></h1>
<p>To start an ElectronVolts <code>TeleOp</code> project, make a new copy of the Qualcomm framework and add this into your TeamCode directory:</p>
<pre><code> java
 ├── MyRobotCfg.java
 └── MyTeleOp.java
</code></pre>
<p>Then add the ElectronVolts library into the directory like so:</p>
<pre><code> java
 ├── MyRobotCfg.java
 ├── MyTeleOp.java
 └── ftc
     ├── electronvolts
     │   └┄┄
     ├── evlib
     ┆   └┄┄
</code></pre>
<p>Once you've set up those files, you can start writing FTC code.</p>
<p>The end product should look something like below. This is just for later reference (i.e. when your code stops working); keep reading for the rest of the walkthrough.</p>
<pre><code class="language-java">MyRobotCfg.java

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}

MyTeleOp.java

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {
    DcMotor myMotor;

    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {
        myMotor = robotCfg.getMyMotor();
    }

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {
        double power = gamepad1.left_trigger - gamepad1.right_trigger;
        myMotor.setPower(power);
    }

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-config"><a class="header" href="#robot-config">Robot Config</a></h1>
<p>In order to access hardware, the Qualcomm framework provides an object called the <code>hardwareMap</code>, which is something like a TypeMap, except each type also has its own map between <code>String</code> and the hardware you want.</p>
<p>ElectronVolts takes this a step further by making the abstract class <code>RobotCfg</code>, which can be used to preload all of the names out of the <code>hardwareMap</code> and let you get it directly.</p>
<p><img src="starter/program/./config_hardware.png" alt="Hardware presented by default" /></p>
<p>(a side note: I call it hardware here, but it's really a reference to the hardware. As in, an object which you can use to control the hardware.)</p>
<p>Importantly, Robot Configs <em>decouple the hardware team from the software team</em>. When the hardware team connects a device to the Robot's brain, that change needs to be reflected in the code. If the hardware specification and the software logic are in the same place, it makes it hard for both teams to read and write. With the Robot Config, the hardware team can declare in one place what hardware they are using in their robot, and the software team only has to read from one place to figure out what hardware is being used.</p>
<p>This also means that this section is great for <em>both hardware and software team</em> to understand.</p>
<p><strong>The library is still not magic</strong>.</p>
<p>If you write code that isn't readable, then putting it all in one place won't necessarily make it better.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Start with a Robot Config like so:</p>
<pre><code class="language-java">MyRobotCfg.java

import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}

</code></pre>
<p>Right now, this config represents an empty bot. It has one brain, one phone, and that's it. This is already pretty powerful – without any custom logic, you have direct access to all the phone's sensors. This is sufficient for an abstract example, but what if we want to add motors to a bot?</p>
<p>Let's start by adding a simple DC motor to a bot, which on the robot core has been <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/Configuring-Your-Hardware">programmed</a> to be called &quot;bruh&quot;:</p>
<pre><code class="language-java">public class MyRobotCfg extends RobotCfg {
    public final DcMotor myMotor;

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }
}
</code></pre>
<p>Some code is not shown for conciseness.</p>
<p>This also works with the getter pattern, like so:</p>
<pre><code class="language-java">public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }
}
</code></pre>
<p>Now, when the software team needs the motor, and has a <code>MyRobotCfg</code>, they can call <code>myRobotCfg.getMyMotor()</code> to receive and move the motor.</p>
<p>The complete code should look like this:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}
</code></pre>
<p>This is all the code you need to move to the next step. If there are some other types of hardware you'd like to add, find them in the <a href="https://javadoc.io/doc/org.firstinspires.ftc">FTC javadoc</a>, or see some more types we've made in the <a href="starter/program/../../hardware/index.html">Hardware section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teleop-program"><a class="header" href="#teleop-program">TeleOp Program</a></h1>
<p>A TeleOp is Tele-Operation: A period of time when <em>you</em>, the human, control the robot. A TeleOp therefore needs take input from a source (in 2021, an xbox controller), and somehow transform it into actions done by the robot. That's the part you make.</p>
<p>Let's get right into it, with the following starter code:</p>
<pre><code class="language-java">MyTeleOp.java

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {
    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg();
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {}

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {}

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<p>This is a <em>lot</em> of methods, and we'll break it down more in the chapter 3. For now, we'll set the goal of moving the motor counterclockwise with the left trigger of the controller, and clockwise with the right trigger.</p>
<p>To start, we need to figure out how much the motor should move. To do this, we'll need to transform the input from the controller into an output for the motor to be able to use.</p>
<pre><code class="language-java">protected void act() {
    double power = gamepad1.left_trigger - gamepad1.right_trigger;
}
</code></pre>
<p>You can see that <code>gamepad1.left_trigger</code> is not a reference to hardware, but a value. This is another one of the ElectronVolts library's simplifications: Managing the input values. Next, we want to send this computed value to the DC motor.</p>
<pre><code class="language-java">protected void act() {
    double power = gamepad1.left_trigger - gamepad1.right_trigger;
    robotCfg.getMyMotor().setPower(power);
}
</code></pre>
<p>This is relatively straightforward. Now, after the program is initialized and the play button is pressed, the <code>act</code> function will run in a loop, so you don't have to worry about the power only being set once.</p>
<p>The completed code should look like this:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {

    DcMotor myMotor;

    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {}

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {
        double power = gamepad1.left_trigger - gamepad1.right_trigger;
        robotCfg.getMyMotor().setPower(power);
    }

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-and-install"><a class="header" href="#compile-and-install">Compile and Install</a></h1>
<p><img src="starter/program/./install_buttons.png" alt="Android Studio buttons" /></p>
<p>When using Android Studio normally, the box highlighted here will look like this. The hammer icon on the left is the &quot;build&quot; button - it compiles the code you've written using a tool called Gradle. The play button on the right triggers a &quot;deploy&quot; - it compiles your code, but also copies the compiled code into the robot, if it's connected by USB.</p>
<p>To download your code, you must either have a USB or WiFi connection to the Control Hub.
If you use a WiFi connection, it is recommended to use an external wifi card or adapter to be able to connect to
both the internet and robot at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation-modes"><a class="header" href="#operation-modes">Operation Modes</a></h1>
<p>Operation Modes are the entry point for your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-operation-mode"><a class="header" href="#base-operation-mode">Base Operation Mode</a></h1>
<p>The class <code>evlib.opmodes.AbstractOp</code> represents the most basic OpMode used by ElectronVolts. It moves through seven runtime stages and three utility stages.</p>
<p>Here are the seven runtime stages, in order:</p>
<ul>
<li>
<p><code>setup</code>: This method is run once when the init button is pressed.</p>
</li>
<li>
<p><code>setup_act</code>: After <code>setup</code> has run, this method is run in a loop, which exits when the play button is pressed. This method is guaranteed to not stop before it completes.</p>
</li>
<li>
<p><code>go</code>: This method is run once at the time when the play button is pressed.</p>
</li>
<li>
<p><code>pre_act</code>: This method is always run before every time <code>act</code> runs.</p>
</li>
<li>
<p><code>act</code>: After <code>go</code> has run, this method is run in a loop until the OpMode is stopped by the Driver Station or by the game time.</p>
</li>
<li>
<p><code>post_act</code>: This method is always run after every time <code>act</code> runs.</p>
</li>
<li>
<p><code>end</code>: This method is run once after the OpMode is stopped by the Driver Station or by the game timer.</p>
</li>
</ul>
<p>You usually don't need to deal with all of these directly, since those such as <code>pre_act</code> and <code>post_act</code> are meant for the the creation of custom OpModes. Others, such as <code>setup</code> and <code>act</code>, are usually for you to use.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The AbstractOp allows you to make an opmode that is linked to a <a href="evlib/Robot-Configuration.html">Robot Configuration</a>. This class can be used directly by extending it, but it is recommended that you extend <a href="evlib/AbstractTeleOp.html">AbstractTeleOp</a> or <a href="evlib/AbstractAutoOp.html">AbstractAutoOp</a> instead to take advantage of their features as well as these.</p>
<p>AbstractOp takes care of the following:</p>
<ul>
<li>Timing the match</li>
<li>Logging values to a file</li>
<li>Updating the servos</li>
<li>Giving global access to the telemetry</li>
<li>Storing the robotCfg</li>
</ul>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractOp.java">ftc/evlib/opmodes/AbstractOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;

import ftc.electronvolts.util.MatchTimer;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.Telem;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.servos.Servos;
import ftc.evlib.util.FileUtil;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 *
 * adds useful features to the OpMode such as a MatchTimer, servo management, use of RobotCfg
 */
public abstract class AbstractOp&lt;Type extends RobotCfg&gt; extends OpMode {
    /**
     * keeps track of the time left in the match
     */
    public MatchTimer matchTimer;

    /**
     * coordinates all the servos to act with one command
     */
    public Servos servos;

    /**
     * logs values to a file
     */
    private Logger logger;

    /**
     * stores all the motors, servos, and sensors
     */
    public Type robotCfg;


    /**
     * This is implemented by the opmode to initialize the hardware
     *
     * @return a RobotCfg of the type specified by your opmode
     */
    protected abstract Type createRobotCfg();

    /**
     * This is implemented by the opmode to log values
     *
     * @return a Logger that has been configured return null for no logging
     */
    protected abstract Logger createLogger();

    /**
     * This is implemented by the opmode
     * It is called when the init button is pressed on the driver station
     */
    protected abstract void setup();

    /**
     * This is implemented by the opmode
     * It is called continuously between the setup() and go() methods
     */
    protected abstract void setup_act();

    /**
     * This is implemented by the opmode
     * It is called when the start button on the driver station is pressed
     */
    protected abstract void go();

    /**
     * This is implemented by AbstractTeleOp to update the joysticks
     * It is called right before the act() method
     *
     * @see AbstractTeleOp
     */
    protected abstract void pre_act();

    /**
     * This is implemented by the opmode
     * It is called between the go() and stop() methods
     */
    protected abstract void act();

    /**
     * This is implemented by AbstractAutoOp to run the StateMachine
     * It is called right after the act() method
     *
     * @see AbstractAutoOp
     */
    protected abstract void post_act();

    /**
     * This is implemented by the opmode
     * It is called when the stop button is pressed on the driver station
     */
    protected abstract void end();

    /**
     * This is implemented by AbstractAutoOp and AbstractTeleOp to set the match time for autonomous and teleop
     *
     * @return The length of the match
     */
    protected abstract Time getMatchTime();

    @Override
    public void init() {
        Telem.telemetry = telemetry; //store the telemetry in a global location

        robotCfg = createRobotCfg(); //ask the OpMode for the HardwareCfg object
        servos = robotCfg.getServos(); //create the servos object

        matchTimer = new MatchTimer(getMatchTime()); //create the MatchTimer
        logger = createLogger(); //create the logger

        setup();
    }

    @Override
    public void init_loop() {
        setup_act();
    }

    @Override
    public void start() {
        matchTimer.start(); //start the match

        if (logger != null) logger.start(FileUtil.getLogsDir()); // start the logging

        go();
    }

    @Override
    public void loop() {
        double deltaTime = matchTimer.update(); //update the delta time since the last loop
        telemetry.addData(&quot;Delta Time: &quot;, deltaTime);

        //stop the robot when the match ends
        if (matchTimer.isMatchJustOver()) stop();
        if (matchTimer.isMatchOver()) return;

        long timeLeft = matchTimer.getTimeLeft();
        if (timeLeft &gt; 0) {
            telemetry.addData(&quot;Time left&quot;, timeLeft / 1000.0);
        }

        pre_act();

        if (logger != null) logger.act();

        act();
        post_act();

        robotCfg.act();
        servos.servosAct(); //update the servo positions
    }

    @Override
    public void stop() {
        robotCfg.stop();
        robotCfg.getStoppers().stop();
        servos.servosAct(); //update the servos so they will stop
        if (logger != null) logger.stop();

        end();
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>AbstractTeleOp extends <a href="evlib/AbstractOp.html">AbstractOp</a> and adds code to handle the gamepads. You can use this to make a TeleOp by extending this class. <a href="evlib/Basic-TeleOp-Program.html">Here</a> is and example. Inside your class you have access to driver1 and driver2, which are instances of the <a href="evlib/GamepadManager.html">GamepadManager</a> class. They add edge detection and scaling to the gamepads. See also: <a href="evlib/AbstractAutoOp.html">AbstractAutoOp</a></p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractTeleOp.java">ftc/evlib/opmodes/AbstractTeleOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.GamepadManager;
import ftc.evlib.hardware.config.RobotCfg;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * extends AbstractOp and adds gamepad edge detection and scaling, and a 2 minute timer
 *
 * @see AbstractOp
 * @see GamepadManager
 */
public abstract class AbstractTeleOp&lt;Type extends RobotCfg&gt; extends AbstractOp&lt;Type&gt; {
    public GamepadManager driver1;
    public GamepadManager driver2;

    /**
     * This is implemented by the teleop opmode
     *
     * @return a Function to scale the joysticks by
     */
    protected abstract Function getJoystickScalingFunction();

    @Override
    public Time getMatchTime() {
        return Time.fromMinutes(2); //teleop is 2 minutes
    }

    @Override
    public void start() {
        //set the joystick deadzone
//        gamepad1.setJoystickDeadzone(.1F);
//        gamepad2.setJoystickDeadzone(.1F);

        //get the scaling function
        Function f = getJoystickScalingFunction();
        if (f == null) {
            //if it is null set it to none
            f = Functions.none();
        }

        //apply the function to the gamepads and store them
        driver1 = new GamepadManager(gamepad1, f);
        driver2 = new GamepadManager(gamepad2, f);
        super.start();
    }

    @Override
    public void pre_act() {
        //update the joystick values
        driver1.update();
        driver2.update();
    }

    @Override
    public void post_act() {

    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>AbstractAutoOp extends <a href="evlib/AbstractOp.html">AbstractOp</a> and adds code to run a state machine. You can create an autonomous by extending this class and creating the StateMachine in the buildStates() method. <a href="evlib/Basic-Autonomous-Program.html">Here</a> is an example. See also: <a href="evlib/AbstractTeleOp.html">AbstractTeleOp</a></p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractAutoOp.java">ftc/evlib/opmodes/AbstractAutoOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.hardware.config.RobotCfg;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/13/16
 *
 * extends AbstractOp and adds a 30 second timer and a state machine
 *
 * @see AbstractOp
 * @see StateMachine
 */
public abstract class AbstractAutoOp&lt;Type extends RobotCfg&gt; extends AbstractOp&lt;Type&gt; {
    protected StateMachine stateMachine;

    /**
     * This is implemented by the autonomous opmode
     * It is called where the setup would have been
     *
     * @return A state machine to be run
     */
    public abstract StateMachine buildStates();

    @Override
    public Time getMatchTime() {
        return Time.fromSeconds(30); //autonomous is 30 seconds
    }

    @Override
    public void setup() {
        stateMachine = buildStates(); //get the state machine from the opmode
    }

    @Override
    public void pre_act() {

    }

    @Override
    public void post_act() {
        stateMachine.act(); //update the state machine
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Go to <a href="evlib/Servo-Presets.html">Servo Presets</a> to see how to extend this class to tune the servos.</p>
<p>Here is AbstractServoTuneOp, which can be extended to tune servos for any <a href="evlib/Robot-Configuration.html">Robot Configuration</a>.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractServoTuneOp.java">ftc/evlib/opmodes/AbstractServoTuneOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import java.util.ArrayList;
import java.util.List;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.Utility;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.files.OptionsFile;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.servos.ServoCfg;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.util.EVConverters;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/30/16
 *
 * extends AbstractTeleOp and adds tuning of servo presets with the joysticks.
 *
 * Subclasses of this are very simple since this does most of the work.
 *
 * It allows you to change your servo presets without changing the code and re-deploying it to the
 * phone. This means that you can swap out a servo and re-tune it without having to go into the
 * program and fix magic numbers. Note:  It only works if you use presets everywhere instead of
 * hardcoded values.
 *
 * How to use for your robot:
 * Create a subclass of this (AbstractServoTuneOp).
 * return a new instance of your RobotCfg (it has the servos) in createRobotCfg().
 *
 * Subclass example:
 *
 * &lt;code&gt;
 *
 * \@TeleOp(name = &quot;MyRobot ServoTuneOp&quot;)
 * public class MyRobotServoTuneOp extends AbstractServoTuneOp {
 * \@Override protected RobotCfg createRobotCfg() {
 * return new MyRobotCfg(hardwareMap);
 * }
 * }
 * &lt;/code&gt;
 *
 * How to operate:
 * Use the dpad up and down to cycle through all the servos
 * Use the dpad left and right to move through the presets for that servo.
 * Use the left and right joystick y values to change the servo position.
 * Press start to save the current preset of the current servo to the current value.
 *
 * The presets are saved in files that are retrieved when you run other opmodes to find the value of each preset.
 *
 * @see ServoControl
 * @see ServoCfg
 */
public abstract class AbstractServoTuneOp extends AbstractTeleOp&lt;RobotCfg&gt; {
    /**
     * The index of the servo in the list
     */
    private int servoIndex = 0;

    /**
     * The index of the preset for the current servo
     */
    private int presetIndex = 0;

    /**
     * records whether or not a new servo has been selected
     */
    private boolean servoIndexChanged = true;

    /**
     * records whether or not a new servo preset has been selected
     */
    private boolean servoPresetIndexChanged = true;

    /**
     * The list of current positions for each servo
     */
    private final List&lt;Double&gt; servoPositions = new ArrayList&lt;&gt;();

    /**
     * The list of servo names
     */
    private List&lt;ServoName&gt; servoNames;

    /**
     * The list of preset names for the current servo
     */
    private List&lt;Enum&gt; presetNames;

    /**
     * The list of preset values for the current servo
     */
    private List&lt;Double&gt; presetValues;

    /**
     * The current servo
     */
    private ServoControl servo;

    /**
     * @return no joystick scaling
     */
    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.none();
    }

    /**
     * @return no match timer
     */
    @Override
    public Time getMatchTime() {
        return null;
    }

    /**
     * @return no logging
     */
    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {
        //get a list of servo names from the RobotCfg
        servoNames = robotCfg.getServos().getServoNames();

        //add servo positions to be the same length as servoNames
        for (ServoName ignored : servoNames) {
            servoPositions.add(0.5);
        }
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {


        //if dpad up is pressed
        if (driver1.dpad_up.justPressed() || driver2.dpad_up.justPressed()) {
            servoIndex += 1; //move to the next servo
            //wrap around if the index is too large
            if (servoIndex &gt; servoNames.size() - 1) servoIndex = 0;
            servoIndexChanged = true; //signal that the index changed
        }

        //if dpad down is pressed
        if (driver1.dpad_down.justPressed() || driver2.dpad_down.justPressed()) {
            servoIndex -= 1; //move to the previous servo
            //wrap around if the index is too small
            if (servoIndex &lt; 0) servoIndex = servoNames.size() - 1;
            servoIndexChanged = true; //signal that the index changed
        }

        //if a different servo was selected
        if (servoIndexChanged) {
            servoIndexChanged = false;

            servo = robotCfg.getServo(servoNames.get(servoIndex));//get the servo
            presetNames = new ArrayList&lt;&gt;(servo.getPresets().keySet()); //get the preset names from the servo
            presetValues = new ArrayList&lt;&gt;(servo.getPresets().values()); //get the presets from the servo

            presetIndex = 0; //start at the first preset for the new servo
            servoPresetIndexChanged = true; //signal to reload the servo preset
        }

        //get the servo position
        double servoPosition = servoPositions.get(servoIndex);

        //if the dpad left was just pressed
        if (driver1.dpad_left.justPressed() || driver2.dpad_left.justPressed()) {
            presetIndex -= 1; //select the previous servo preset
            //wrap around if the index is too small
            if (presetIndex &lt; 0) presetIndex = presetValues.size() - 1;
            servoPresetIndexChanged = true; //signal that the index changed
        }

        //if the dpad right was just pressed
        if (driver1.dpad_right.justPressed() || driver2.dpad_right.justPressed()) {
            presetIndex += 1; //select the next servo preset
            //wrap around if the index is too large
            if (presetIndex &gt; presetValues.size() - 1) presetIndex = 0;
            servoPresetIndexChanged = true; //signal that the index changed
        }

        //is the servo preset index changed
        if (servoPresetIndexChanged) {
            servoPresetIndexChanged = false;
            servoPosition = presetValues.get(presetIndex); //set the servo to the preset position
        }

        telemetry.addData(&quot;Press start to set the current preset to the current value&quot;, &quot;&quot;);
        //if start is pressed, save the current preset to a file
        if (driver1.start.justPressed() || driver2.start.justPressed()) {
            //set the current selected preset to the current servo position
            servo.getPresets().put(presetNames.get(presetIndex), servoPosition);
            presetValues.set(presetIndex, servoPosition);

            OptionsFile optionsFile = new OptionsFile(EVConverters.getInstance()); //create an OptionsFile

            //put the preset names and presets into the OptionsFile
            for (int i = 0; i &lt; presetNames.size(); i++) {
                optionsFile.set(presetNames.get(i).name(), presetValues.get(i).toString());
            }

            optionsFile.writeToFile(ServoCfg.getServoFile(servoNames.get(servoIndex))); //store the OptionsFile to a file
        }

        //modify the servo position using the joysticks
        servoPosition += 2e-4 * matchTimer.getDeltaTime() * (driver1.left_stick_y.getValue() + 0.1 * driver1.right_stick_y.getValue() + driver2.left_stick_y.getValue() + 0.1 * driver2.right_stick_y.getValue());

        //limit the position
        servoPosition = Utility.servoLimit(servoPosition);

        //set the servo to the position
        servo.setPosition(servoPosition);

        //store the position
        servoPositions.set(servoIndex, servoPosition);

        //display telemetry about the servo
        telemetry.addData(&quot;Servo Name&quot;, servoNames.get(servoIndex));
        telemetry.addData(&quot;Servo Preset Name&quot;, presetNames.get(presetIndex));
        telemetry.addData(&quot;Servo Preset Value&quot;, servoPosition);
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date</p>
</blockquote>
<p>AbstractOptionsOp extends <a href="evlib/AbstractOp.html">AbstractOp</a>. You can use it to take input from the gamepad and store settings for autonomous in a file on the robot phone. It uses <a href="https://github.com/FTC7393/state-machine-framework/wiki/OptionsFile">OptionsFile</a> from the state-machine-framework.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractOptionsOp.java">ftc/evlib/opmodes/AbstractOptionsOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.files.OptionsFile;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.util.EVConverters;
import ftc.evlib.util.FileUtil;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/29/16
 *
 * extends AbstractTeleOp and adds saving and loading an OptionsFile and removes the match timer
 *
 * @see AbstractTeleOp
 * @see OptionsFile
 */
public abstract class AbstractOptionsOp extends AbstractTeleOp&lt;RobotCfg&gt; {
    private final String filename;
    public OptionsFile optionsFile;

    /**
     * The filename will be set by the subclasses
     *
     * @param filename the name of the file where the options are stored
     */
    public AbstractOptionsOp(String filename) {
        this.filename = filename;
    }

    /**
     * @return a dummy RobotCfg
     */
    @Override
    protected RobotCfg createRobotCfg() {
        return new RobotCfg(hardwareMap) {
            @Override
            public void act() {

            }

            @Override
            public void stop() {

            }
        };
    }

    @Override
    protected Logger createLogger() {
        //the OptionsOp has no logging
        return null;
    }

    @Override
    public Time getMatchTime() {
        //the OptionsOp has no time limit
        return null;
    }

    /**
     * Load the options from the file
     */
    public void loadOptionsFile() {
        optionsFile = new OptionsFile(EVConverters.getInstance(), FileUtil.getOptionsFile(filename));
    }

    /**
     * save the options from the file
     */
    public void saveOptionsFile() {
        optionsFile.writeToFile(FileUtil.getOptionsFile(filename));
    }

    @Override
    protected void setup() {
        //load the file when the opmode starts
        loadOptionsFile();
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    public void post_act() {
        super.post_act();

        //display telemetry instructions
        telemetry.addData(&quot;* back button =&gt; erase changes&quot;, &quot;&quot;);
        //reload the file if the back button is pressed
        if (driver1.back.justPressed()) loadOptionsFile();

        //display telemetry instructions
        telemetry.addData(&quot;* start button =&gt; save&quot;, &quot;&quot;);
        //save the file if the start button is pressed
        if (driver1.start.justPressed()) saveOptionsFile();

        telemetry.addData(&quot;* Stop the opmode to save and quit.&quot;, &quot;&quot;);
    }

    @Override
    protected void end() {
        //save the file when the opmode ends
        saveOptionsFile();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>EVStates</strong> | <a href="evlib/EVEndConditions.html">EVEndConditions</a> | <a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></p>
<hr />
<p>EVStates is a factory class that extends States from the state-machine-framework. It inherits all the factory methods from States, and adds its own that relate to FTC.</p>
<p>Some that we use frequently are:</p>
<ul>
<li><strong>mecanumDrive</strong> -- drives with the mecanum wheels and stabilizes with the gyro</li>
<li><strong>servoTurn</strong> -- turns a servo to a <a href="evlib/Servo-Presets.html">preset</a> at a given <a href="evlib/Servo-Speed-Control.html">speed</a></li>
<li><strong>calibrateGyro</strong> -- waits for the gyro sensor to finish calibrating</li>
</ul>
<p>Some others that are also useful are:</p>
<ul>
<li><strong>drive</strong> -- drives with a <a href="evlib/TwoMotors.html">TwoMotors</a> object</li>
<li><strong>turn</strong> -- tuns with a TwoMotors object</li>
<li><strong>oneWheelTurn</strong> -- powers one wheel to turn</li>
<li><strong>motorTurn</strong> -- turns a motor</li>
</ul>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/statemachine/EVStates.java">ftc/evlib/statemachine/EVStates.java</a></p>
<pre><code class="language-java">package ftc.evlib.statemachine;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.hardware.GyroSensor;

import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;

import java.util.List;

import ftc.electronvolts.statemachine.AbstractState;
import ftc.electronvolts.statemachine.BasicAbstractState;
import ftc.electronvolts.statemachine.EndCondition;
import ftc.electronvolts.statemachine.EndConditions;
import ftc.electronvolts.statemachine.State;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.statemachine.States;
import ftc.electronvolts.statemachine.Transition;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.ResultReceiver;
import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.Telem;
import ftc.evlib.hardware.control.LineUpControl;
import ftc.evlib.hardware.control.MecanumControl;
import ftc.evlib.hardware.control.RotationControl;
import ftc.evlib.hardware.control.RotationControls;
import ftc.evlib.hardware.control.TranslationControl;
import ftc.evlib.hardware.control.TranslationControls;
import ftc.evlib.hardware.mechanisms.Shooter;
import ftc.evlib.hardware.motors.MecanumMotors;
import ftc.evlib.hardware.motors.Motor;
import ftc.evlib.hardware.motors.NMotors;
import ftc.evlib.hardware.motors.TwoMotors;
import ftc.evlib.hardware.sensors.DigitalSensor;
import ftc.evlib.hardware.sensors.DistanceSensor;
import ftc.evlib.hardware.sensors.DoubleLineSensor;
import ftc.evlib.hardware.sensors.LineSensorArray;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.Servos;
import ftc.evlib.vision.framegrabber.FrameGrabber;
import ftc.evlib.vision.framegrabber.VuforiaFrameFeeder;
import ftc.evlib.vision.processors.BeaconColorResult;
import ftc.evlib.vision.processors.BeaconName;
import ftc.evlib.vision.processors.CloseUpColorProcessor;
import ftc.evlib.vision.processors.ImageProcessor;
import ftc.evlib.vision.processors.ImageProcessorResult;
import ftc.evlib.vision.processors.Location;
import ftc.evlib.vision.processors.RGBBeaconProcessor;
import ftc.evlib.vision.processors.VuforiaBeaconColorProcessor;

import static ftc.evlib.driverstation.Telem.telemetry;
import static ftc.evlib.vision.framegrabber.GlobalFrameGrabber.frameGrabber;
import static ftc.evlib.vision.framegrabber.VuforiaFrameFeeder.beacons;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 5/10/16
 *
 * @see State
 * @see EVStateMachineBuilder
 */
public class EVStates extends States {

    /**
     * Displays the left and right color of a BeaconColorResult
     *
     * @param stateName the name of the state
     * @param receiver  the ResultReceiver to get the color from
     * @return the created State
     * @see BeaconColorResult
     */
    public static State displayBeaconColorResult(StateName stateName, final ResultReceiver&lt;BeaconColorResult&gt; receiver) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                Telem.displayBeaconColorResult(receiver);
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * Displays the color of a BeaconColorResult.BeaconColor
     *
     * @param stateName the name of the state
     * @param receiver  the ResultReceiver to get the color from
     * @return the created State
     * @see BeaconColorResult
     */
    public static State displayBeaconColor(StateName stateName, final ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; receiver) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                Telem.displayBeaconColor(receiver);
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * Uses vuforia to find the beacon target image, then uses opencv to determine the beacon color
     *
     * @param stateName         the name of the state
     * @param successState      the state to go to if it succeeds
     * @param failState         the state to go to if it fails
     * @param timeoutState      the state to go to if it times out
     * @param timeoutTime       the time before it will time out
     * @param vuforiaReceiver   the ResultReceiver to get the VuforiaFramFeeder object from
     * @param beaconColorResult the ResultReceiver to store the result in
     * @param teamColor         your team's color to decide which beacons to look for
     * @param numFrames         the number of frames to process
     * @param saveImages        whether or not to save the frames for logging
     * @return the created State
     * @see VuforiaFrameFeeder
     * @see VuforiaBeaconColorProcessor
     */
    //TODO assume that vuforia is initialized in findBeaconColorState
    public static State findBeaconColorState(StateName stateName, final StateName successState, final StateName failState, final StateName timeoutState, Time timeoutTime, final ResultReceiver&lt;VuforiaFrameFeeder&gt; vuforiaReceiver, final ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult, TeamColor teamColor, final int numFrames, final boolean saveImages) {
        final List&lt;BeaconName&gt; beaconNames = BeaconName.getNamesForTeamColor(teamColor);
        final EndCondition timeout = EndConditions.timed(timeoutTime);

        return new BasicAbstractState(stateName) {
            private VuforiaFrameFeeder vuforia = null;
            private VuforiaBeaconColorProcessor processor = null;
            private BeaconName beaconName;
            private int beaconIndex = 0; //index of the beaconNames list
            private boolean timedOut = false;

            @Override
            public void init() {
                timeout.init();
                timedOut = false;

                if (beaconIndex &gt;= beaconNames.size()) {
                    beaconIndex = 0;
                    //we should never go here
                }
                beaconName = beaconNames.get(beaconIndex);
                if (processor != null) {
                    processor.setBeaconName(beaconName);
                }
            }

            @Override
            public boolean isDone() {
                if (vuforia == null &amp;&amp; vuforiaReceiver.isReady()) {
                    vuforia = vuforiaReceiver.getValue();
//                    if (vuforia == null) {
//                        Log.e(&quot;EVStates&quot;, &quot;vuforia is null!!!!!!!!!!!!!&quot;);
//                    }

                    processor = new VuforiaBeaconColorProcessor(vuforia);
                    processor.setBeaconName(beaconName);

                    VuforiaTrackable beacon = beacons.get(beaconName);
                    beacon.getTrackables().activate();

                    frameGrabber.setImageProcessor(processor);
                    frameGrabber.setSaveImages(saveImages);
                    frameGrabber.grabContinuousFrames();
                }
                timedOut = timeout.isDone();
                return timedOut || processor != null &amp;&amp; processor.getResultsFound() &gt;= numFrames;
            }

            @Override
            public StateName getNextStateName() {
                beaconIndex++;
                frameGrabber.stopFrameGrabber();
                VuforiaTrackable beacon = beacons.get(beaconName);
                beacon.getTrackables().deactivate();

                BeaconColorResult result = processor.getAverageResult();
                processor.reset();
                BeaconColorResult.BeaconColor leftColor = result.getLeftColor();
                BeaconColorResult.BeaconColor rightColor = result.getRightColor();
                if ((leftColor == BeaconColorResult.BeaconColor.RED &amp;&amp; rightColor == BeaconColorResult.BeaconColor.BLUE)
                        || (leftColor == BeaconColorResult.BeaconColor.BLUE &amp;&amp; rightColor == BeaconColorResult.BeaconColor.RED)) {
                    beaconColorResult.setValue(result);
                    return successState;
                } else {
                    beaconColorResult.setValue(new BeaconColorResult());
                    if (timedOut) {
                        return timeoutState;
                    } else {
                        return failState;
                    }
                }
            }
        };
    }

    public static State findColorState(StateName stateName, final StateName successState, final StateName unknownState, final ResultReceiver&lt;VuforiaFrameFeeder&gt; vuforiaReceiver, final ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; colorResult, final boolean saveImages) {
        return new BasicAbstractState(stateName) {
            private VuforiaFrameFeeder vuforia = null;
            private CloseUpColorProcessor processor = null;
            private boolean timedOut = false;

            @Override
            public void init() {
                vuforia = vuforiaReceiver.getValue();
                processor = new CloseUpColorProcessor();

                frameGrabber.setImageProcessor(processor);
                frameGrabber.setSaveImages(saveImages);
                frameGrabber.grabSingleFrame();
            }

            @Override
            public boolean isDone() {
                return frameGrabber.isResultReady();
            }

            @Override
            public StateName getNextStateName() {
                BeaconColorResult.BeaconColor result = (BeaconColorResult.BeaconColor) frameGrabber.getResult().getResult();
                colorResult.setValue(result);
                if (result == BeaconColorResult.BeaconColor.RED || result == BeaconColorResult.BeaconColor.BLUE) {
                    return successState;
                } else {
                    return unknownState;
                }
            }
        };
    }

    public static State beaconColorSwitch(StateName stateName, final StateName redState, final StateName blueState, final StateName unknownState, ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; colorResult) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                BeaconColorResult.BeaconColor result = (BeaconColorResult.BeaconColor) frameGrabber.getResult().getResult();
                switch (result) {
                    case RED:
                        return redState;
                    case BLUE:
                        return blueState;
                    default:
                        return unknownState;
                }
            }
        };
    }

    /**
     * use the camera to detect and drive up to the beacon
     *
     * @param stateName       the name of the state
     * @param doneState       the state to go to if it works
     * @param lostObjectState the state to go to if it cannot find the beacon
     * @param timeoutState    the state to go to if it times out
     * @param timeoutMillis   the number of milliseconds before the timeout
     * @param mecanumControl  the mecanum wheels
     * @param frameGrabber    access to the camera frames
     * @return the created State
     */
    public static State mecanumCameraTrack(StateName stateName, final StateName doneState, final StateName lostObjectState, final StateName timeoutState, long timeoutMillis, final MecanumControl mecanumControl, final FrameGrabber frameGrabber, ImageProcessor&lt;? extends Location&gt; imageProcessor) {
        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);
        final TranslationControl beaconTrackingControl = TranslationControls.cameraTracking(frameGrabber, imageProcessor);
        final long timeoutTime = System.currentTimeMillis() + timeoutMillis;

        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                mecanumControl.setTranslationControl(beaconTrackingControl);
            }

            @Override
            public boolean isDone() {
                return !mecanumControl.translationWorked() || beaconTrackingControl.getTranslation().getLength() &lt; 0.1 || System.currentTimeMillis() &gt;= timeoutTime;
            }

            @Override
            public StateName getNextStateName() {
                mecanumControl.stop();

                if (beaconTrackingControl.getTranslation().getLength() &lt; 0.1) {
                    return doneState;
                } else {
                    if (!mecanumControl.translationWorked()) {
                        return lostObjectState;
                    } else {
                        return timeoutState;
                    }
                }
            }
        };
    }

    /**
     * @param stateName      the name of the state
     * @param nextStateName  the name of the next state
     * @param imageProcessor the object that processes the image
     * @param resultReceiver the object that stores the image
     * @return the created State
     */
    public static State processFrame(StateName stateName, final StateName nextStateName, final ImageProcessor imageProcessor, final ResultReceiver&lt;ImageProcessorResult&gt; resultReceiver) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                frameGrabber.setImageProcessor(imageProcessor);
                frameGrabber.grabSingleFrame();
            }

            @Override
            public boolean isDone() {
                return frameGrabber.isResultReady();
            }

            @Override
            public StateName getNextStateName() {
                resultReceiver.setValue(frameGrabber.getResult());
                return nextStateName;
            }
        };
    }

    /**
     * @param stateName           the name of the state
     * @param unknownUnknownState if both sides are unknown
     * @param unknownRedState     if the left is unknown and the right is red
     * @param unknownBlueState    if the left is unknown and the right is blue
     * @param redUnknownState     if the left is red and the right is unknown
     * @param redRedState         if the left is red and the right is red
     * @param redBlueState        if the left is red and the right is blue
     * @param blueUnknownState    if the left is blue and the right is unknown
     * @param blueRedState        if the left is blue and the right is red
     * @param blueBlueState       if the left is blue and the right is blue
     * @return the created State
     */
    public static State processBeaconPicture(StateName stateName,
                                             final StateName unknownUnknownState, final StateName unknownRedState, final StateName unknownBlueState,
                                             final StateName redUnknownState, final StateName redRedState, final StateName redBlueState,
                                             final StateName blueUnknownState, final StateName blueRedState, final StateName blueBlueState
    ) {

        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                frameGrabber.setImageProcessor(new RGBBeaconProcessor());
                frameGrabber.grabSingleFrame();
            }

            @Override
            public boolean isDone() {
                return frameGrabber.isResultReady();
            }

            @Override
            public StateName getNextStateName() {
                BeaconColorResult beaconColorResult = (BeaconColorResult) frameGrabber.getResult().getResult();
                BeaconColorResult.BeaconColor leftColor = beaconColorResult.getLeftColor();
                BeaconColorResult.BeaconColor rightColor = beaconColorResult.getRightColor();

                if (leftColor == BeaconColorResult.BeaconColor.RED) {
                    if (rightColor == BeaconColorResult.BeaconColor.RED) {
                        return redRedState;
                    } else if (rightColor == BeaconColorResult.BeaconColor.BLUE) {
                        return redBlueState;
                    } else {
                        return redUnknownState;
                    }
                } else if (leftColor == BeaconColorResult.BeaconColor.BLUE) {
                    if (rightColor == BeaconColorResult.BeaconColor.RED) {
                        return blueRedState;
                    } else if (rightColor == BeaconColorResult.BeaconColor.BLUE) {
                        return blueBlueState;
                    } else {
                        return blueUnknownState;
                    }
                } else {
                    if (rightColor == BeaconColorResult.BeaconColor.RED) {
                        return unknownRedState;
                    } else if (rightColor == BeaconColorResult.BeaconColor.BLUE) {
                        return unknownBlueState;
                    } else {
                        return unknownUnknownState;
                    }
                }
            }
        };
    }

    /**
     * @param stateName the name of the state
     * @param nMotors   the motors to turn off
     * @return the created State
     */
    public static State stop(StateName stateName, final NMotors nMotors) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                nMotors.stop();
            }

            @Override
            public boolean isDone() {
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName      the name of the state
     * @param mecanumControl the motors to turn off
     * @return the created State
     */
    public static State stop(StateName stateName, final MecanumControl mecanumControl) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                mecanumControl.stop();
            }

            @Override
            public boolean isDone() {
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName the name of the state
     * @param message   the message to display to the driver station
     * @param value     the value associated with that message
     * @return the created State
     */
    public static State telemetry(StateName stateName, final String message, final double value) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                telemetry.addData(message, value);
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName the name of the state
     * @param message1  the first message to display to the driver station
     * @param input1    an InputExtractor that returns the value associated with the first message
     * @param message2  the second message to display to the driver station
     * @param input2    an InputExtractor that returns the value associated with the second message
     * @return the created State
     */
    public static State telemetry(StateName stateName, final String message1, final InputExtractor&lt;Double&gt; input1, final String message2, final InputExtractor&lt;Double&gt; input2) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                telemetry.addData(message1, input1.getValue());
                telemetry.addData(message2, input2.getValue());
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName   the name of the state
     * @param transitions the list of transitions to the next states
     * @param message     the message to display to the driver station
     * @param value       the value associated with that message
     * @return the created State
     */
    public static State telemetry(StateName stateName, List&lt;Transition&gt; transitions, final String message, final double value) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
            }

            @Override
            public void run() {
                telemetry.addData(message, value);
            }

            @Override
            public void dispose() {
            }
        };
    }

    /**
     * @param stateName   the name of the state
     * @param transitions the list of transitions to the next states
     * @param message1    the first message to display to the driver station
     * @param input1      an InputExtractor that returns the value associated with the first message
     * @param message2    the second message to display to the driver station
     * @param input2      an InputExtractor that returns the value associated with the second message
     * @return the created State
     */
    public static State telemetry(StateName stateName, List&lt;Transition&gt; transitions, final String message1, final InputExtractor&lt;Double&gt; input1, final String message2, final InputExtractor&lt;Double&gt; input2) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
            }

            @Override
            public void run() {
                telemetry.addData(message1, input1.getValue());
                telemetry.addData(message2, input2.getValue());
            }

            @Override
            public void dispose() {
            }
        };
    }

    /**
     * @param stateName     the name of the state
     * @param nextStateName the name of the next state
     * @param servos        the servos to be initialized
     * @return the created State
     * @see Servos
     */
    public static State servoInit(StateName stateName, final StateName nextStateName, final Servos servos) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return servos.areServosDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * @param stateName     the name of the state
     * @param nextStateName the name of the next state
     * @param gyro          the gyro sensor to be calibrated
     * @return the created State
     * @see GyroSensor
     */
    public static State calibrateGyro(StateName stateName, final StateName nextStateName, final GyroSensor gyro) {
        gyro.calibrate();
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return !gyro.isCalibrating();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * @param stateName        the name of the state
     * @param nextStateName    the name of the next state
     * @param doubleLineSensor the 2 line sensors to be calibrated
     * @return the created State
     * @see DoubleLineSensor
     */
    public static State calibrateLineSensor(StateName stateName, final StateName nextStateName, final DoubleLineSensor doubleLineSensor) {
        doubleLineSensor.calibrate();
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return doubleLineSensor.isReady();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * Turn a servo to a preset at max speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPreset   the preset to go to
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, StateName nextStateName, ServoControl servoControl, Enum servoPreset, boolean waitForDone) {
        return servoTurn(stateName, nextStateName, servoControl, servoPreset, ServoControl.MAX_SPEED, waitForDone);
    }

    /**
     * Turn a servo to a preset at a given speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPreset   the preset to go to
     * @param speed         the speed to turn the servo at
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, final StateName nextStateName, final ServoControl servoControl, final Enum servoPreset, final double speed, final boolean waitForDone) {
        return new BasicAbstractState(stateName) {

            @Override
            public void init() {
                servoControl.goToPreset(servoPreset, speed);
            }

            @Override
            public boolean isDone() {
                return !waitForDone || servoControl.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * Turn a servo to a position at max speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPosition the position to go to
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, StateName nextStateName, ServoControl servoControl, double servoPosition, boolean waitForDone) {
        return servoTurn(stateName, nextStateName, servoControl, servoPosition, ServoControl.MAX_SPEED, waitForDone);
    }

    /**
     * Turn a servo to a position at a given speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPosition the position to go to
     * @param speed         the speed to turn the servo at
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, final StateName nextStateName, final ServoControl servoControl, final double servoPosition, final double speed, final boolean waitForDone) {
        return new BasicAbstractState(stateName) {

            @Override
            public void init() {
                servoControl.setPosition(servoPosition, speed);
            }

            @Override
            public boolean isDone() {
                return !waitForDone || servoControl.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }


    /**
     * drive using the mecanum wheels
     * travels for a certain amount of time defined by the robots speed and a desired distance
     *
     * @param stateName       the name of the state
     * @param nextStateName   the next state to go to
     * @param distance        the distance to travel
     * @param mecanumControl  the mecanum wheels
     * @param gyro            the gyro sensor
     * @param velocity        the velocity to drive at
     * @param direction       the direction to drive
     * @param orientation     the angle to rotate to
     * @param maxAngularSpeed the max speed to rotate to that angle
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     * @see Distance
     */
    public static State mecanumDrive(StateName stateName, final StateName nextStateName, Distance distance, final MecanumControl mecanumControl, final GyroSensor gyro, final double velocity, final Angle direction, final Angle orientation, final Angle tolerance, final double maxAngularSpeed) {
        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);
        double speedMetersPerMillisecond = mecanumControl.getMaxRobotSpeed().metersPerMillisecond() * velocity;
        final double durationMillis = Math.abs(distance.meters() / speedMetersPerMillisecond);
        final EndCondition gyroEC = EVEndConditions.gyroCloseTo(gyro, orientation, tolerance);
        return new BasicAbstractState(stateName) {
            long startTime = 0;

            @Override
            public void init() {
                mecanumControl.setControl(
                        TranslationControls.constant(velocity, direction),
                        RotationControls.gyro(gyro, orientation, maxAngularSpeed)
                );
                startTime = System.currentTimeMillis();
            }

            @Override
            public boolean isDone() {
                long now = System.currentTimeMillis();
                long elapsedTime = now - startTime;
                if (elapsedTime &gt;= durationMillis) {
                    mecanumControl.setTranslationControl(TranslationControls.ZERO);
                    return gyroEC.isDone();
                }
                return false;
            }

            @Override
            public StateName getNextStateName() {
                mecanumControl.stop();
                return nextStateName;
            }
        };
    }

    /**
     * drive using the mecanum wheels
     *
     * @param stateName       the name of the state
     * @param transitions     the list of transitions to the next states
     * @param mecanumControl  the mecanum wheels
     * @param gyro            the gyro sensor
     * @param velocity        the velocity to drive at
     * @param direction       the direction to drive
     * @param orientation     the angle to rotate to
     * @param maxAngularSpeed the max speed to rotate to that angle
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     */
    public static State mecanumDrive(StateName stateName, List&lt;Transition&gt; transitions, final MecanumControl mecanumControl, final GyroSensor gyro, final double velocity, final Angle direction, final Angle orientation, final double maxAngularSpeed) {
        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
//                OptionsFile optionsFile = new OptionsFile(EVConverters.getInstance(), FileUtil.getOptionsFile(&quot;AutoOptions.txt&quot;));
//
//                double max = optionsFile.get(&quot;gyro_max&quot;, Double.class);
//                double gain = optionsFile.get(&quot;gyro_gain&quot;, Double.class);

                mecanumControl.setControl(
                        TranslationControls.constant(velocity, direction),
                        RotationControls.gyro(gyro, orientation, maxAngularSpeed)
//                        RotationControls.gyro(gyro, orientation, max, false, gain)
                );
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                mecanumControl.stop();
            }
        };
    }

    /**
     * @param stateName      the name of the state
     * @param transitions    the list of transitions to the next states
     * @param mecanumControl the mecanum wheels
     * @param gyro           the gyro sensor
     * @param velocity       the velocity to drive at
     * @param direction      the direction to drive
     * @param orientation    the angle to rotate to
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     */
    public static State mecanumDrive(StateName stateName, List&lt;Transition&gt; transitions, MecanumControl mecanumControl, GyroSensor gyro, double velocity, Angle direction, Angle orientation) {
        return mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, direction, orientation, RotationControl.DEFAULT_MAX_ANGULAR_SPEED);
    }

    /**
     * drive using the mecanum wheels
     * travels for a certain amount of time defined by the robots speed and a desired distance
     *
     * @param stateName      the name of the state
     * @param nextStateName  the next state to go to
     * @param distance       the distance to travel
     * @param mecanumControl the mecanum wheels
     * @param gyro           the gyro sensor
     * @param velocity       the velocity to drive at
     * @param direction      the direction to drive
     * @param orientation    the angle to rotate to
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     * @see Distance
     */
    public static State mecanumDrive(StateName stateName, StateName nextStateName, Distance distance, final MecanumControl mecanumControl, final GyroSensor gyro, final double velocity, final Angle direction, final Angle orientation, final Angle tolerance) {
        return mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance, RotationControl.DEFAULT_MAX_ANGULAR_SPEED);
    }

    /**
     * follow a line with the mecanum wheels
     *
     * @param stateName           the name of the state
     * @param transitions         the list of transitions to the next states
     * @param lostLineState       what state to go to if the line is lost
     * @param mecanumControl      the mecanum wheels
     * @param doubleLineSensor    the 2 line sensors
     * @param velocity            the velocity to drive at
     * @param lineFollowDirection the direction (left or right) to follow the line at
     * @return the created State
     * @see MecanumControl
     * @see TranslationControls
     */
    public State mecanumLineFollow(StateName stateName, List&lt;Transition&gt; transitions, StateName lostLineState, final MecanumControl mecanumControl, final DoubleLineSensor doubleLineSensor, final double velocity, final TranslationControls.LineFollowDirection lineFollowDirection) {
        transitions.add(new Transition(new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return !mecanumControl.translationWorked();
            }
        }, lostLineState));

        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);

        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                mecanumControl.setTranslationControl(TranslationControls.lineFollow(doubleLineSensor, lineFollowDirection, velocity));
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                mecanumControl.stop();
            }
        };
    }


    /**
     * Drive forward or backward with two motors
     *
     * @param stateName   the name of the state
     * @param transitions the transitions to new states
     * @param twoMotors   the motors to move
     * @param velocity    the velocity to drive at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State drive(StateName stateName, List&lt;Transition&gt; transitions, final TwoMotors twoMotors, final double velocity) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                twoMotors.runMotors(velocity, velocity);
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                twoMotors.runMotors(0, 0);
            }
        };
    }

    /**
     * Turn left or right
     *
     * @param stateName   the name of the state
     * @param transitions the transitions to new states
     * @param twoMotors   the motors to move
     * @param velocity    the velocity to turn at (negative for turning left)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, List&lt;Transition&gt; transitions, final TwoMotors twoMotors, final double velocity) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                twoMotors.runMotors(velocity, -velocity);
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                twoMotors.runMotors(0, 0);
            }
        };
    }

    /**
     * Turn with one wheel
     *
     * @param stateName    the name of the state
     * @param transitions  the transitions to new states
     * @param twoMotors    the motors to move
     * @param isRightWheel tells which wheel to turn
     * @param velocity     the velocity to turn the wheel at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State oneWheelTurn(StateName stateName, List&lt;Transition&gt; transitions, final TwoMotors twoMotors, final boolean isRightWheel, final double velocity) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                if (isRightWheel) {
                    twoMotors.runMotors(0, velocity);
                } else {
                    twoMotors.runMotors(velocity, 0);
                }
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                twoMotors.runMotors(0, 0);
            }
        };
    }


    /**
     * Drive for a certain distance
     *
     * @param stateName     the name of the state
     * @param nextStateName the state to go to after the drive is done
     * @param distance      the distance to drive
     * @param twoMotors     the motors to move
     * @param velocity      the velocity to drive at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State drive(StateName stateName, StateName nextStateName, Distance distance, TwoMotors twoMotors, double velocity) {
        double speedMetersPerMillisecond = twoMotors.getMaxRobotSpeed().metersPerMillisecond() * velocity;
        double durationMillis = Math.abs(distance.meters() / speedMetersPerMillisecond);
        return drive(stateName, ImmutableList.of(
                new Transition(
                        EndConditions.timed((long) durationMillis),
                        nextStateName
                )
        ), twoMotors, velocity);
    }

    /**
     * Turn for a certain angle by calculating the time required for that angle
     *
     * @param stateName        the name of the state
     * @param nextStateName    the state to go to when done turning
     * @param angle            the angle to turn
     * @param minRobotTurnTime the time it takes for the robot to turn
     * @param twoMotors        the motors to run
     * @param velocity         the velocity to turn (negative for turning left)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, StateName nextStateName, Angle angle, Time minRobotTurnTime, TwoMotors twoMotors, double velocity) {
        double speedRotationsPerMillisecond = velocity / minRobotTurnTime.milliseconds();
        double durationMillis = Math.abs(angle.degrees() / 360 / speedRotationsPerMillisecond);
        return turn(stateName, ImmutableList.of(
                new Transition(
                        EndConditions.timed((long) durationMillis),
                        nextStateName
                )
        ), twoMotors, velocity);
    }

    /**
     * Turn for a certain angle using a gyro sensor
     *
     * @param stateName     the name of the state
     * @param nextStateName the state to go to when done turning
     * @param angle         the angle to turn
     * @param gyro          the gyro sensor to use
     * @param twoMotors     the motors to turn
     * @param velocity      the velocity to turn at (negative to turn left)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, StateName nextStateName, Angle angle, GyroSensor gyro, TwoMotors twoMotors, double velocity) {
        return turn(stateName, ImmutableList.of(
                new Transition(
                        EVEndConditions.gyroCloseToRelative(gyro, angle, Angle.fromDegrees(5)),
                        nextStateName
                )
        ), twoMotors, velocity);
    }

    /**
     * Turn with one wheel for a certain angle by calculating the time needed to turn that angle
     *
     * @param stateName        the name of the state
     * @param nextStateName    the state to go to when done turning
     * @param angle            the angle to turn
     * @param minRobotTurnTime the time it takes for the robot to turn
     * @param twoMotors        the motors to turn
     * @param isRightWheel     tells which wheel to turn
     * @param velocity         the velocity to turn the wheel at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State oneWheelTurn(StateName stateName, StateName nextStateName, Angle angle, Time minRobotTurnTime, TwoMotors twoMotors, boolean isRightWheel, double velocity) {
        double speedRotationsPerMillisecond = velocity / minRobotTurnTime.milliseconds();
        double durationMillis = Math.abs(2 * angle.degrees() / 360 / speedRotationsPerMillisecond);
        velocity = Math.abs(velocity) * Math.signum(angle.radians());
        if (isRightWheel) {
            velocity *= -1;
        }
        return oneWheelTurn(stateName, ImmutableList.of(
                new Transition(
                        EndConditions.timed((long) durationMillis),
                        nextStateName
                )
        ), twoMotors, isRightWheel, velocity);
    }

    /**
     * Turn with one wheel for a certain angle using a gyro sensor
     *
     * @param stateName     the name of the state
     * @param nextStateName the state to go to after the turn is done
     * @param angle         the angle to turn
     * @param gyro          the gyro sensor to use
     * @param twoMotors     the motors to turn
     * @param isRightWheel  which wheel to use
     * @param velocity      the velocity to turn the wheel at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, StateName nextStateName, Angle angle, GyroSensor gyro, TwoMotors twoMotors, boolean isRightWheel, double velocity) {
        velocity = Math.abs(velocity) * Math.signum(angle.radians());
        if (isRightWheel) {
            velocity *= -1;
        }
        return oneWheelTurn(stateName, ImmutableList.of(
                new Transition(
                        EVEndConditions.gyroCloseToRelative(gyro, angle, Angle.fromDegrees(5)),
                        nextStateName
                )
        ), twoMotors, isRightWheel, velocity);
    }

    /**
     * Turn a motor at a given power
     *
     * @param stateName   the name of the state
     * @param transitions the transitions to new states
     * @param motor       the motor to be turned
     * @param power       the power to turn the motor at
     * @return the created State
     * @see TwoMotors
     */
    public static State motorTurn(StateName stateName, List&lt;Transition&gt; transitions, final Motor motor, final double power) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                motor.setPower(power);
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                motor.setPower(0);
            }
        };
    }

    /**
     * Line up with the beacon using the line sensor array and distance sensor
     *
     * @param stateName         the name of the state
     * @param successState      the state to go to if the line up succeeds
     * @param failState         the state to go to if the line up fails
     * @param mecanumControl    the mecanum wheels
     * @param direction         the direction angle to face
     * @param gyro              the gyro to use for rotation stabilization
     * @param distSensor        the distance sensor to detect distance from the beacon
     * @param lineSensorArray   the line sensor array to line up sideways with the line
     * @param teamColor         the team you are on and ...
     * @param beaconColorResult ... the beacon configuration to decide which button to line up with
     * @param distance          the distance from the beacon to line up to
     * @return the created State
     * @see LineUpControl
     */
    public static State beaconLineUp(StateName stateName, final StateName successState, final StateName failState, final MecanumControl mecanumControl, final Angle direction, final GyroSensor gyro, final DistanceSensor distSensor, final LineSensorArray lineSensorArray, TeamColor teamColor, final ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult, final Distance distance) {
//        final EndCondition distEndCondition = EVEndConditions.distanceSensorLess(distSensor, Distance.add(distance, Distance.fromInches(4)));
        final EndCondition distEndCondition = EVEndConditions.distanceSensorLess(distSensor, distance);
        final EndCondition gyroEndCondition = EVEndConditions.gyroCloseTo(gyro, direction, 2);

        final BeaconColorResult.BeaconColor myColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor);
        final BeaconColorResult.BeaconColor opponentColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor.opposite());

        return new BasicAbstractState(stateName) {
            private boolean success;
            LineUpControl.Button buttonToLineUpWith;

            @Override
            public void init() {
                buttonToLineUpWith = null;
                if (beaconColorResult.isReady()) {
                    BeaconColorResult result = beaconColorResult.getValue();
                    BeaconColorResult.BeaconColor leftColor = result.getLeftColor();
                    BeaconColorResult.BeaconColor rightColor = result.getRightColor();
                    if (leftColor == myColor &amp;&amp; rightColor == opponentColor) {
                        buttonToLineUpWith = LineUpControl.Button.LEFT;
                    }
                    if (leftColor == opponentColor &amp;&amp; rightColor == myColor) {
                        buttonToLineUpWith = LineUpControl.Button.RIGHT;
                    }
                }

                success = buttonToLineUpWith != null;

                LineUpControl lineUpControl = new LineUpControl(lineSensorArray, buttonToLineUpWith, distSensor, distance, gyro, direction);

                mecanumControl.setTranslationControl(lineUpControl);
                mecanumControl.setRotationControl(lineUpControl);

                distEndCondition.init();
                gyroEndCondition.init();
            }

            @Override
            public boolean isDone() {

                if (!mecanumControl.translationWorked()) {
                    success = false;
                }
                return !success || distEndCondition.isDone();
            }

            @Override
            public StateName getNextStateName() {
                mecanumControl.stop();
                return success ? successState : failState;
            }
        };
    }

    public static State shoot(StateName stateName, final StateName nextStateName, final Shooter shooter, final int shots) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                shooter.shoot(shots);
            }

            @Override
            public boolean isDone() {
//                shooter.act();
                return shooter.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    public static State gyroStabilize(StateName stateName, StateName nextStateName, final MecanumControl mecanumControl, final GyroSensor gyro, final Angle orientation, Angle tolerance) {
        List&lt;Transition&gt; transitions = ImmutableList.of(
                new Transition(EVEndConditions.gyroCloseTo(gyro, orientation, tolerance), nextStateName)
        );

        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                mecanumControl.setTranslationControl(TranslationControls.ZERO);
                mecanumControl.setRotationControl(RotationControls.gyro(gyro, orientation));
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                mecanumControl.stop();
            }
        };
    }

    public static State switchPressed(StateName stateName, StateName pressedStateName, StateName timeoutStateName, DigitalSensor digitalSensor, Time timeout) {
        return empty(stateName, ImmutableList.of(
                new Transition(EndConditions.inputExtractor(digitalSensor), pressedStateName),
                new Transition(EndConditions.timed((long) timeout.milliseconds()), timeoutStateName)
        ));
    }

    public static State initShooter(StateName stateName, final StateName nextStateName, final Shooter shooter) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                shooter.initialize();
            }

            @Override
            public boolean isDone() {
                return shooter.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }


    public static State beaconColorSwitch(StateName stateName, final StateName leftButtonState, final StateName rightButtonState, final StateName unknownState, TeamColor teamColor, final ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult) {

        final BeaconColorResult.BeaconColor myColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor);
        final BeaconColorResult.BeaconColor opponentColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor.opposite());

        return new BasicAbstractState(stateName) {
            private StateName nextState = unknownState;

            @Override
            public void init() {
                if (beaconColorResult.isReady()) {
                    BeaconColorResult result = beaconColorResult.getValue();
                    BeaconColorResult.BeaconColor leftColor = result.getLeftColor();
                    BeaconColorResult.BeaconColor rightColor = result.getRightColor();
                    if (leftColor == myColor &amp;&amp; rightColor == opponentColor) {
                        nextState = leftButtonState;
                    }
                    if (leftColor == opponentColor &amp;&amp; rightColor == myColor) {
                        nextState = rightButtonState;
                    }
                }

            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                return nextState;
            }
        };
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="evlib/EVStates.html">EVStates</a> | <strong>EVEndConditions</strong> | <a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></p>
<hr />
<p>EVEndConditions is a factory class that extends EndConditions from the state-machine-framework. It inherits all the factory methods from EndConditions, and adds its own that relate to FTC.</p>
<p>Some of the useful ones are:</p>
<ul>
<li><strong>analogSensorGreater</strong> -- waits for an <a href="evlib/Analog-Sensors.html">AnalogSensor</a> to be greater than a certain value</li>
<li><strong>analogSensorLess</strong> -- waits for an <a href="evlib/Analog-Sensors.html">AnalogSensor</a> to be less than a certain value</li>
<li><strong>gyroCloseTo</strong> -- waits for a gyro sensor to be close to a certain value</li>
<li><strong>distanceSensorGreater</strong> -- waits for a <a href="evlib/DistanceSensor.html">DistanceSensor</a> to be greater than a certain value</li>
<li><strong>distanceSensorLess</strong> -- waits for a <a href="evlib/DistanceSensor.html">DistanceSensor</a> to be less than a certain value</li>
</ul>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/statemachine/EVEndConditions.java">ftc/evlib/statemachine/EVEndConditions.java</a></p>
<pre><code class="language-java">package ftc.evlib.statemachine;

import com.qualcomm.robotcore.hardware.GyroSensor;

import ftc.electronvolts.statemachine.EndCondition;
import ftc.electronvolts.statemachine.EndConditions;
import ftc.electronvolts.util.Vector2D;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.sensors.AnalogSensor;
import ftc.evlib.hardware.sensors.ColorSensor;
import ftc.evlib.hardware.sensors.DistanceSensor;
import ftc.evlib.hardware.sensors.DoubleLineSensor;
import ftc.evlib.hardware.sensors.LineFinder;
import ftc.evlib.hardware.sensors.LineSensorArray;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 5/10/16
 * &lt;p&gt;
 * Factory class for EndCondition
 * extends EndConditions, which has some useful factory methods already
 *
 * @see EndCondition
 * @see EndConditions
 */
public class EVEndConditions extends EndConditions {

    /**
     * wait for a line of any color
     *
     * @param doubleLineSensor   the two line sensors
     * @param detectionsRequired the number of detections in a row to look for (to avoid false positives)
     * @return the created EndCondition
     * @see DoubleLineSensor
     */
    public static EndCondition foundLine(final DoubleLineSensor doubleLineSensor, final int detectionsRequired) {
        return new EndCondition() {
            int detections;

            @Override
            public void init() {
                detections = 0;
            }

            @Override
            public boolean isDone() {
                DoubleLineSensor.LinePosition linePosition = doubleLineSensor.getPosition();
                if (linePosition == DoubleLineSensor.LinePosition.LEFT || linePosition == DoubleLineSensor.LinePosition.MIDDLE || linePosition == DoubleLineSensor.LinePosition.RIGHT) {
                    detections++;
                    if (detections &gt; detectionsRequired) {
                        return true;
                    }
                } else {
                    detections = 0;
                }
                return false;
            }
        };
    }

    /**
     * wait for a line of a certain color
     *
     * @param lineFinder         two line sensors and a reflective color sensor
     * @param lineColor          the color of line to look for
     * @param detectionsRequired the number of detections in a row to look for (to avoid false positives)
     * @return the created EndCondition
     * @see LineFinder
     */
    public static EndCondition foundColoredLine(final LineFinder lineFinder, final LineFinder.LineColor lineColor, final int detectionsRequired) {
        return new EndCondition() {
            int detections;

            @Override
            public void init() {
                detections = 0;
                lineFinder.startLookingFor(lineColor);
            }

            @Override
            public boolean isDone() {
                if (lineFinder.getValue()) {
                    detections++;
                    if (detections &gt; detectionsRequired) {
                        return true;
                    }
                } else {
                    detections = 0;
                }
                return false;
            }
        };
    }

    /**
     * look for a value from a sensor that is greater/less than a target value
     *
     * @param analogSensor the sensor
     * @param target       the target sensor value
     * @param greater      true if the sensor value needs to be greater than the target value
     * @return the created EndCondition
     * @see AnalogSensor
     */
    public static EndCondition analogSensor(final AnalogSensor analogSensor, final double target, final boolean greater) {
        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                if (greater) {
                    return (analogSensor.getValue() &gt;= target);
                } else {
                    return (analogSensor.getValue() &lt;= target);
                }
            }
        };
    }

    /**
     * look for a value from a sensor that is greater than a target value
     *
     * @param analogSensor the sensor
     * @param value        the target value
     * @return the created EndCondition
     * @see AnalogSensor
     */
    public static EndCondition analogSensorGreater(AnalogSensor analogSensor, double value) {
        return analogSensor(analogSensor, value, true);
    }

    /**
     * look for a value from a sensor that is less than a target value
     *
     * @param analogSensor the sensor
     * @param value        the target value
     * @return the created EndCondition
     * @see AnalogSensor
     */
    public static EndCondition analogSensorLess(AnalogSensor analogSensor, double value) {
        return analogSensor(analogSensor, value, false);
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro             the gyro sensor
     * @param targetDegrees    the target value (in degrees)
     * @param toleranceDegrees the accepted tolerance to be considered &quot;close to&quot; (in degrees)
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(GyroSensor gyro, double targetDegrees, double toleranceDegrees) {
        return gyroCloseTo(gyro, Angle.fromDegrees(targetDegrees), Angle.fromDegrees(toleranceDegrees));
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro             the gyro sensor
     * @param target           the target value
     * @param toleranceDegrees the accepted tolerance to be considered &quot;close to&quot; (in degrees)
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(GyroSensor gyro, Angle target, double toleranceDegrees) {
        return gyroCloseTo(gyro, target, Angle.fromDegrees(toleranceDegrees));
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro          the gyro sensor
     * @param targetDegrees the target value (in degrees)
     * @param tolerance     the accepted tolerance to be considered &quot;close to&quot;
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(GyroSensor gyro, double targetDegrees, Angle tolerance) {
        return gyroCloseTo(gyro, Angle.fromDegrees(targetDegrees), tolerance);
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro      the gyro sensor
     * @param target    the target value
     * @param tolerance the accepted tolerance to be considered &quot;close to&quot;
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(final GyroSensor gyro, Angle target, final Angle tolerance) {
        final Vector2D targetVector = new Vector2D(1, target);
        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                Vector2D gyroVector = new Vector2D(1, Angle.fromDegrees(gyro.getHeading()));
                Angle separation = Vector2D.signedAngularSeparation(targetVector, gyroVector);
                return Math.abs(separation.radians()) &lt;= tolerance.radians();
            }
        };
    }

    /**
     * wait until the gyro heading is close to a target value relative to the starting heading
     *
     * @param gyro      the gyro sensor
     * @param target    the target value relative to the starting heading
     * @param tolerance the accepted tolerance to be considered &quot;close to&quot;
     * @return the created State
     * @see GyroSensor
     */
    public static EndCondition gyroCloseToRelative(final GyroSensor gyro, Angle target, final Angle tolerance) {
        final Vector2D targetVector = new Vector2D(1, target);
        return new EndCondition() {
            double gyroInit = 0;

            @Override
            public void init() {
                gyroInit = gyro.getHeading();
            }

            @Override
            public boolean isDone() {
                Vector2D gyroVector = new Vector2D(1, Angle.fromDegrees(gyro.getHeading() - gyroInit));
                Angle separation = Vector2D.signedAngularSeparation(targetVector, gyroVector);
                return Math.abs(separation.degrees()) &lt;= tolerance.degrees();
            }
        };
    }

    /**
     * wait for a reflection of red light with a color sensor
     *
     * @param colorSensor the sensor
     * @return the created EndCondition
     * @see ColorSensor
     */
    public static EndCondition colorSensorRedLight(final ColorSensor colorSensor) {
        return new EndCondition() {
            @Override
            public void init() {
                colorSensor.setColorRed();
            }

            @Override
            public boolean isDone() {
                return colorSensor.getValue();
            }
        };
    }

    /**
     * wait for a reflection of blue light with a color sensor
     *
     * @param colorSensor the sensor
     * @return the created EndCondition
     * @see ColorSensor
     */
    public static EndCondition colorSensorBlueLight(final ColorSensor colorSensor) {
        return new EndCondition() {
            @Override
            public void init() {
                colorSensor.setColorBlue();
            }

            @Override
            public boolean isDone() {
                return colorSensor.getValue();
            }
        };
    }

    /**
     * Wait for any sensor to activate on a line sensor array
     *
     * @param lineSensorArray the sensor
     * @return the created State
     * @see LineSensorArray
     */
    public static EndCondition lineSensorArrayAny(final LineSensorArray lineSensorArray) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return lineSensorArray.getNumSensorsActive() &gt; 0;
            }
        };
    }

    /**
     * Wait for a distance sensor to cross a threshold
     *
     * @param distanceSensor the distance sensor
     * @param target         the target value
     * @param greater        whether to wait for the sensor to be greater or less than the target
     * @return the created State
     * @see DistanceSensor
     */
    public static EndCondition distanceSensor(final DistanceSensor distanceSensor, final Distance target, final boolean greater) {
        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                if (greater) {
                    return (distanceSensor.getDistance().meters() &gt;= target.meters());
                } else {
                    return (distanceSensor.getDistance().meters() &lt;= target.meters());
                }
            }
        };
    }

    /**
     * Wait for a distance sensor to be less than a certain distance
     *
     * @param distanceSensor the distance sensor
     * @param target         the target Distance
     * @return the created State
     * @see DistanceSensor
     */
    public static EndCondition distanceSensorLess(DistanceSensor distanceSensor, Distance target) {
        return distanceSensor(distanceSensor, target, false);
    }

    /**
     * Wait for a distance sensor to be greater than a certain distance
     *
     * @param distanceSensor the distance sensor
     * @param target         the target Distance
     * @return the created State
     * @see DistanceSensor
     */
    public static EndCondition distanceSensorGreater(DistanceSensor distanceSensor, Distance target) {
        return distanceSensor(distanceSensor, target, true);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="evlib/EVStates.html">EVStates</a> | <a href="evlib/EVEndConditions.html">EVEndConditions</a> | <strong>EVStateMachineBuilder</strong></p>
<hr />
<p>EVStateMachineBuilder is a builder class that extends StateMachineBuilder from the state-machine-framework. It inherits all the convenience methods from StateMachineBuilder, and adds its own that relate to FTC.</p>
<p>When you create the EVStateMachineBuilder, you pass in servos, sensors, motors, etc. Then you can call the convenience methods to add servo states, drive states, etc. without passing in the objects again. If you don't have one of the object, a gyro for example, you can pass in a null value and not use any of the gyro convenience methods.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/statemachine/EVStateMachineBuilder.java">ftc/evlib/statemachine/EVStateMachineBuilder.java</a></p>
<pre><code class="language-java">package ftc.evlib.statemachine;

import com.qualcomm.robotcore.hardware.GyroSensor;

import java.util.List;

import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.statemachine.Transition;
import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.control.MecanumControl;
import ftc.evlib.hardware.mechanisms.Shooter;
import ftc.evlib.hardware.sensors.DistanceSensor;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.hardware.servos.Servos;
import ftc.evlib.vision.framegrabber.FrameGrabber;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 5/10/16
 * &lt;p&gt;
 * Builder that uses the EVStates Factory class to create states and build them into a StateMachine
 * extends StateMachineBuilder which has the basic builder methods as well as some useful addXYZ methods
 *
 * @see EVStates
 * @see StateMachineBuilder
 */
public class EVStateMachineBuilder extends StateMachineBuilder {
    private final TeamColor teamColor;
    private final Angle tolerance;
    private final MecanumControl mecanumControl;
    private final GyroSensor gyro;
    private final FrameGrabber frameGrabber;
    private final Servos servos;
    private final DistanceSensor distanceSensor;
    private final Shooter shooter;

    /**
     * any of the parameters can be null if the robot does not have it
     *
     * @param firstStateName the state to start with
     * @param teamColor      the alliance you are on
     * @param tolerance      the tolerance on gyro angles
     * @param gyro           the gyro sensor
     * @param frameGrabber   access to the camera
     * @param servos         the servos
     * @param distanceSensor the distance sensor
     * @param mecanumControl the mecanum wheel controller
     * @param shooter        the helper class for the mecanism that shoots the particles
     */
    public EVStateMachineBuilder(StateName firstStateName, TeamColor teamColor, Angle tolerance, GyroSensor gyro, FrameGrabber frameGrabber, Servos servos, DistanceSensor distanceSensor, MecanumControl mecanumControl, Shooter shooter) {
        super(firstStateName);
        this.teamColor = teamColor;
        this.tolerance = tolerance;
        this.mecanumControl = mecanumControl;
        this.gyro = gyro;
        this.frameGrabber = frameGrabber;
        this.servos = servos;
        this.distanceSensor = distanceSensor;
        this.shooter = shooter;
    }

    public EVStateMachineBuilder(StateName firstStateName, EVStateMachineBuilder b) {
        this(firstStateName, b.teamColor, b.tolerance, b.gyro, b.frameGrabber, b.servos, b.distanceSensor, b.mecanumControl, b.shooter);
    }

//    public void addCameraTracking(StateName stateName, StateName doneState, StateName lostObjectState, long timeoutMillis, StateName timeoutState, ImageProcessor&lt;? extends Location&gt; imageProcessor) {
//        add(EVStates.mecanumCameraTrack(stateName, doneState, lostObjectState, timeoutMillis, timeoutState, mecanumControl, frameGrabber, imageProcessor));
//    }

    //convenience methods for adding different types of States

    public void addServoInit(StateName stateName, StateName nextStateName) {
        add(EVStates.servoInit(stateName, nextStateName, servos));
    }

    public void addCalibrateGyro(StateName stateName, StateName nextStateName) {
        add(EVStates.calibrateGyro(stateName, nextStateName, gyro));
    }

    public void addStop(StateName stateName) {
        add(EVStates.stop(stateName, mecanumControl));
    }

    ///// START DRIVE STATES /////
    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, double directionDegrees, double orientationDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees), maxAngularSpeed));
    }

    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, double directionDegrees, double orientationDegrees) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees)));
    }

    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, Angle direction, Angle orientation, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, direction, orientation, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, Angle direction, Angle orientation) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, direction, orientation));
    }


    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, double directionDegrees, double orientationDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees), tolerance, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, double directionDegrees, double orientationDegrees) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees), tolerance));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation, Angle tolerance, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation, Angle tolerance) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance));
    }
    ///// END DRIVE STATES /////

    ///// START TURN STATES /////
    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, double orientationDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees), maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, double orientationDegrees) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees)));
    }

    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, Angle orientation, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), orientation, maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, Angle orientation) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), orientation));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, double orientationDegrees, double toleranceDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees), Angle.fromDegrees(toleranceDegrees), maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, double orientationDegrees, double toleranceDegrees) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees), Angle.fromDegrees(toleranceDegrees)));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, Angle orientation, Angle tolerance, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), orientation, tolerance, maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, Angle orientation, Angle tolerance) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), orientation, tolerance));
    }
    ///// END TURN STATES /////

    ///// START SERVO STATES /////
    private ServoControl getServo(ServoName servoName) {
        if (!servos.getServoMap().containsKey(servoName)) {
            throw new IllegalArgumentException(&quot;ServoName \&quot;&quot; + servoName + &quot;\&quot; was not found in the servoMap&quot;);
        }
        return servos.getServoMap().get(servoName);

    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, double position, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), position, waitForDone));
    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, double position, double speed, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), position, speed, waitForDone));
    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum preset, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), preset, waitForDone));
    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum preset, double speed, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), preset, speed, waitForDone));
    }
    ///// END SERVO STATES /////

    public void addTelem(StateName stateName, String message, double value, List&lt;Transition&gt; transitions) {
        add(EVStates.telemetry(stateName, transitions, message, value));
    }

    public void addTelem(StateName stateName, String message, double value) {
        add(EVStates.telemetry(stateName, message, value));
    }

//    public void addBeaconLineUp(StateName stateName, StateName successState, StateName failState, Angle direction, ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult, Distance distance) {
//        add(EVStates.beaconLineUp(stateName, successState, failState, mecanumControl, direction, gyro, distanceSensor, lineSensorArray, teamColor, beaconColorResult, distance));
//    }

    public void addShoot(StateName stateName, StateName nextStateName, int shots) {
        add(EVStates.shoot(stateName, nextStateName, shooter, shots));
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In EVLib there are 2 types of motors. Motor, which has no encoder, and MotorEnc, which has an encoder. A MotorEnc extends Motor, which means that you can use a motor with an encoder as a motor without an encoder. To create instances of these, see the <a href="evlib/Creating-Motors.html">Creating Motors</a> page.</p>
<p>The interface for Motor has only a few methods, and the only way to control it is by setting the power.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/Motor.java">ftc/evlib/hardware/motors/Motor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/11/16
 * 
 * Wrapper class for the DcMotor.
 * This represents the functions a motor without an encoder can do.
 *
 * @see MotorEnc
 * @see Motors
 */
public interface Motor {
    /**
     * The different modes the motor can be in
     */
    enum Mode {
        POWER, //directly control the power
        SPEED, //enable a feedback loop to correct speed (requires encoders)
        POSITION //turn the motor to a certain encoder position (requires encoders)
    }

    /**
     * Control the motor's raw voltage
     *
     * @param power value to set the power to
     */
    void setPower(double power);

    /**
     * Tells the mode the motor is in which is determined by the last command to the motor.
     *
     * @return the current mode
     */
    Mode getMode();

    /**
     * Sends motor commands to the motor controller
     */
    void update();
}
</code></pre>
<p>The MotorEnc interface has all the methods from Motor, plus the ones for the encoder-related functions.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/MotorEnc.java">ftc/evlib/hardware/motors/MotorEnc.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * Wrapper class for DcMotor if the motor has an encoder
 * This interface has all the non-encoder methods from the Motor interface plus the ones shown here.
 * It can be passed in where a non-encoder Motor interface is needed.
 *
 * @see Motor
 * @see Motors
 */
public interface MotorEnc extends Motor {
    /**
     * A PID on the motor controller uses the encoder to regulate the speed of the motor.
     *
     * @param speed value to set the speed to
     */
    void setSpeed(double speed);

    /**
     * A PID on the motor controller uses the encoder to turn the motor to any encoder position.
     *
     * @param encoderTarget      position in encoder ticks to rotate to
     * @param maxCorrectionPower the max power to run the motor at when turning to the position
     */
    void setPosition(int encoderTarget, double maxCorrectionPower);

    /**
     * Set the encoder zero point to the current encoder value
     */
    void resetEncoder();

    /**
     * Get the encoder position relative to the zero value
     *
     * @return the encoder position
     */
    int getEncoderPosition();

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Before you read this, it is helpful to read about the <a href="evlib/Motor-and-MotorEnc.html">Motor and MotorEnc</a> interfaces.</p>
<p>To get a DcMotor from the hardwareMap and wrap it with the Motor interface, you can do the following:</p>
<pre><code class="language-java">Stoppers stoppers = new Stoppers(); //pass this in each time you create a motor
boolean reversed = false;
boolean brake = true;

DcMotor leftDcMotor = hardwareMap.dcMotor.get(&quot;leftMotor&quot;)
Motor leftMotor = Motors.withoutEncoder(leftDcMotor, reversed, brake, stoppers);
</code></pre>
<p>or you can combine them into 1 line:</p>
<pre><code class="language-java">Motor leftMotor = Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers);
</code></pre>
<p>You can also create a Motor from a Continuous servo:</p>
<pre><code class="language-java">boolean reversed = false;
Motor arm = Motors.continuousServo(hardwareMap.crservo.get(&quot;servoArm&quot;), reversed);
</code></pre>
<p>To combine two motors:</p>
<pre><code class="language-java">Motor combined = Motors.combinedWithoutEncoder(leftMotor, arm);
</code></pre>
<p>To combine more than 2 motors:</p>
<pre><code class="language-java">Motor combined = Motors.combinedWithoutEncoder(
        ImmutableList.of(motor1, motor2, motor3, ...)
);
</code></pre>
<p>Here are all the methods for creating motors:</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/Motors.java">ftc/evlib/hardware/motors/Motors.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.HardwareMap;

import java.util.List;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Utility;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/11/16
 *
 * Factory class for creating Motor wrapper classes.
 * Has methods for all the combinations of with/without encoders and forward/reversed.
 *
 * @see Motor
 * @see MotorEnc
 */
public class Motors {
    /**
     * combine two motors with encoders into one motor
     *
     * @param motorEnc1 the first motor (with encoder)
     * @param motorEnc2 the second motor (with encoder)
     * @return the motor that controls both (with encoder support)
     */
    public static MotorEnc combinedWithEncoder(MotorEnc motorEnc1, MotorEnc motorEnc2) {
        return combinedWithEncoder(ImmutableList.of(motorEnc1, motorEnc2));
    }

    /**
     * combines any number of motors with encoders into one
     *
     * @param motorEncs the list of motors to combine (all must have encoders)
     * @return the motor that controls all of them (with encoder support)
     */
    public static MotorEnc combinedWithEncoder(final List&lt;MotorEnc&gt; motorEncs) {
        return new MotorEnc() {
            @Override
            public void setSpeed(double speed) {
                for (MotorEnc motorEnc : motorEncs)
                    motorEnc.setSpeed(speed);
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                for (MotorEnc motorEnc : motorEncs)
                    motorEnc.setPosition(encoderTarget, maxCorrectionPower);
            }

            @Override
            public void resetEncoder() {
                for (MotorEnc motorEnc : motorEncs) motorEnc.resetEncoder();
            }

            @Override
            public int getEncoderPosition() {
                int total = 0;
                for (MotorEnc motorEnc : motorEncs) total += motorEnc.getEncoderPosition();
                if (motorEncs.size() == 0) {
                    return 0;
                } else {
                    return total / motorEncs.size();
                }
            }

            @Override
            public void setPower(double power) {
                for (MotorEnc motorEnc : motorEncs) motorEnc.setPower(power);
            }

            @Override
            public Mode getMode() {
                if (motorEncs.size() == 0) {
                    return Mode.POWER;
                } else {
                    return motorEncs.get(0).getMode();
                }
            }

            @Override
            public void update() {
                for (MotorEnc motorEnc : motorEncs) motorEnc.update();
            }
        };
    }

    /**
     * combine two motors with or without encoders into one motor
     *
     * @param motor1 the first motor
     * @param motor2 the second motor
     * @return the motor that controls both (without encoder support)
     */
    public static Motor combinedWithoutEncoder(Motor motor1, Motor motor2) {
        return combinedWithoutEncoder(ImmutableList.of(motor1, motor2));
    }

    /**
     * combines any number of motors with or without encoders into one
     *
     * @param motors the list of motors to combine
     * @return the motor that controls all of them (without encoder support)
     */
    public static Motor combinedWithoutEncoder(final List&lt;Motor&gt; motors) {
        return new Motor() {
            @Override
            public void setPower(double power) {
                for (Motor motor : motors) motor.setPower(power);
            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {
                for (Motor motor : motors) motor.update();
            }
        };
    }

    /**
     * Initialize a dcMotor by setting parameters and checking that they were set properly
     *
     * @param dcMotor  the motor to initialize
     * @param reversed whether or not the motor direction should be reversed
     * @param brake    whether to brake or float when stopping
     * @param runMode  what mode to start the motor in
     */
    private static void dcMotorInit(DcMotor dcMotor, boolean reversed, boolean brake, DcMotor.RunMode runMode) {
        //reset the encoder position to zero
        do {
            dcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        } while (dcMotor.getMode() != DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        //determine the motor's direction as a Direction object
        DcMotor.Direction direction;
        if (reversed) {
            direction = DcMotorSimple.Direction.REVERSE;
        } else {
            direction = DcMotorSimple.Direction.FORWARD;
        }

        //set the motor's direction
        do {
            dcMotor.setDirection(direction);
        } while (dcMotor.getDirection() != direction);

        //set the motor's mode
        do {
            dcMotor.setMode(runMode);
        } while (dcMotor.getMode() != runMode);

        //determine the ZeroPowerBehavior
        DcMotor.ZeroPowerBehavior zeroPowerBehavior;
        if (brake) {
            zeroPowerBehavior = DcMotor.ZeroPowerBehavior.BRAKE;
        } else {
            zeroPowerBehavior = DcMotor.ZeroPowerBehavior.FLOAT;
        }

        //set the motor's ZeroPowerBehavior
        do {
            dcMotor.setZeroPowerBehavior(zeroPowerBehavior);
        } while (dcMotor.getZeroPowerBehavior() != zeroPowerBehavior);
    }

    /**
     * Create a Motor from the hardware map
     *
     * @param hardwareMap              the hardwareMap from the opmode
     * @param dcMotorName              the name of the DcMotor in the hardwareMap
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static Motor withoutEncoder(HardwareMap hardwareMap, String dcMotorName, boolean reversed, boolean brake, Stoppers stoppers) {
        return withoutEncoder(hardwareMap.dcMotor.get(dcMotorName), reversed, brake, stoppers);
    }

    /**
     * Create a Motor from a DcMotor
     *
     * @param dcMotor                  the DcMotor to be wrapped
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static Motor withoutEncoder(final DcMotor dcMotor, boolean reversed, boolean brake, Stoppers stoppers) {
        //initialize the motor with no encoder
        dcMotorInit(dcMotor, reversed, brake, DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        stoppers.add(new Stopper() {
            @Override
            public void stop() {
                do {
                    dcMotor.setPower(0);
                } while (dcMotor.getPower() != 0);
            }
        });

        return new Motor() {
            private double power = 0;

            @Override
            public void setPower(double power) {
                this.power = power;
            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {
                dcMotor.setPower(Utility.motorLimit(power));
            }
        };
    }

    /**
     * Convert a Motor.MotorMode to a DcMotor.RunMode
     *
     * @param mode the mode to convert
     * @return the corresponding DcMotor.RunMode
     */
    public static DcMotor.RunMode motorModeToDcMotorRunMode(Motor.Mode mode) {
        switch (mode) {
            case POWER:
                return DcMotor.RunMode.RUN_WITHOUT_ENCODER;
            case SPEED:
                return DcMotor.RunMode.RUN_USING_ENCODER;
            case POSITION:
                return DcMotor.RunMode.RUN_TO_POSITION;
            default:
                return null;
        }
    }

    /**
     * Convert a DcMotor.RunMode to a Motor.Mode
     *
     * @param runMode the mode to convert
     * @return the corresponding Motor.Mode
     */
    public static Motor.Mode dcMotorRunModeToMotorMode(DcMotor.RunMode runMode) {
        switch (runMode) {
            case RUN_WITHOUT_ENCODER:
                return Motor.Mode.POWER;
            case RUN_USING_ENCODER:
                return Motor.Mode.SPEED;
            case RUN_TO_POSITION:
                return Motor.Mode.POSITION;
            default:
                return null;
        }
    }

    /**
     * Create a MotorEnc from the hardware map
     *
     * @param hardwareMap              the hardwareMap from the opmode
     * @param dcMotorName              the name of the DcMotor in the hardwareMap
     * @param maxEncoderTicksPerSecond the encoder ticks per second at max power
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static MotorEnc withEncoder(HardwareMap hardwareMap, String dcMotorName, int maxEncoderTicksPerSecond, boolean reversed, boolean brake, Stoppers stoppers) {
        return withEncoder(hardwareMap.dcMotor.get(dcMotorName), maxEncoderTicksPerSecond, reversed, brake, stoppers);
    }

    /**
     * Create a MotorEnc from a DcMotor
     *
     * @param dcMotor                  the DcMotor to be wrapped
     * @param maxEncoderTicksPerSecond the encoder ticks per second at max power
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static MotorEnc withEncoder(final DcMotor dcMotor, int maxEncoderTicksPerSecond, boolean reversed, boolean brake, Stoppers stoppers) {
        final Motor.Mode initMode = Motor.Mode.SPEED;
        dcMotorInit(dcMotor, reversed, brake, motorModeToDcMotorRunMode(initMode)); //start with speed mode

        do {
            dcMotor.setMaxSpeed(maxEncoderTicksPerSecond);
        } while (dcMotor.getMaxSpeed() != maxEncoderTicksPerSecond);

        stoppers.add(new Stopper() {
            @Override
            public void stop() {
                do {
                    dcMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
                } while (dcMotor.getMode() != DcMotor.RunMode.RUN_WITHOUT_ENCODER);
                do {
                    dcMotor.setPower(0);
                } while (dcMotor.getPower() != 0);
            }
        });

        return new MotorEnc() {
            private int encoderZero = 0, encoderPosition = 0;
            private Mode mode = initMode, lastMode = initMode;
            private double power = 0;
            private int encoderTarget = 0;

            @Override
            public void setPower(double power) {
                mode = Mode.POWER;
                this.power = power;
            }

            @Override
            public void setSpeed(double speed) {
                mode = Mode.SPEED;
                power = speed;
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                mode = Mode.POSITION;
                this.encoderTarget = encoderTarget;
                power = maxCorrectionPower;
            }

            @Override
            public void resetEncoder() {
                encoderZero = encoderPosition;
            }

            @Override
            public int getEncoderPosition() {
                return encoderPosition - encoderZero;
            }

            @Override
            public Mode getMode() {
                return mode;
            }

            @Override
            public void update() {
                encoderPosition = dcMotor.getCurrentPosition();

                if (mode != lastMode) {
                    dcMotor.setMode(motorModeToDcMotorRunMode(mode));
                    lastMode = dcMotorRunModeToMotorMode(dcMotor.getMode());
                }

                switch (mode) {
                    case POWER:
                        break;
                    case SPEED:
                        break;
                    case POSITION:
                        dcMotor.setTargetPosition(encoderTarget);
                        break;
                }
                dcMotor.setPower(Utility.motorLimit(power));
            }
        };
    }

    /**
     * Wraps a continuous rotation servo as a normal motor
     *
     * @param crServo  the servo to be wrapped as a motor
     * @param reversed true if the servo should be reversed
     * @return the Motor wrapper class
     */
    public static Motor continuousServo(final CRServo crServo, boolean reversed) {
        DcMotorSimple.Direction direction;
        if (reversed) {
            direction = DcMotorSimple.Direction.REVERSE;
        } else {
            direction = DcMotorSimple.Direction.FORWARD;
        }

        do {
            crServo.setDirection(direction);
        } while (crServo.getDirection() != direction);

        return new Motor() {
            private double power = 0;

            @Override
            public void setPower(double power) {
                this.power = power;
            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {
                crServo.setPower(power);
            }
        };
    }

    /**
     * Scale a motor's power by a constant
     *
     * @param motor the motor to scale
     * @param scale the scaling factor
     * @return the created MotorEnc
     */
    public static Motor scale(final Motor motor, final double scale) {
        return new Motor() {
            @Override
            public void setPower(double power) {
                motor.setPower(power * scale);
            }

            @Override
            public Mode getMode() {
                return motor.getMode();
            }

            @Override
            public void update() {
                motor.update();
            }

        };
    }

    /**
     * Scale a motor's power and speed by a constant
     *
     * @param motorEnc the motor to scale
     * @param scale    the scaling factor
     * @return the created MotorEnc
     */
    public static Motor scale(final MotorEnc motorEnc, final double scale) {
        return new MotorEnc() {
            @Override
            public void setSpeed(double speed) {
                motorEnc.setSpeed(speed * scale);
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                motorEnc.setPosition(encoderTarget, maxCorrectionPower);
            }

            @Override
            public void resetEncoder() {
                motorEnc.resetEncoder();
            }

            @Override
            public int getEncoderPosition() {
                return motorEnc.getEncoderPosition();
            }

            @Override
            public void setPower(double power) {
                motorEnc.setPower(power * scale);
            }

            @Override
            public Mode getMode() {
                return motorEnc.getMode();
            }

            @Override
            public void update() {
                motorEnc.update();
            }

        };
    }


    /**
     * Scale a motor's power by a function
     *
     * @param motor    the motor to scale
     * @param function the function to scale by
     * @return the created MotorEnc
     */
    public static Motor scale(final Motor motor, final Function function) {
        return new Motor() {
            @Override
            public void setPower(double power) {
                motor.setPower(function.f(power));
            }

            @Override
            public Mode getMode() {
                return motor.getMode();
            }

            @Override
            public void update() {
                motor.update();
            }

        };
    }

    /**
     * Scale a motor's power and speed by a function
     *
     * @param motorEnc the motor to scale
     * @param function the function to scale by
     * @return the created MotorEnc
     */
    public static Motor scale(final MotorEnc motorEnc, final Function function) {
        return new MotorEnc() {
            @Override
            public void setSpeed(double speed) {
                motorEnc.setSpeed(function.f(speed));
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                motorEnc.setPosition(encoderTarget, maxCorrectionPower);
            }

            @Override
            public void resetEncoder() {
                motorEnc.resetEncoder();
            }

            @Override
            public int getEncoderPosition() {
                return motorEnc.getEncoderPosition();
            }

            @Override
            public void setPower(double power) {
                motorEnc.setPower(function.f(power));
            }

            @Override
            public Mode getMode() {
                return motorEnc.getMode();
            }

            @Override
            public void update() {
                motorEnc.update();
            }

        };
    }

    /**
     * @return a motor with an encoder that does nothing
     */
    public static MotorEnc dummyWithEncoder() {
        return new MotorEnc() {
            private Mode mode = Mode.POWER;

            @Override
            public void setSpeed(double speed) {
                mode = Mode.SPEED;
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                mode = Mode.POSITION;
            }

            @Override
            public void resetEncoder() {

            }

            @Override
            public int getEncoderPosition() {
                return 0;
            }

            @Override
            public void setPower(double power) {
                mode = Mode.POWER;
            }

            @Override
            public Mode getMode() {
                return mode;
            }

            @Override
            public void update() {

            }
        };
    }

    /**
     * @return a motor that does nothing
     */
    public static Motor dummyWithoutEncoder() {
        return new Motor() {
            @Override
            public void setPower(double power) {

            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {

            }
        };
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Before you read this, it is helpful to read about the <a href="evlib/Motor-and-MotorEnc.html">Motor and MotorEnc</a> interfaces and also how to <a href="evlib/Creating-Motors.html">create motors</a>.</p>
<p>The following class groups any number of motors and can run them all at once with a list of powers.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/NMotors.java">ftc/evlib/hardware/motors/NMotors.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import ftc.electronvolts.util.Utility;
import ftc.electronvolts.util.units.Velocity;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * A general controller for a collection of N motors.
 * Knows how to run the motors given a list of Doubles.
 * Can normalize the powers/speeds before running if requested.
 * Subclasses can have fixed numbers of motors
 *
 * @see Motor
 * @see MotorEnc
 * @see OneMotors
 * @see TwoMotors
 * @see ThreeMotors
 * @see FourMotors
 * @see FiveMotors
 * @see SixMotors
 */
public class NMotors {
    /**
     * the list of motors that are grouped
     */
    private final List&lt;? extends Motor&gt; motors;

    /**
     * whether or not to use speed mode on the motors
     */
    private final boolean useSpeedMode;

    /**
     * the measured maximum speed of the robot
     */
    private final Velocity maxRobotSpeed;

    /**
     * the values most recently sent to the motors
     */
    private final double[] values;
    private final int[] encoders;

    /**
     * @param motors        the list of motors
     * @param useSpeedMode  true if encoder-regulated speed mode is desired
     * @param maxRobotSpeed the measured maximum speed of the robot
     */
    public NMotors(List&lt;? extends Motor&gt; motors, boolean useSpeedMode, Velocity maxRobotSpeed) {
        //if using speed mode, the motors need to have encoders
        if (useSpeedMode) {
            for (int i = 0; i &lt; motors.size(); i++) {
                if (!(motors.get(i) instanceof MotorEnc)) {
                    throw new IllegalArgumentException(&quot;Argument 'motors' must be of type List&lt;MotorEnc&gt; if speed mode is to be used.&quot;);
                }
            }
        }
        this.motors = motors;
        this.useSpeedMode = useSpeedMode;
        this.maxRobotSpeed = maxRobotSpeed.abs();
        values = new double[motors.size()];
        encoders = new int[motors.size()];
    }

    /**
     * @return the measured maximum speed of the robot
     */
    public Velocity getMaxRobotSpeed() {
        return maxRobotSpeed;
    }

    /**
     * Allows different stop behaviors for different operations
     *
     * @param stopBehavior what to do when the power/speed is 0
     */

    /**
     * scale all the motor values if any one power is above the maximum of 1
     *
     * @param values the powers/speeds to be scaled and then run
     */
    public void runNormalized(List&lt;Double&gt; values) {
        if (values.size() != motors.size()) {
            throw new IllegalArgumentException(&quot;Argument 'values' must have the same length as the number of motors.&quot;);
        }

        //if the inputs are too high, scale them
        double highest = 0;

        //find the magnitude of the number with the highest magnitude
        for (double n : values) {
            if (Math.abs(n) &gt; highest) {
                highest = Math.abs(n);
            }
        }

        if (highest &lt; 1) { //only normalize if the values are too high
            highest = 1;
        }

        //rescale the values by the highest value
        List&lt;Double&gt; valuesScaled = new ArrayList&lt;&gt;();
        for (double power : values) {
            valuesScaled.add(power / highest);
        }

        run(valuesScaled);
    }

    /**
     * run the motors with raw power/speed
     *
     * @param values the raw values to send to the motors
     */
    public void run(List&lt;Double&gt; values) {
        if (values.size() != motors.size()) {
            throw new IllegalArgumentException(&quot;Argument 'values' must have the same length as the number of motors.&quot;);
        }

        //set the motor powers/speeds of each motor
        for (int i = 0; i &lt; motors.size(); i++) {
            Double value = Utility.motorLimit(values.get(i));
            if (useSpeedMode) {
                MotorEnc motorEnc = ((MotorEnc) motors.get(i));
                motorEnc.setSpeed(value);
                encoders[i] = motorEnc.getEncoderPosition();
            } else {
                motors.get(i).setPower(value);
            }
            this.values[i] = value;
        }
    }

    /**
     * @param i the index of the motor to read the value from
     * @return the values most recently sent to the motors
     */
    public double getValue(int i) {
        return values[i];
    }

    /**
     * @param i the index of the motor to read the encoder value from
     * @return the values of the motor encoders. All encoder values will be 0 if useSpeedMode is false
     */
    public int getEncoder(int i) {
        return encoders[i];
    }

    /**
     * stop all the motors
     */
    public void stop() {
        //create a list of the same length as motors filled with zeroes
        run(new ArrayList&lt;&gt;(Collections.nCopies(motors.size(), 0.0)));
    }

    /**
     * Send the motor commands to the motor controller
     */
    public void update() {
        for (int i = 0; i &lt; motors.size(); i++) {
            motors.get(i).update();
        }
    }
}
</code></pre>
<p>There are also similar classes for every other number of motors up to 6. (for example: <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/FourMotors.java">FourMotors</a>). If you need more than 6 motors, you can extend the class yourself. (You never know when you might need 800 motors for some reason.)</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before you read this, it might be helpful to read about the <a href="evlib/NMotors.html">NMotors</a> class first.</p>
<p>Mecanum wheels use diagonal forces to move in any direction. Here is a diagram of the direction of the force of each wheel when moving forward:</p>
<p><img src="https://github.com/FTC7393/EVLib/blob/master/images/mecanum.png?raw=true" alt="mecanum force diagram" /></p>
<p>To drive forward/backward, you just power all the wheels forward/backward.
To turn right, you power the right wheels backward and the left wheels forward, just like normal wheels.
(Turning left is the same idea.)</p>
<p>To move sideways right, move the front-left and back-right wheels forward, and the others backward.</p>
<p>Now we have this table:</p>
<pre><code>            FORWARD(+x)   SIDEWAYS RIGHT(+y)   TURN RIGHT(+r)
front left      +                 +                  +
front right     +                 -                  -
back left       +                 -                  +
back right      +                 +                  -
</code></pre>
<p>And we can convert this table to an algorithm:</p>
<pre><code>inputs: x, y, and r

flPower = + x + y + r
frPower = + x - y - r
blPower = + x - y + r
brPower = + x + y - r
</code></pre>
<p>This converts the desired motion of the robot into the power for the wheels.</p>
<p>The next thing to worry about is scaling to make sure the motors do not get sent a power that is greater than 1 or less than -1. Fortunately, the scaling is already implemented in the <a href="evlib/NMotors.html">NMotors</a> class.</p>
<p>This is the MecanumMotors class, which extends FourMotors, which in turn extends NMotors. So all MecanumMotors has to do is convert the velocity in X, Y, and R to motor powers using the algorithm we found above. It also has various setters for X, y, and R, as well as functions to convert polar (direction and distance) coordinates to cartesian (x and y) coordinates.</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/MecanumMotors.java">ftc/evlib/hardware/motors/MecanumMotors.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

import com.google.common.collect.ImmutableList;

import java.util.ArrayList;
import java.util.List;

import ftc.electronvolts.util.Utility;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Velocity;

import static ftc.evlib.driverstation.Telem.telemetry;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 12/27/15
 *
 * A subclass of FourMotors that contains algorithms for controlling mecanum wheels.
 * It stores the X, Y, and R velocities and sends them to the motors when it is updated.
 *
 * @see FourMotors
 * @see ftc.evlib.hardware.control.MecanumControl
 */
public class MecanumMotors extends FourMotors {

    public enum MecanumDriveMode {
        NORMALIZED, TRANSLATION_NORMALIZED
    }

    //the stored velocities
    private double velocityX = 0;
    private double velocityY = 0;
    private double velocityR = 0;

    //the drive mode
    private MecanumDriveMode driveMode = MecanumDriveMode.NORMALIZED;

    /**
     * @param frontLeftMotor  the front left motor
     * @param frontRightMotor the front right motor
     * @param backLeftMotor   the back left motor
     * @param backRightMotor  the back right motor
     * @param useSpeedMode    whether or not to use speed control on the motors
     * @param maxRobotSpeed   the measured speed of the robot at 100% power
     */
    public MecanumMotors(Motor frontLeftMotor, Motor frontRightMotor, Motor backLeftMotor, Motor backRightMotor, boolean useSpeedMode, Velocity maxRobotSpeed) {
        super(frontLeftMotor, frontRightMotor, backLeftMotor, backRightMotor, useSpeedMode, maxRobotSpeed);
    }

    /**
     * @param mode the drive mode
     */
    public void setDriveMode(MecanumDriveMode mode) {
        driveMode = mode;
    }

    /**
     * Update the motor powers
     */
    public void mecanumDrive() {
        switch (driveMode) {
            case NORMALIZED:
                mecanumDriveNormalized();
                break;
            case TRANSLATION_NORMALIZED:
                mecanumDriveTranslationNormalized();
                break;
        }
    }

    /**
     * run the motors based on the xyr velocities
     * normalize if any motor power is too large
     */
    private void mecanumDriveNormalized() {
        //calculate motor powers
        runMotorsNormalized(
                velocityX + velocityY - velocityR,
                velocityX - velocityY + velocityR,
                velocityX - velocityY - velocityR,
                velocityX + velocityY + velocityR
        );
    }

    /**
     * Calculate rotational velocity first, and use remaining headway for translation.
     */
    private void mecanumDriveTranslationNormalized() {
        //calculate motor powers
        List&lt;Double&gt; translationValues = ImmutableList.of(
                velocityX + velocityY,
                velocityX - velocityY,
                velocityX - velocityY,
                velocityX + velocityY);

        List&lt;Double&gt; rotationValues = ImmutableList.of(
                -velocityR,
                velocityR,
                -velocityR,
                velocityR);

        double scaleFactor = 1;
        double tmpScale = 1;

        // Solve this equation backwards:
        // MotorX = TranslationX * scaleFactor + RotationX
        // to find scaleFactor that ensures -1 &lt;= MotorX &lt;= 1 and 0 &lt; scaleFactor &lt;= 1

        for (int i = 0; i &lt; 4; i++) {
            if (Math.abs(translationValues.get(i) + rotationValues.get(i)) &gt; 1) {
                tmpScale = (1 - rotationValues.get(i)) / translationValues.get(i);
            } else if (translationValues.get(i) + rotationValues.get(i) &lt; -1) {
                tmpScale = (rotationValues.get(i) - 1) / translationValues.get(i);
            }
            if (tmpScale &lt; scaleFactor) {
                scaleFactor = tmpScale;
            }
        }

        telemetry.addData(&quot;driveMode&quot;, driveMode.toString());
        telemetry.addData(&quot;scaleFactor&quot;, scaleFactor);

        List&lt;Double&gt; valuesScaled = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 4; i++) {
            valuesScaled.add(translationValues.get(i) * scaleFactor + rotationValues.get(i));
            telemetry.addData(&quot;valuesScaled(&quot; + i + &quot;)&quot;, valuesScaled.get(i));
        }

        run(valuesScaled);
    }

    /**
     * @param velocityX the x velocity
     */
    public void setVelocityX(double velocityX) {
        this.velocityX = Utility.motorLimit(velocityX);
    }

    /**
     * @param velocityY the y velocity
     */
    public void setVelocityY(double velocityY) {
        this.velocityY = Utility.motorLimit(velocityY);
    }

    /**
     * @param velocityR the rotational velocity
     */
    public void setVelocityR(double velocityR) {
        this.velocityR = Utility.motorLimit(velocityR);
    }

    /**
     * set the x and y velocities at the same time
     *
     * @param velocityX the x velocity
     * @param velocityY the y velocity
     */
    public void setVelocityXY(double velocityX, double velocityY) {
        setVelocityX(velocityX);
        setVelocityY(velocityY);
    }

    /**
     * set the x, y, and rotational velocities at the same time
     *
     * @param velocityX the x velocity
     * @param velocityY the y velocity
     * @param velocityR the rotational velocity
     */
    public void setVelocityXYR(double velocityX, double velocityY, double velocityR) {
        setVelocityX(velocityX);
        setVelocityY(velocityY);
        setVelocityR(velocityR);
    }

    /**
     * set the x and y velocities using polar coordinates
     *
     * @param velocity  the velocity (r of the polar coordinate)
     * @param direction the direction (theta of the polar coordinate)
     */
    public void setVelocityPolar(double velocity, Angle direction) {
        double directionRadians = direction.radians();
        setVelocityX(velocity * Math.cos(directionRadians));
        setVelocityY(velocity * Math.sin(directionRadians));
    }

    /**
     * set the x and y velocities using polar coordinates, and also set the rotational velocity
     *
     * @param velocity  the velocity (r of the polar coordinate)
     * @param direction the direction (theta of the polar coordinate)
     * @param velocityR the rotational velocity
     */
    public void setVelocityPolarR(double velocity, Angle direction, double velocityR) {
        setVelocityPolar(velocity, direction);
        setVelocityR(velocityR);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Using the <a href="evlib/Mecanum-Wheels.html">MecanumMotors</a> class that converts velocity in the X, Y, and R directions, we need a way to add control algorithms, such as gyro stabilization or line following.</p>
<p>The gyro algorithm would look like:</p>
<pre><code>Loop:
  get current heading from gyro
  calculate heading error from desired heading
  adjust ROTATION based on heading error
</code></pre>
<p>And the line following would look like:
(The x axis is the forward/backward movement of the robot)</p>
<pre><code>Loop:
  get values from line sensors
  calculate position on the line (LEFT, MIDDLE, or RIGHT)
  if LEFT: y = positive
  if middle: y = 0
  if RIGHT: y = negative
  x is defined by the input
  set the TRANSLATION to (x, y)
</code></pre>
<p>As you can see, the gyro stabilization controls the rotation, and the line following controls the translation.</p>
<p>Now the challenge is to make a class that can accept different types of translation/rotation controllers.</p>
<p>First, we create interfaces TranslationControl and RotationControl to define what they have output:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/TranslationControl.java">ftc/evlib/hardware/control/TranslationControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.Vector2D;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/19/16
 * 
 * Controls the translation of a mecanum robot
 *
 * @see TranslationControls
 * @see Vector2D
 */
public interface TranslationControl {
    /**
     * update the velocity x and velocity y values
     *
     * @return true if there were no problems
     */
    boolean act();

    /**
     * @return the translational velocity
     */
    Vector2D getTranslation();
}
</code></pre>
<p>As you can see, the translation control returns a Vector2D (x and y).</p>
<p>RotationControl is more complicated, because it not only has to find the angular velocity, but also apply a correction of a certain angle to the translation.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/RotationControl.java">ftc/evlib/hardware/control/RotationControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.units.Angle;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/19/16
 * 
 * Controls the rotation of a mecanum robot
 *
 * @see RotationControls
 * @see Angle
 */
public interface RotationControl {
    double DEFAULT_MAX_ANGULAR_SPEED = 0.5;
//    double DEFAULT_MAX_ANGULAR_SPEED = 0.8;

    /**
     * update the rotational velocity
     *
     * @return true if there were no problems
     */
    boolean act();

    /**
     * @return the rotational velocity
     */
    double getVelocityR();

    /**
     * accounts for the robot's rotation being off when translating
     *
     * @return correction to the translation direction
     */
    Angle getPolarDirectionCorrection();
}
</code></pre>
<p>There are factory classes for the TranslationControl and RotationControl:
<a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/TranslationControls.java">ftc/evlib/hardware/control/TranslationControls.java</a>
<a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/RotationControls.java">ftc/evlib/hardware/control/RotationControls.java</a></p>
<p>They create the controllers such as the gyro stabilization, line following, and also controllers that return constant values for dead reckoning.</p>
<p>For controllers that control the rotation and translation, there is an abstract class called XYRControl that combines both the RotationControl and TranslationControl interfaces.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/XYRControl.java">ftc/evlib/hardware/control/XYRControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.units.Angle;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 12/14/16
 *
 * Controls both the translation (x and y) and the rotation (r) of a robot with mecanum wheels
 *
 * @see RotationControl
 * @see TranslationControl
 * @see XYRControls
 */
public abstract class XYRControl implements RotationControl, TranslationControl {
    @Override
    public Angle getPolarDirectionCorrection() {
        return Angle.zero();
    }
}
</code></pre>
<p>The factory class for XYRControl is <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/XYRControls.java">ftc/evlib/hardware/control/XYRControls.java</a></p>
<p>Now we need to take the value from the TranslationControl and RotationControl and pass them to the MecanumMotors. This is done by MecanumControl:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/MecanumControl.java">ftc/evlib/hardware/control/MecanumControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.Vector2D;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.motors.MecanumMotors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/19/16
 * 
 * Manages what algorithms control the rotation and translation of the mecanum wheels
 * This allows you to mix and match rotation and translation (x and y) controllers and change them whenever you want
 *
 * @see MecanumMotors
 * @see RotationControl
 * @see RotationControls
 * @see TranslationControl
 * @see TranslationControls
 */
public class MecanumControl {
    /**
     * the motors to be controlled
     */
    private final MecanumMotors mecanumMotors;

    //the controllers for the rotation and translation
    private RotationControl rotationControl;
    private TranslationControl translationControl;

    /**
     * the velocity in the x, y, and rotation directions
     */
    private double velocityX, velocityY, velocityR;

    /**
     * stores whether or not the translation/rotation worked
     * for example, translationWorked will be false if the line following lost the line
     */
    private boolean translationWorked = true, rotationWorked = false;

    /**
     * create a MecanumControl that is not moving
     *
     * @param mecanumMotors the motors to control
     */
    public MecanumControl(MecanumMotors mecanumMotors) {
        this(mecanumMotors, XYRControls.ZERO);
    }

    /**
     * create a MecanumControl and immediately start using an XYR control
     *
     * @param mecanumMotors the motors to control
     * @param xyrControl    how to command the motors' rotation and translation
     */
    public MecanumControl(MecanumMotors mecanumMotors, XYRControl xyrControl) {
        this(mecanumMotors, xyrControl, xyrControl);
    }

    /**
     * create a MecanumControl and immediately start using TranslationControl and RotationControl
     *
     * @param mecanumMotors      the motors to control
     * @param rotationControl    how to command the motors' rotation
     * @param translationControl how to command the motors' translation
     */
    public MecanumControl(MecanumMotors mecanumMotors, RotationControl rotationControl, TranslationControl translationControl) {
        this.rotationControl = rotationControl;
        this.mecanumMotors = mecanumMotors;
        this.translationControl = translationControl;
    }

    /**
     * @return the robot's speed when the power is set to 100%
     */
    public Velocity getMaxRobotSpeed() {
        return mecanumMotors.getMaxRobotSpeed();
    }

    /**
     * @param rotationControl the controller that determines the robot's rotation
     */
    public void setRotationControl(RotationControl rotationControl) {
        this.rotationControl = rotationControl;
    }

    /**
     * @param translationControl the controller that determines the robot's translation (x and y)
     */
    public void setTranslationControl(TranslationControl translationControl) {
        this.translationControl = translationControl;
    }

    /**
     * set both translation and rotation controls at once
     *
     * @param translationControl the controller that determines the robot's translation (x and y)
     * @param rotationControl    the controller that determines the robot's rotation
     */
    public void setControl(TranslationControl translationControl, RotationControl rotationControl) {
        this.translationControl = translationControl;
        this.rotationControl = rotationControl;
    }

    /**
     * set both translation and rotation controls at once
     *
     * @param rotationControl    the controller that determines the robot's rotation
     * @param translationControl the controller that determines the robot's translation (x and y)
     */
    public void setControl(RotationControl rotationControl, TranslationControl translationControl) {
        this.translationControl = translationControl;
        this.rotationControl = rotationControl;
    }

    /**
     * Set both translation and rotation controls to the same object
     *
     * @param xyrControl the controller that determines both the translation and rotation
     */
    public void setControl(XYRControl xyrControl) {
        this.translationControl = xyrControl;
        this.rotationControl = xyrControl;
    }

    /**
     * stop the motors
     */
    public void stop() {
        translationControl = TranslationControls.ZERO;
        rotationControl = RotationControls.ZERO;
        mecanumMotors.stop();
    }

    /**
     * set the drive mode to turn on or off translation normalizing
     *
     * @param mode the drive mode
     */
    public void setDriveMode(MecanumMotors.MecanumDriveMode mode) {
        mecanumMotors.setDriveMode(mode);
    }

    /**
     * update the motor powers based on the output of the translationControl and rotationControl
     */
    public void act() {
        translationWorked = translationControl.act();

        //in case the same object is passed in that implements both controllers
        if (translationControl == rotationControl) {
            rotationWorked = translationWorked;
        } else {
            rotationWorked = rotationControl.act();
        }

        Vector2D translation = translationControl.getTranslation();

        double velocity = translation.getLength();
        double directionRads = translation.getDirection().radians() +
                rotationControl.getPolarDirectionCorrection().radians();

        velocityX = velocity * Math.cos(directionRads);
        velocityY = velocity * Math.sin(directionRads);

        velocityR = rotationControl.getVelocityR();

        mecanumMotors.setVelocityXYR(
                velocityX,
                velocityY,
                velocityR
        );

        mecanumMotors.mecanumDrive();
        mecanumMotors.update();
    }

    /**
     * @return whether or not the translation worked
     */
    public boolean translationWorked() {
        return translationWorked;
    }

    /**
     * @return whether or not the rotation worked
     */
    public boolean rotationWorked() {
        return rotationWorked;
    }

    /**
     * @return the robot's x velocity
     */
    public double getVelocityX() {
        return velocityX;
    }

    /**
     * @return the robot's y velocity
     */
    public double getVelocityY() {
        return velocityY;
    }

    /**
     * @return the robot's rotational velocity
     */
    public double getVelocityR() {
        return velocityR;
    }

    public RotationControl getRotationControl() {
        return rotationControl;
    }

    public TranslationControl getTranslationControl() {
        return translationControl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>EVLib has its own interface for Analog sensors. It extends <a href="https://github.com/FTC7393/state-machine-framework/wiki/InputExtractor">InputExtractor</a> (from the state-machine-framework) of type Double, which means that every AnalogSensor has to have a method that returns a Double: <code>Double getValue()</code>.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/AnalogSensor.java">ftc/evlib/hardware/sensors/AnalogSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

import ftc.electronvolts.util.InputExtractor;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/11/16
 * 
 * Interface for any type of analog sensor
 * examples: light sensor, distance sensor, potentiometer
 *
 * @see InputExtractor
 * @see Sensors
 */
public interface AnalogSensor extends InputExtractor&lt;Double&gt; {
}
</code></pre>
<p>To create an AnalogSensor from an AnalogInput (which is part of the FTC libraries), you can use the <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/Sensors.java">ftc/evlib/hardware/sensors/Sensors.java</a> factory class:</p>
<pre><code class="language-java">AnalogInput analogInput = hardwareMap.analogInput.get(&quot;lightSensor&quot;);
AnalogSensor lightSensor = Sensors.analog(analogInput);

//To combine on one line:
AnalogSensor lightSensor = Sensors.analog(hardwareMap, &quot;lightSensor&quot;);
</code></pre>
<p>To get the value of a sensor, call the getValue() method:</p>
<pre><code class="language-java">telemetry.addData(&quot;light sensor&quot;, lightSensor.getValue());
</code></pre>
<p>See also: <a href="evlib/DistanceSensor.html">DistanceSensor</a>, <a href="evlib/Digital-Sensors.html">Digital Sensors</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>AveragedSensor takes an <a href="evlib/Analog-Sensors.html">AnalogSensor</a> and averages the last N values to get the current value. The act() method should be called exactly once every time through the loop, but getValue() can be called whenever you need the value. The isReady() method will return true if the sensor is done collecting the first N values. If the sensor is not ready, the value will not be accurate.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/AveragedSensor.java">ftc/evlib/hardware/sensors/AveragedSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/16/16
 * 
 * report the average of the last N values of a sensor as the value
 *
 * @see AnalogSensor
 */
public class AveragedSensor implements AnalogSensor {
    private final AnalogSensor sensor;
    private final double readings[];
    private int index = 0;
    private boolean ready = false;
    private final int numReadings;
    private double average = 0;

    /**
     * @param sensor      the sensor to average
     * @param numReadings the number of readings to average
     */
    public AveragedSensor(AnalogSensor sensor, int numReadings) {
        this.sensor = sensor;
        this.numReadings = numReadings;
        readings = new double[numReadings];
    }

    /**
     * @return true once the first numReadings have been read
     */
    public boolean isReady() {
        return ready;
    }

    @Override
    public Double getValue() {
        return average;
    }

    /**
     * read the sensor and update the average
     */
    public void act() {
        double reading = sensor.getValue();
        readings[index] = reading;
        index++;
        if (index &gt;= numReadings) {
            index = 0;
            ready = true;
        }
        if (ready) {
            average = 0;
            for (int i = 0; i &lt; numReadings; i++) {
                average += readings[i];
            }
            average /= numReadings;
        } else {
            average = reading;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>EVLib has its own interface for Digital sensors. It extends InputExtractor of type Boolean, which means that every DigitalSensor has to have a getValue method that returns a Boolean.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/DigitalSensor.java">ftc/evlib/hardware/sensors/DigitalSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

import ftc.electronvolts.util.InputExtractor;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * Interface for any type of digital sensor
 * examples: touch sensor, digital line sensor, magnetic reed switch
 *
 * @see InputExtractor
 * @see Sensors
 */
public interface DigitalSensor extends InputExtractor&lt;Boolean&gt; {
}
</code></pre>
<p>You can create a DigitalSensor from a DigitalChannel or TouchSensor using the <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/Sensors.java">Sensors</a> factory class:</p>
<pre><code class="language-java">DigitalInput digitalInput = hardwareMap.touchSensor.get(&quot;limitSwitch&quot;);
DigitalSensor limitSwitch = Sensors.digitalSensor(digitalInput);

//To combine on one line:
DigitalSensor button = Sensors.digitalSensor(hardwareMap, &quot;button&quot;);
</code></pre>
<p>To get the value of a DigitalSensor, call the getValue() method which returns a Boolean.</p>
<pre><code class="language-java">teletry.addData(&quot;limit switch pressed?&quot;, limitSwitch.getValue());
</code></pre>
<p>See also: <a href="evlib/Analog-Sensors.html">Analog Sensors</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>CalibratedLineSensor takes an <a href="evlib/Analog-Sensors.html">analog</a> line sensor and turns it into a <a href="evlib/Digital-Sensors.html">DigitalSensor</a> by finding a threshold between light and dark. The getValue() method will return true if the sensor sees a line. Note: the act method must be called every loop to update the sensor values for averaging. This class is used in <a href="evlib/DoubleLineSensor.html">DoubleLineSensor</a>.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/CalibratedLineSensor.java">ftc/evlib/hardware/sensors/CalibratedLineSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/8/16
 * 
 * manages threshold calculation for the line sensor
 *
 * @see AnalogSensor
 */
public class CalibratedLineSensor implements DigitalSensor {
    private boolean ready = true;
    private final AnalogSensor lineSensor;
    private static final int NUM_CALIBRATIONS = 100;
    private int numReadings;
    private double average, deviation, threshold = 80;
    private final double readings[] = new double[NUM_CALIBRATIONS];
    private boolean seeingLine = false;
    private double value;

    /**
     * @param lineSensor the raw line sensor
     */
    public CalibratedLineSensor(AnalogSensor lineSensor) {
        this.lineSensor = lineSensor;
    }

    /**
     * start calibrating the sensor
     */
    public void calibrate() {
        ready = false;
        average = 0;
        numReadings = 0;
        deviation = 0;
    }

    /**
     * @return true when done calibrating
     */
    public boolean isReady() {
        return ready;
    }

    /**
     * @return true if the sensor is over the line
     */
    @Override
    public Boolean getValue() {
        return seeingLine;
    }

    /**
     * read the sensor value and use it to calibrate/update the average
     */
    public void act() {
        value = lineSensor.getValue();
        if (!ready) {
            if (numReadings &lt; NUM_CALIBRATIONS) {
                //add a value
                readings[numReadings] = value;
                numReadings++;

                //update the average
                average = (average * (numReadings - 1) + value) / (numReadings);

            } else {
                //find deviation
                for (double reading : readings) {
                    deviation += (reading - average) * (reading - average);
                }
                deviation /= Math.sqrt(numReadings);

                threshold = (average - deviation) * (average - deviation) / average;
                ready = true;
            }
        }
        seeingLine = value &lt; threshold;
    }

    /**
     * @return the raw value of the line sensor
     */
    public double getRawValue() {
        return value;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>This takes two <a href="evlib/CalibratedLineSensor.html">CalibratedLineSensor</a> objects and combines them. It reports the robot's position relative to the line. It is used in <a href="evlib/LineFinder.html">LineFinder</a> along with a <a href="evlib/ColorSensor.html">ColorSensor</a> to find different colored lines.</p>
<p>It is be used in <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/TranslationControls.java">ftc/evlib/hardware/control/TranslationControls.java</a> to do line following. See: <a href="evlib/Mecanum-Control.html">Mecanum Control</a></p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/DoubleLineSensor.java">ftc/evlib/hardware/sensors/DoubleLineSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/8/16
 * 
 * Manages two line sensors to tell where the robot is relative to the line
 *
 * @see CalibratedLineSensor
 * @see DigitalSensor
 */
public class DoubleLineSensor implements DigitalSensor {

    public enum LinePosition {
        LEFT,
        MIDDLE,
        RIGHT,
        OFF_UNKNOWN,
        OFF_LEFT,
        OFF_RIGHT
    }

    private LinePosition position = LinePosition.OFF_UNKNOWN;

    private final CalibratedLineSensor leftSensor, rightSensor;

    public DoubleLineSensor(AnalogSensor leftSensor, AnalogSensor rightSensor) {
        this.leftSensor = new CalibratedLineSensor(leftSensor);
        this.rightSensor = new CalibratedLineSensor(rightSensor);
    }

    public void calibrate() {
        leftSensor.calibrate();
        rightSensor.calibrate();
    }

    public boolean isReady() {
        return leftSensor.isReady() &amp;&amp; rightSensor.isReady();
    }

    public LinePosition getPosition() {
        return position;
    }

    public void reset() {
        position = LinePosition.MIDDLE;
    }

    /**
     * @return true if either sensor is on the line
     */
    @Override
    public Boolean getValue() {
        return leftSensor.getValue() || rightSensor.getValue();
    }

    /**
     * determine where the robot is relative to the line
     */
    public void act() {
        leftSensor.act();
        rightSensor.act();

        if (leftSensor.getValue()) {
            if (rightSensor.getValue()) {
                position = LinePosition.MIDDLE;
            } else {
                position = LinePosition.LEFT;
            }
        } else {
            if (rightSensor.getValue()) {
                position = LinePosition.RIGHT;
            } else {
                //if neither sensor detects the line, the position is determined by the previous position
                if (position == LinePosition.LEFT) {
                    position = LinePosition.OFF_LEFT;
                } else if (position == LinePosition.RIGHT) {
                    position = LinePosition.OFF_RIGHT;
                } else {
                    position = LinePosition.OFF_UNKNOWN;
                }
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ColorSensor uses a red LED, a blue LED, and a photoresistor to detect the color of a line on the mat. It has 4 methods for setting the color: red, blue, magenta, and off. It implements <a href="evlib/Digital-Sensors.html">DigitalSensor</a>, returning whether or not it is seeing the color specified. It is used in <a href="evlib/LineFinder.html">LineFinder</a> along with <a href="evlib/DoubleLineSensor.html">DoubleLineSensor</a> to more accurately find colored lines.</p>
<p>Fun fact: last year when connecting LEDs, we guessed on the resistor values and it burnt out 2 of our digital outputs. Always calculate the current before you plug LEDs in to the Core Device Interface Module.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/ColorSensor.java">ftc/evlib/hardware/sensors/ColorSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

import com.qualcomm.robotcore.hardware.LED;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/22/16
 * 
 * Uses LEDs and a photoresistor to detect the color of a line on the mat
 * 
 * --- light red blue
 * mat    35 250 250
 * red
 * blue
 * white 145 640 550
 *
 * @see DigitalSensor
 */
public class ColorSensor implements DigitalSensor {
    private static final int THRESHOLD = 500;
    private final LED redLight, blueLight;
    private final AveragedSensor lightSensor;
    private String ledColorString = &quot;unknown&quot;;

    /**
     * @param redLight    the red LED
     * @param blueLight   the blue LED
     * @param lightSensor the photoresistor
     */
    public ColorSensor(LED redLight, LED blueLight, AveragedSensor lightSensor) {
        this.redLight = redLight;
        this.blueLight = blueLight;
        this.lightSensor = lightSensor;
    }

    /**
     * turn off both LEDs
     */
    public void turnOff() {
        redLight.enable(true);
        blueLight.enable(true);
        ledColorString = &quot;blank&quot;;
    }

    /**
     * turn on the red LED and turn off the blue LED
     */
    public void setColorRed() {
        redLight.enable(false);
        blueLight.enable(true);
        ledColorString = &quot;red&quot;;
    }

    /**
     * turn on the blue LED and turn off the red LED
     */
    public void setColorBlue() {
        redLight.enable(true);
        blueLight.enable(false);
        ledColorString = &quot;blue&quot;;
    }

    /**
     * turn on both LEDs
     */
    public void setColorMagenta() {
        redLight.enable(false);
        blueLight.enable(false);
        ledColorString = &quot;magenta&quot;;
    }

    /**
     * @return the name of the current color for telemetry purposes
     */
    public String getLedColorString() {
        return ledColorString;
    }

    /**
     * update the light sensor
     */
    public void act() {
        lightSensor.act();
    }

    /**
     * @return true if it is seeing the color requested
     */
    @Override
    public Boolean getValue() {
        return lightSensor.getValue() &gt; THRESHOLD;
    }

    /**
     * @return the raw value of the light sensor
     */
    public double getRawValue() {
        return lightSensor.getValue();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>LineFinder uses a <a href="evlib/DoubleLineSensor.html">DoubleLineSensor</a> and a <a href="evlib/ColorSensor.html">ColorSensor</a> to find lines of different colors. You use it by setting the color you are looking for, then calling getValue() to see if it is seeing the line color you requested.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/LineFinder.java">ftc/evlib/hardware/sensors/LineFinder.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;


import static ftc.evlib.driverstation.Telem.telemetry;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 4/10/16
 * 
 * Combines two line sensors and an LED-powered color sensor to detect the color of lines
 *
 * @see ColorSensor
 * @see DoubleLineSensor
 */
public class LineFinder implements DigitalSensor {
    public enum LineColor {
        RED,
        BLUE,
        WHITE_RED_TEAM,
        WHITE_BLUE_TEAM
    }

    private final ColorSensor colorSensor;
    private final DoubleLineSensor doubleLineSensor;
    private LineColor lookingFor = LineColor.WHITE_RED_TEAM;
    private boolean justStarted = true;


    public LineFinder(ColorSensor colorSensor, DoubleLineSensor doubleLineSensor) {
        this.colorSensor = colorSensor;
        this.doubleLineSensor = doubleLineSensor;
    }

    /**
     * start looking for a line of a certain color by turning the LEDs to a certain color
     *
     * @param lineColor the color of the line to look for
     */
    public void startLookingFor(LineColor lineColor) {
        lookingFor = lineColor;
        justStarted = true;
        if (lookingFor == LineColor.RED) {
            colorSensor.setColorBlue();
        } else if (lookingFor == LineColor.BLUE) {
            colorSensor.setColorRed();
        } else if (lookingFor == LineColor.WHITE_RED_TEAM) {
            colorSensor.setColorBlue();
        } else if (lookingFor == LineColor.WHITE_BLUE_TEAM) {
            colorSensor.setColorRed();
        }
    }

    /**
     * note: it skips the first loop because the LEDs take 1 loop to turn on
     *
     * @return true if the line of the requested color was found
     */
    @Override
    public Boolean getValue() {
        if (justStarted) {
            justStarted = false;
            telemetry.addData(&quot;Just started line finder&quot;, &quot;&quot;);
        } else {
            if (lookingFor == LineColor.RED) {
                return doubleLineSensor.getValue() &amp;&amp; !colorSensor.getValue();
            } else if (lookingFor == LineColor.BLUE) {
                return doubleLineSensor.getValue() &amp;&amp; !colorSensor.getValue();
            } else if (lookingFor == LineColor.WHITE_RED_TEAM) {
                return doubleLineSensor.getValue() &amp;&amp; colorSensor.getValue();
            } else if (lookingFor == LineColor.WHITE_BLUE_TEAM) {
                return doubleLineSensor.getValue() &amp;&amp; colorSensor.getValue();
            }
        }
        return false;
    }

    public void act() {
        doubleLineSensor.act();
        colorSensor.act();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>The GamepadManager adds edge detection to all the gamepad buttons and analog scaling to the joysticks and left/right triggers.</p>
<p>You can use it by first creating a new GamepadManager. You have to pass in the gamepad and a Function to scale the analog values with.</p>
<pre><code class="language-java">driver1 = new GamepadManager(gamepad1, Functions.squared());
</code></pre>
<p>Then to use it, for example to tell if button &quot;a&quot; has just been pressed:</p>
<pre><code class="language-java">if (driver1.a.justPressed()){
    //do something
}
</code></pre>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/driverstation/GamepadManager.java">java/ftc/evlib/driverstation/GamepadManager.java</a></p>
<pre><code class="language-java">package ftc.evlib.driverstation;

import com.qualcomm.robotcore.hardware.Gamepad;

import ftc.electronvolts.util.AnalogInputScaler;
import ftc.electronvolts.util.DigitalInputEdgeDetector;
import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 1/9/16
 * 
 * This class wraps a gamepad and adds:
 * Edge detection to the digital inputs (buttons and dpad) {@see DigitalInputEdgeDetector}
 * Scaling to the analog inputs (joysticks and triggers) {@see AnalogInputScaler}
 */
public class GamepadManager {
    //this stores all the wrapped digital inputs
    public final DigitalInputEdgeDetector a, b, x, y, left_bumper, right_bumper,
            dpad_up, dpad_down, dpad_left, dpad_right,
            left_stick_button, right_stick_button, back, start;

    //this stores all the wrapped analog inputs
    public final AnalogInputScaler left_stick_x, left_stick_y, right_stick_x, right_stick_y,
            left_trigger, right_trigger;


    //use this constructor for no joystick scaling
    public GamepadManager(Gamepad gamepad) {
        this(gamepad, Functions.none());
    }

    //use this constructor for custom joystick scaling
    public GamepadManager(Gamepad gamepad, Function scalingFunction) {
        //create all the DigitalInputEdgeDetector objects
        a = new DigitalInputEdgeDetector(GamepadIEFactory.a(gamepad));
        b = new DigitalInputEdgeDetector(GamepadIEFactory.b(gamepad));
        x = new DigitalInputEdgeDetector(GamepadIEFactory.x(gamepad));
        y = new DigitalInputEdgeDetector(GamepadIEFactory.y(gamepad));
        left_bumper = new DigitalInputEdgeDetector(GamepadIEFactory.left_bumper(gamepad));
        right_bumper = new DigitalInputEdgeDetector(GamepadIEFactory.right_bumper(gamepad));
        dpad_up = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_up(gamepad));
        dpad_down = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_down(gamepad));
        dpad_left = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_left(gamepad));
        dpad_right = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_right(gamepad));
        left_stick_button = new DigitalInputEdgeDetector(GamepadIEFactory.left_stick_button(gamepad));
        right_stick_button = new DigitalInputEdgeDetector(GamepadIEFactory.right_stick_button(gamepad));
        back = new DigitalInputEdgeDetector(GamepadIEFactory.back(gamepad));
        start = new DigitalInputEdgeDetector(GamepadIEFactory.start(gamepad));

        //create all the AnalogInputScaler objects
        left_stick_x = new AnalogInputScaler(GamepadIEFactory.left_stick_x(gamepad), scalingFunction);
        left_stick_y = new AnalogInputScaler(GamepadIEFactory.left_stick_y(gamepad), scalingFunction);
        right_stick_x = new AnalogInputScaler(GamepadIEFactory.right_stick_x(gamepad), scalingFunction);
        right_stick_y = new AnalogInputScaler(GamepadIEFactory.right_stick_y(gamepad), scalingFunction);
        left_trigger = new AnalogInputScaler(GamepadIEFactory.left_trigger(gamepad), scalingFunction);
        right_trigger = new AnalogInputScaler(GamepadIEFactory.right_trigger(gamepad), scalingFunction);
    }

    public void update() {
        //update all the values
        a.update();
        b.update();
        x.update();
        y.update();

        left_bumper.update();
        right_bumper.update();

        left_trigger.update();
        right_trigger.update();

        dpad_up.update();
        dpad_down.update();
        dpad_left.update();
        dpad_right.update();

        left_stick_button.update();
        right_stick_button.update();

        back.update();
        start.update();

        left_stick_x.update();
        left_stick_y.update();

        right_stick_x.update();
        right_stick_y.update();


        /*telemetry.addData(&quot;a&quot;, a.isPressed());
        telemetry.addData(&quot;b&quot;, b.isPressed());
        telemetry.addData(&quot;x&quot;, x.isPressed());
        telemetry.addData(&quot;y&quot;, y.isPressed());
        telemetry.addData(&quot;LB&quot;, left_bumper.isPressed());
        telemetry.addData(&quot;RB&quot;, right_bumper.isPressed());
        telemetry.addData(&quot;DU&quot;, dpad_up.isPressed());
        telemetry.addData(&quot;DD&quot;, dpad_down.isPressed());
        telemetry.addData(&quot;DL&quot;, dpad_left.isPressed());
        telemetry.addData(&quot;DR&quot;, dpad_right.isPressed());
        telemetry.addData(&quot;LSB&quot;, left_stick_button.isPressed());
        telemetry.addData(&quot;RSB&quot;, right_stick_button.isPressed());
        telemetry.addData(&quot;Back&quot;, back.isPressed());
        telemetry.addData(&quot;Start&quot;, start.isPressed());

        telemetry.addData(&quot;Left X&quot;, left_stick_x.isPressed());
        telemetry.addData(&quot;Left Y&quot;, left_stick_y.isPressed());
        telemetry.addData(&quot;Right X&quot;, right_stick_x.isPressed());
        telemetry.addData(&quot;Right Y&quot;, right_stick_y.isPressed());
        telemetry.addData(&quot;Left Trigger&quot;, left_trigger.isPressed());
        telemetry.addData(&quot;Right Trigger&quot;, right_trigger.isPressed());
        */
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In order for all the classes to have easy access to the telemetry object, we decided to make it global. It is set inside AbstractOp so any opmode that extends AbstractOp automatically sets it up. If you use normal opmodes, you can still set it up with <code>Telem.telemetry = telemetry;</code></p>
<p>To use it, you can add a static import:</p>
<pre><code class="language-java">import static ftc.evlib.driverstation.Telem.telemetry;
</code></pre>
<p>Then access it later in the class:</p>
<pre><code class="language-java">telemtry.addData(&quot;Test&quot;, 3);

//this displays whether or not the gyro is calibrated on the driver phone
Telem.displayGyroIsCalibrated(gyro);
</code></pre>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/driverstation/Telem.java">ftc/evlib/driverstation/Telem.java</a></p>
<pre><code class="language-java">package ftc.evlib.driverstation;

import com.qualcomm.robotcore.hardware.GyroSensor;

import org.firstinspires.ftc.robotcore.external.Telemetry;

import ftc.electronvolts.util.ResultReceiver;
import ftc.evlib.Fake;
import ftc.evlib.vision.framegrabber.VuforiaFrameFeeder;
import ftc.evlib.vision.processors.BeaconColorResult;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 *
 * This class gives everything access to the telemetry
 * Put this in your opmode:
 *
 * Telem.telemetry = telemetry;
 *
 * To set the telemetry variable for anything to use.
 *
 * @see Telemetry
 */
public class Telem {
    //this will fail silently and move on if you write to it before it is set by the opmode
    public static Telemetry telemetry = Fake.TELEMETRY;

    //this will cause errors if you write to it before it is set by the opmode
//    public static Telemetry telemetry = null;

    /**
     * Display whether or not a ResultReceiver is ready on the driver station telemetry
     *
     * @param receiver the ResultReceiver
     * @param caption  the caption of the telemetry item
     * @param ready    the value of the telemetry item if ready
     * @param notReady the value of the telemetry item if not ready
     */
    public static void displayReceiverReadiness(ResultReceiver receiver, String caption, String ready, String notReady) {
        if (receiver.isReady()) {
            telemetry.addData(caption, ready);
        } else {
            telemetry.addData(caption, notReady);
        }
    }

    /**
     * Display whether or not a Vuforia ResultReceiver is ready on the driver station telemetry
     *
     * @param receiver the ResultReceiver of the VuforiaFrameFeeder type
     */
    public static void displayVuforiaReadiness(ResultReceiver&lt;VuforiaFrameFeeder&gt; receiver) {
        displayReceiverReadiness(receiver, &quot;vuforia&quot;, &quot;ready&quot;, &quot;NOT INITIALIZED!!!&quot;);
    }

    /**
     * Display a BeaconColorResult on the telemetry
     *
     * @param receiver the ResultReceiver that contains the BeaconColorResult
     */
    public static void displayBeaconColorResult(ResultReceiver&lt;BeaconColorResult&gt; receiver) {
        if (receiver.isReady()) {
            BeaconColorResult result = receiver.getValue();
            telemetry.addData(&quot;leftColor&quot;, result.getLeftColor());
            telemetry.addData(&quot;rightColor&quot;, result.getRightColor());
        } else {
            telemetry.addData(&quot;receiver not ready&quot;, &quot;&quot;);
        }
    }


    /**
     * Display a BeaconColor on the telemetry
     *
     * @param receiver the ResultReceiver that contains the BeaconColor
     */
    public static void displayBeaconColor(ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; receiver) {
        if (receiver.isReady()) {
            telemetry.addData(&quot;color&quot;, receiver.getValue());
        } else {
            telemetry.addData(&quot;receiver not ready&quot;, &quot;&quot;);
        }
    }

    /**
     * Display whether or not a gyro sensor is calibrated on the telemetry screen
     *
     * @param gyro the gyro sensor
     */
    public static void displayGyroIsCalibrated(GyroSensor gyro) {
        if (gyro.isCalibrating()) {
            telemetry.addData(&quot;Gyro state&quot;, &quot;CALIBRATING&quot;);
        } else {
            telemetry.addData(&quot;Gyro state&quot;, &quot;ready&quot;);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>StepTimer keeps track of how long it takes for something to execute. For example:</p>
<pre><code class="language-java">StepTimer stepTimer = new StepTimer(&quot;MATH&quot;);
stepTimer.start();
double result = doComplexMathCalculation(1, 2, 3); //replace this with your actual code.
stepTimer.log(&quot;Complex math calculation&quot;);
</code></pre>
<p>The output in the Android monitor would be:</p>
<pre><code>01-02 03:04:05.678      901-234/? I/MATH: TIME: Complex math calculation: 567 ms
</code></pre>
<p>Here is an example from the <a href="evlib/OpenCV-Image-Processing.html">image processing code</a>:</p>
<pre><code class="language-java">stepTimer.start();
//save the raw camera image for logging
ImageUtil.saveImage(TAG, rgbaFrame, Imgproc.COLOR_RGBA2BGR, &quot;00_camera&quot;, startTime);
stepTimer.log(&quot;save 00&quot;);
</code></pre>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/util/StepTimer.java">ftc/evlib/util/StepTimer.java</a></p>
<pre><code class="language-java">package ftc.evlib.util;

import android.util.Log;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 8/26/16
 *
 * Records and logs the time it takes to complete a certain step in an algorithm
 */
public class StepTimer {
    private final String tag;
    private long timer;

    /**
     * @param tag the tag to give to the android logging
     *            You can search for the tag in the logs to find messages generated by your code
     */
    public StepTimer(String tag) {
        this.tag = tag;
        start();
    }

    /**
     * Start a step
     */
    public void start() {
        timer = System.nanoTime();
    }

    /**
     * Log the name of the step and the time since it started
     *
     * @param message the name of the step
     */
    public void log(String message) {
        Log.i(tag, &quot;TIME: &quot; + message + &quot;: &quot; + String.valueOf(get()) + &quot; ms&quot;);
    }

    /**
     * @return the time since the step started
     */
    public double get() {
        return (System.nanoTime() - timer) / 1000000.0;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>FileUtil manages a directory structure on the robot controller phone:</p>
<ul>
<li>root/sdcard/FTC
<ul>
<li>pictures - outputs of [[ImageProcessor]] operations</li>
<li>logs - outputs of the logging from any opmode</li>
<li>options - storage for autonomous options</li>
<li>configs - storage for servo preset values
<ul>
<li>inside configs is a directory for each [[Robot Configuration]] with its servos' presets</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FileUtil can return a reference to any of these directories, or a new File in any of these directories.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/util/FileUtil.java">ftc/evlib/util/FileUtil.java</a></p>
<pre><code class="language-java">package ftc.evlib.util;

import android.os.Environment;

import java.io.File;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/2/16
 *
 * Utilities to get files and directories on the phone storage
 * All files will be under the &quot;FTC&quot; directory in the phone's root directory
 */

public class FileUtil {
    private static final String APP_DIR_NAME = &quot;FTC&quot;;

    /**
     * @return a reference to the root phone directory
     */
    public static File getRootDir() {
        return Environment.getExternalStorageDirectory();
    }

    /**
     * @return a reference to the root phone directory
     */
    public static File getAppDir() {
        File dir = new File(getRootDir(), &quot;/&quot; + APP_DIR_NAME);
        mkdirsOrThrowException(dir);
        return dir;
    }

    /**
     * Get a reference to a file in the app directory
     *
     * @param filename the name of the file
     * @return the File
     */
    public static File getAppFile(String filename) {
        return new File(getAppDir(), filename);
    }

    public static File getDir(String dirname) {
        File dir = new File(getAppDir(), dirname);
        mkdirsOrThrowException(dir);
        return dir;
    }

    public static File getFile(String dirname, String filename) {
        return new File(getDir(dirname), filename);
    }

    public static File getPicturesDir() {
//        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
        return getDir(&quot;pictures&quot;);
    }

    public static File getPicturesFile(String filename) {
        return new File(getPicturesDir(), filename);
    }

    public static File getLogsDir() {
        return getDir(&quot;logs&quot;);
    }

    public static File getLogsFile(String filename) {
        return new File(getLogsDir(), filename);
    }

    public static File getOptionsDir() {
        return getDir(&quot;options&quot;);
    }

    public static File getOptionsFile(String filename) {
        return new File(getOptionsDir(), filename);
    }

    public static File getConfigsDir() {
        return getDir(&quot;configs&quot;);
    }

    public static File getConfigsFile(String filename) {
        return new File(getConfigsDir(), filename);
    }

    public static void mkdirsOrThrowException(File dir) {
        //noinspection ResultOfMethodCallIgnored
        dir.mkdirs();
        if (!dir.exists() || !dir.isDirectory()) {
            throw new IllegalArgumentException(&quot;Error creating directory \&quot;&quot; + dir + '&quot;');
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>The unfortunate part about programming for the FTC robot is that to test code, you must build, download, then run; for large codebases this is often a slow process. Sometimes, there will be numbers which are not necessarily fixed, and rebuilding just before every competition and match is infeasible.</p>
<p>This collection of classes gives you a dynamic solution to this problem:</p>
<ul>
<li><code>ftc.evlib.opmodes.AbstractOptionsOp</code></li>
<li><code>ftc.evlib.util.FileUtil</code></li>
<li><code>ftc.electronvolts.util.OptionsFile</code></li>
<li><code>ftc.electronvolts.util.OptionEntry</code></li>
</ul>
<p>These classes allow you to set variables by running an <code>AbstractOptionsOp</code>, then access them later in an unrelated Opmode.</p>
<blockquote>
<p>NOTE: Option setting is an <strong>opt-in</strong> feature. An opmode for setting options is not included.</p>
</blockquote>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>You'll probably want to orient your driver hub to be landscape to use the interface</p>
<blockquote>
<p>TODO: Add picture of driver hub</p>
</blockquote>
<p>The table on the right shows a list of option names and their current values.</p>
<ul>
<li>To select an option, press dpad-up or dpad-down (navigate up or down) until you reach it (the arrows are on either side of the option).</li>
<li>For discrete variables (e.g. integers), press the left/right bumpers to modify their values (this change will be reflected on the telemetry log).</li>
<li>For approximate continuous variables (e.g. floating-points), press the left/right triggers.
<ul>
<li>The depth of the trigger press will be reflected in the rate at which the option is modified (the heavier the touch, the more the variable goes up).</li>
</ul>
</li>
<li>To save the options, press the start button
<ul>
<li><strong>The options will not save when the opmode finishes</strong></li>
</ul>
</li>
<li>To clear changes to the last save, press the reset button
<ul>
<li><strong>This will irrevocably remove all changes that are not saved</strong></li>
</ul>
</li>
</ul>
<h2 id="defining-variables"><a class="header" href="#defining-variables">Defining Variables</a></h2>
<p>You'll first want to set up two classes: An OpMode extending <code>AbstractOptionsOp</code> and an enum class implementing <code>OptionEntry</code>. Here is an example:</p>
<pre><code class="language-java">// ExampleOptions.java

import ftc.electronvolts.util.OptionEntry;

public enum ExampleOptions implements OptionEntry {

    TypeData&lt;?&gt; data;

    @Override
    public TypeData&lt;?&gt; getData {
        return data;
    }

    ExampleOptions(TypeDataBuilder&lt;?&gt; t) {
        data = t.build();
    }

}

// ExampleOptionsOp.java

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import ftc.evlib.opmodes.AbstractOptionsOp;

@TeleOp(name = &quot;Example Options Op&quot;)
public class ExampleOptionsOp extends AbstractOptionsOp {
    @Override
    protected void setImplementationSpecificDetails() {

        filename = &quot;example_options.json&quot;;
        options = ExampleOptions.class;

    }
}
</code></pre>
<p>These classes would run fine by themselves, but if you try running &quot;Example Options Op&quot; you would see nothing. To create options, you would have to define an entry in <code>ExampleOptions</code>. Let's define one that is heavily suited for this task: The alliance color. It's one you'll only know on the field, and will not necessarily have the time to set.</p>
<p>Let's say that you represent your alliance color like so:</p>
<pre><code class="language-java">// AllianceColor.java

public enum AllianceColor {
    RED,
    BLUE,
}
</code></pre>
<p>We'll define an option with these properties:</p>
<ul>
<li>It is called <code>ALLIANCE_COLOR</code></li>
<li>It stores the <code>AllianceColor</code> enum</li>
<li>We somehow tipped off the judge, so we're expecting it to mostly be red</li>
</ul>
<p>Here is the full definition:</p>
<pre><code class="language-java">ALLIANCE_COLOR(TypeDataBuilder
    .enumType(AllianceColor.class)
    .withFallback(AllianceColor.RED)
)
</code></pre>
<p>Here it is inserted into <code>ExampleOptions</code>:</p>
<pre><code class="language-java">public enum ExampleOptions implements OptionEntry {

    ALLIANCE_COLOR(TypeDataBuilder
        .enumType(AllianceColor.class)
        .withFallback(AllianceColor.RED)
    )

    TypeData&lt;?&gt; data;

    @Override
    public TypeData&lt;?&gt; getData {
        return data;
    }

    ExampleOptions(TypeDataBuilder&lt;?&gt; t) {
        data = t.build();
    }

}
</code></pre>
<p>Now if you run &quot;Example Options Op&quot; again, it will show this one option, which you can now change using the bumpers on your controller. Adding more options is as easy as adding more enum variants.</p>
<blockquote>
<p>TODO: add an image</p>
</blockquote>
<h2 id="fetching-options"><a class="header" href="#fetching-options">Fetching Options</a></h2>
<p>After you have set these options, you can programatically access them using the <code>OptionsFile</code> class. Admittedly this is not an easy thing to do, and will be the next thing to improve about the option framework.</p>
<p>To get the object containing the options, use:</p>
<pre><code class="language-java">OptionsFile file = new OptionsFile(FileUtil.getOptionsFile(&quot;example_options.json&quot;));
</code></pre>
<p>The string <code>&quot;example_options.json&quot;</code> comes from the <code>ExampleOptionsOp</code> defined before.</p>
<p>To get out the <code>AllianceColor</code>, access the object like so:</p>
<pre><code class="language-java">AllianceColor color = (AllianceColor) file.load(ExampleOptions.ALLIANCE_COLOR);
</code></pre>
<p>The cast is necessary, without it you will have a compile error.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Welcome to the EVLib wiki!</p>
<p>EVLib is designed to assist in the development of very powerful FTC autonomous programs. It provides helper mechanisms for a variety of hardware, like servo speed control.</p>
<p>For starters, check <a href="evlib/Importing-Into-Your-Project.html">the first chapter</a> for instructions on importing into your project.</p>
<p>This tutorial uses our <a href="https://github.com/FTC7393/state-machine-framework/">state-machine-framework</a> library. Click <a href="https://github.com/FTC7393/state-machine-framework/wiki">here</a> for the state-machine-framework wiki.</p>
<div style="break-before: page; page-break-before: always;"></div><p><del>Importing the library into the ftc-app is extremely simple!</del></p>
<p>Unfortunately right now importing Evlib is not very simple, since the library has been migrated and
releases aren't up to date. We're working on it though!</p>
<ol>
<li>
<p>Download the latest release <code>EVLib-release.aar</code>. You can also click <del><a href="https://github.com/FTC7393/EVLib/raw/master/EVLib-release.aar">here</a></del>.</p>
</li>
<li>
<p>Copy the downloaded library to the <code>(your project root)/libs/</code> directory.</p>
</li>
<li>
<p>Now you need to tell gradle that EVLib is a dependency. In android studio, edit the <code>TeamCode/build.gradle</code> file and add the following lines:</p>
</li>
</ol>
<pre><code class="language-groovy">dependencies {
    implementation 'EVlib-release.aar`
}
</code></pre>
<p>Attaching the source (Optional, out of date):</p>
<ol>
<li>
<p><del><a href="https://github.com/FTC7393/EVLib/archive/master.zip">Download the repository as a zip file</a></del> and extract it.</p>
</li>
<li>
<p>When a yellow bar appears at the top of the screen:</p>
</li>
</ol>
<p><img src="https://github.com/FTC7393/EVLib/blob/master/images/attach.png?raw=true" alt="Decompiled .class file" /></p>
<ol start="3">
<li>Click on the blue link that says &quot;Choose Sources...&quot; and a window will pop up.</li>
</ol>
<p><img src="https://github.com/FTC7393/EVLib/blob/master/images/attach2.png?raw=true" alt="attach sources window" /></p>
<ol start="4">
<li>Choose the &quot;EVLib-master/EVLib/src/main/java directory&quot; from the file you downloaded.</li>
</ol>
<p>You are done! You can look at the next chapter to get you started on using the library.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The sample code is in the repository in the <a href="https://github.com/FTC7393/EVLib/tree/master/sample/">sample/</a> directory. It has a few sub-folders: v0, v1, etc. Each &quot;version&quot; adds more functionality to the code.</p>
<p>The first sample is explained in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><p>If you are just starting out with FTC, using this library to its fullest extend probably seems intimidating. You can, however, use some of the simple functions of the library to save yourself some headaches. The following is an example of a TeleOp program that uses EVLib for 2 things:</p>
<ol>
<li>
<p><a href="evlib/GamepadManager.html">Edge detection on the joystick buttons</a>. It might not seem like a big deal, but we spent too much time with flags and nested if statements before moving the edge detection to a dedicated class.</p>
</li>
<li>
<p><a href="evlib/Creating-Motors.html">Management of the motor commands</a>. The EVLib can &quot;wrap&quot; a DcMotor object into either a Motor object (no encoder) or a MotorEnc object. This wrapper class receives your commands and sends them when you call the update() method.</p>
</li>
</ol>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v0/SampleTeleOp.java">/sample/v0/SampleTeleOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v0;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.Servo;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.Utility;
import ftc.evlib.driverstation.GamepadManager;
import ftc.evlib.hardware.motors.Motor;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.Stoppers;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * Sample TeleOp that uses some of the EVLib functionality
 */

@TeleOp(name = &quot;SampleTeleOp V0&quot;)
public class SampleTeleOp extends OpMode {
    /**
     * Adds edge detection to the gamepad buttons
     * and analog scaling to the joysticks
     */
    private GamepadManager driver1, driver2;

    /**
     * Wraps the motors to easily keep track of motor direction
     */
    private Motor leftMotor, rightMotor;

    /**
     * Servo object from the FTC libraries
     */
    private Servo servo;

    /**
     * The servo's current position from 0 to 1
     */
    private double servoPosition;

    /**
     * Takes care of stopping both motors
     */
    private Stoppers stoppers = new Stoppers();

    @Override
    public void init() {
        //get the motors from the hardwareMap and wrap them with the Motor interface
        //         motor factory class method      hardware name, reversed, brake
        leftMotor = Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers);
        rightMotor = Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers);

        //get the servo from the hardwareMap
        servo = hardwareMap.servo.get(&quot;servo&quot;);
    }

    @Override
    public void start() {
        //use a squared function for the joystick scaling
        Function scalingFunction = Functions.squared();

        //create the two drivers' gamepads
        driver1 = new GamepadManager(gamepad1, scalingFunction);
        driver2 = new GamepadManager(gamepad2, scalingFunction);

        //set the servo's position
        servoPosition = 0.5;
    }

    @Override
    public void loop() {
        //set the left and right motor powers based on the scaled joystick values
        leftMotor.setPower(driver1.left_stick_y.getValue());
        rightMotor.setPower(driver1.right_stick_y.getValue());

        //making use of the edge detection from the GamepadManager

        //if the dpad up was just pressed, increase the servo position
        if (driver1.dpad_up.justPressed()) {
            servoPosition += 0.1;
        }

        //if the dpad down was just pressed, decrease the servo position
        if (driver1.dpad_down.justPressed()) {
            servoPosition -= 0.1;
        }

        //limit the servo position to be in the valid range for servos (0 to 1)
        servoPosition = Utility.servoLimit(servoPosition);

        //send the command to the servo
        servo.setPosition(servoPosition);

        //send the motor powers to the motor controller
        leftMotor.update();
        rightMotor.update();
    }

    @Override
    public void stop() {
        //stop both motors
        stoppers.stop();
    }
}
</code></pre>
<p>If you want, you can stop here, you can check out a <a href="evlib/Logging-Example.html">Logging Example</a> for another simple use of EVLib, or you can move on to <a href="evlib/Robot-Configuration.html">Robot Configuration</a> if you want to learn more in depth about the library.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The following is an example of how the Logger and <a href="evlib/FileUtil.html">FileUtil</a> classes are used together in an OpMode to log values. The logs will appear in the phone storage in the FTC/logs folder.</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.yr2016.opmodes;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.util.FileUtil;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 1/13/17
 */

@TeleOp(name = &quot;LogTestOp&quot;)
public class LogTestOp extends OpMode {
    Logger logger = new Logger(&quot;log&quot;, &quot;.csv&quot;, ImmutableList.of(
            new Logger.Column(&quot;gamepad1.left_stick_y&quot;, new InputExtractor&lt;Float&gt;() {
                @Override
                public Float getValue() {
                    return gamepad1.left_stick_y;
                }
            }),
            new Logger.Column(&quot;gamepad1.right_stick_y&quot;, new InputExtractor&lt;Float&gt;() {
                @Override
                public Float getValue() {
                    return gamepad1.right_stick_y;
                }
            })
    ));

    @Override
    public void init() {

    }

    @Override
    public void start() {
        logger.start(FileUtil.getLogsDir());
    }

    @Override
    public void loop() {
        logger.act();
    }

    @Override
    public void stop() {
        logger.stop();
    }
}
</code></pre>
<p>If you want to learn more about the library, check out the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before you write an OpMode using the EVLib, you have to make a class that will retrieve the devices (such as motors, servos, and sensors) from the hardwareMap.</p>
<p>Here is an example of this configuration class:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleRobotCfg.java">/sample/v1/SampleRobotCfg.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.hardware.HardwareMap;

import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.TwoMotors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A basic configuration of a robot with 2 motors, and nothing else.
 * Its purpose is to make the same configuration available to multiple opmodes.
 */

public class SampleRobotCfg extends RobotCfg {
    /**
     * the speed of the robot at 100% power
     * you should replace this with a measured value
     */
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));

    /**
     * the drive motors of the robot
     */
    private final TwoMotors twoMotors;

    public SampleRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);

        // create the twoMotors object
        twoMotors = new TwoMotors(
                //get the left and right motors and wrap it with the EVLib Motor interface
                Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers),
                Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers),
                false, //true for speed mode, false for power mode
                MAX_SPEED
        );
    }

    /**
     * gives the opmodes access to the drive motors
     *
     * @return the drive motors
     */
    public TwoMotors getTwoMotors() {
        return twoMotors;
    }

    @Override
    public void act() {

    }

    @Override
    public void stop() {

    }
}
</code></pre>
<p>The next step is to bring the robot to life with a Basic TeleOp Program (next chapter)</p>
<div style="break-before: page; page-break-before: always;"></div><p>After you have <a href="evlib/Robot-Configuration.html">set up a RobotCfg</a>, you can now write TeleOp and Autonomous OpModes.</p>
<p>The following is a sample TeleOp program that uses the sample RobotCfg.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleTeleOp.java">/sample/v1/SampleTeleOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample TeleOp program that will allow you to control 2 motors with the left and right joysticks
 */

@TeleOp(name = &quot;SampleTeleOp V1&quot;)
public class SampleTeleOp extends AbstractTeleOp&lt;SampleRobotCfg&gt; {
    @Override
    protected Function getJoystickScalingFunction() {
        //use an exponentially based function for the joystick scaling to allow fine control
        return Functions.eBased(5);
//        return Functions.squared();
//        return Functions.cubed();
//        return Functions.none();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        //create and return a SampleRobotCfg for the library to use
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {

    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {
        //set the motor powers to the joystick values
        robotCfg.getTwoMotors().runMotors(
                driver1.left_stick_y.getValue(),
                driver1.right_stick_y.getValue()
        );
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>The next step is to make a Basic Autonomous Program (next chapter).</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before you can make an autonomous program, add the following field to your RobotCfg:</p>
<pre><code class="language-java">    //the speed of the robot at 100% power
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));
</code></pre>
<p>This represents your robot's speed at 100% power. You can calculate it or determine it by measuring the distance your robot drives in a certain amount of time. The Distance and Time classes support a variety of units (you could <em>technically</em> express you robot's speed in nautical miles per week).</p>
<p>The following is an Autonomous program that drives forward for 2 feet (using the speed defined in the robot config):</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleAuto.java">/sample/v1/SampleAuto.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.opmodes.AbstractAutoOp;
import ftc.evlib.statemachine.EVStates;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample autonomous that drives forward for 2 feet.
 */

@Autonomous(name = &quot;SampleAuto V1&quot;)
public class SampleAuto extends AbstractAutoOp&lt;SampleRobotCfg&gt; {

    /**
     * defines all the possible states for the state machine
     * modify this to have whatever states you want
     */
    private enum S implements StateName {
        DRIVE,
        STOP
    }

    @Override
    public StateMachine buildStates() {
        //create a new builder for the states, starting with the DRIVE state
        StateMachineBuilder b = new StateMachineBuilder(S.DRIVE);

        //define the DRIVE state to drive for 2 feet and move to the STOP state
        b.add(EVStates.drive(S.DRIVE, S.STOP, Distance.fromFeet(2), robotCfg.getTwoMotors(), 0.5));

        //define the STOP state to be empty (and never exit) so the state machine will stop
        b.addStop(S.STOP);

        //build and return the StateMachine
        return b.build();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {

    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>You can simplify this autonomous a bit by customizing the StateMachineBuilder (next chapter).</p>
<div style="break-before: page; page-break-before: always;"></div><p>Currently in the autonomous we have the following:</p>
<pre><code class="language-java">        //define the DRIVE state to drive for 2 feet and move to the STOP state
        b.add(EVStates.drive(S.DRIVE, S.STOP, Distance.fromFeet(2), robotCfg.getTwoMotors(), 0.5));
</code></pre>
<p>It would be nice if we didn't have to specify the robot's max speed and the motors to use for each drive state.
The solution for that is to make a class that extends StateMachineBuilder. This custom builder will store the parameters that appear commonly in the drive state and add a convenience method with fewer arguments.</p>
<p>The line above could be changed to:</p>
<pre><code class="language-java">        //more readable and less tedious to type
        b.addDrive(S.DRIVE, S.STOP, Distance.fromFeet(2), 0.5);
</code></pre>
<p>Here is the subclass to StateMachineBuilder with the convenience method:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v2/SampleStateMachineBuilder.java">/sample/v2/SampleStateMachineBuilder.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v2;

import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.motors.TwoMotors;
import ftc.evlib.statemachine.EVStates;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample extension of the StateMachineBuilder.
 * This subclass adds one convenience method for autonomous opmodes.
 */

public class SampleStateMachineBuilder extends StateMachineBuilder {
    /**
     * The drive motors
     */
    private final TwoMotors twoMotors;

    /**
     * Create a SampleStateMachineBuilder, passing it the drive motors
     * The drive motors will be passed to the drive state every time
     *
     * @param firstStateName the state to start with
     * @param twoMotors      the robot's drive motors
     */
    public SampleStateMachineBuilder(StateName firstStateName, TwoMotors twoMotors) {
        super(firstStateName);
        this.twoMotors = twoMotors;
    }

    /**
     * convenience method for adding a drive state
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to after the drive is complete
     * @param distance      the distance to drive
     * @param velocity      the velocity to drive at
     */
    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity) {
        //add the drive state with the motors and speed from sampleRobotCfg
        add(EVStates.drive(stateName, nextStateName, distance, twoMotors, velocity));
    }
}
</code></pre>
<p>We then have to change our creation of the StateMachineBuilder to create this new subclass instead, and then we can simplify the drive state.</p>
<p>Here is the autonomous with both changes:</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v2/SampleAuto.java">/sample/v2/SampleAuto.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v2;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.opmodes.AbstractAutoOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample autonomous that drives forward for 2 feet.
 * This one uses a custom builder
 */

@Autonomous(name = &quot;SampleAuto V2&quot;)
public class SampleAuto extends AbstractAutoOp&lt;SampleRobotCfg&gt; {

    /**
     * defines all the possible states for the state machine
     * modify this to have whatever states you want
     */
    private enum S implements StateName {
        DRIVE,
        STOP
    }

    @Override
    public StateMachine buildStates() {
        //create a new builder for the states, starting with the DRIVE state
        //this time we are using the custom builder and passing it the drive motors from the robotCfg
        SampleStateMachineBuilder b = new SampleStateMachineBuilder(S.DRIVE, robotCfg.getTwoMotors());

        //define the DRIVE state to drive for 2 feet and move to the STOP state

        //the old code without the custom builder:
//        b.add(EVStates.drive(S.DRIVE, S.STOP, Distance.fromFeet(2), robotCfg.getTwoMotors(), 0.5));

        //the new code (more readable and less tedious to type):
        b.addDrive(S.DRIVE, S.STOP, Distance.fromFeet(2), 0.5);

        //define the STOP state to be empty (and never exit) so the state machine will stop
        b.addStop(S.STOP);

        //build and return the StateMachine
        return b.build();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        //it will save logs in /FTC/logs/autonomous[....].csv on the robot controller phone
        return new Logger(&quot;autonomous&quot;, &quot;.csv&quot;, ImmutableList.of(
                //each one of these is a column in the log file
                new Logger.Column(&quot;state&quot;, new InputExtractor&lt;StateName&gt;() {
                    @Override
                    public StateName getValue() {
                        return stateMachine.getCurrentStateName();
                    }
                }),
                new Logger.Column(&quot;leftMotor power&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return robotCfg.getTwoMotors().getValue(0);
                    }
                }),
                new Logger.Column(&quot;rightMotor power&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return robotCfg.getTwoMotors().getValue(1);
                    }
                })
        ));
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {

    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>I might not seem like a big improvement, but it makes a huge difference when you have upwards of 20 drive states you are trying to debug. It can also be applied to states that take more parameters, such as a gyro turn which needs <a href="evlib/NMotors.html">TwoMotors</a>, a GyroSensor, and a rotation speed (which could then be the same for all gyro turns).</p>
<p>The next step is to use <a href="evlib/Servo-Presets.html">Servo Presets</a> to add some features to the servos.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The idea of servo presets is to replace &quot;magic numbers&quot; (numbers whose purpose is not obvious) with named servo positions. For example, instead of <code>7.341</code>, you can write <code>ArmServoPresets.LEFT</code> -- much more readable.</p>
<p>Another feature of the servo presets is that you can modify the preset values without changing the app and re-uploading to the phone.</p>
<p>The way these two features are implemented is that each servo has an enum of presets:</p>
<pre><code class="language-java">    /**
     * all the possible values for the arm servo
     */
    public enum ArmServoPresets {
        LEFT,
        MIDDLE,
        RIGHT
    }
</code></pre>
<p>and each RobotCfg has a list of servos, each of which has a hardware name (such as <code>&quot;armServo&quot;</code>) and a list of presets determined from the enum (such as <code>ArmServoPresets.values()</code>):</p>
<pre><code class="language-java">
    /**
     * defines all the servos on the robot
     */
    public enum SampleServoName implements ServoName {
        //enum name(&quot;hardware name&quot;, preset enum.values()),
        ARM_SERVO(&quot;armServo&quot;, ArmServoPresets.values()),
        LEG_SERVO(&quot;legServo&quot;, LegServoPresets.values());

        private final String hardwareName;
        private final Enum[] presets;

        SampleServoName(String hardwareName, Enum[] presets) {
            this.hardwareName = hardwareName;
            this.presets = presets;
        }

        @Override
        public String getHardwareName() {
            return hardwareName;
        }

        @Override
        public Enum[] getPresets() {
            return presets;
        }

        @Override
        public Class&lt;? extends RobotCfg&gt; getRobotCfg() {
            return SampleRobotCfg.class;
        }


    }
</code></pre>
<p>To actually enter the preset values, you need to make and run a ServoTuneOp:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleServoTuneOp.java">/sample/v3/SampleServoTuneOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.opmodes.AbstractServoTuneOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * This opmode is very short since the superclass, AbstractServoTuneOp does most of the work. It
 * allows you to change your servo presets without changing the code and re-deploying it to the
 * phone. This means that you can swap out a servo and re-tune it without having to go into the
 * program and fix magic numbers. Note:  It only works if you use presets everywhere instead of
 * hardcoded values.
 *
 * How to use:
 * Select this opmode from the TeleOp menu and run it.
 * Use the dpad up and down to cycle through all the servos
 * Use the dpad left and right to move through the presets for that servo.
 * Press start to save the current preset of the current servo to the current value.
 *
 * The presets are saved in files that are retrieved when you run other opmodes to find the value of each preset.
 */

@TeleOp(name = &quot;SampleServoTuneOp V3&quot;)
public class SampleServoTuneOp extends AbstractServoTuneOp {
    @Override
    protected RobotCfg createRobotCfg() {
        //create a new SampleRobotConfig and return it.
        //the superclass will extract the servos and do the rest.
        return new SampleRobotCfg(hardwareMap);
    }
}
</code></pre>
<p>The details of how the servos are initialized are in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Here is the SampleRobotConfig with the servo names and presets added:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleRobotCfg.java">/sample/v3/SampleRobotCfg.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.qualcomm.robotcore.hardware.HardwareMap;

import java.util.Map;

import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.TwoMotors;
import ftc.evlib.hardware.servos.ServoCfg;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.hardware.servos.Servos;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A more complicated configuration of a robot with 2 motors and 2 servos.
 */

public class SampleRobotCfg extends RobotCfg {
    /**
     * the speed of the robot at 100% power
     * you should replace this with a measured value
     */
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));

    /**
     * the drive motors of the robot
     */
    private final TwoMotors twoMotors;

    /**
     * stores all the servos of the robot
     */
    private final Servos servos;

    /**
     * all the possible values for the arm servo
     */
    public enum ArmServoPresets {
        LEFT,
        MIDDLE,
        RIGHT
    }

    /**
     * all the possible values for the leg servo
     */
    public enum LegServoPresets {
        DOWN,
        MIDDLE,
        UP
    }

    /**
     * defines all the servos on the robot
     */
    public enum SampleServoName implements ServoName {
        //enum name(&quot;hardware name&quot;, preset enum.values()),
        ARM_SERVO(&quot;armServo&quot;, ArmServoPresets.values()),
        LEG_SERVO(&quot;legServo&quot;, LegServoPresets.values());

        private final String hardwareName;
        private final Enum[] presets;

        SampleServoName(String hardwareName, Enum[] presets) {
            this.hardwareName = hardwareName;
            this.presets = presets;
        }

        @Override
        public String getHardwareName() {
            return hardwareName;
        }

        @Override
        public Enum[] getPresets() {
            return presets;
        }

        @Override
        public Class&lt;? extends RobotCfg&gt; getRobotCfg() {
            return SampleRobotCfg.class;
        }


    }

    /**
     * Create the SampleRobotCfg with the default servo starting positions
     *
     * @param hardwareMap the hardwareMap from the opmode
     */
    public SampleRobotCfg(HardwareMap hardwareMap) {
        this(hardwareMap, ServoCfg.defaultServoStartPresetMap(SampleServoName.values()));
    }

    /**
     * Create the SampleRobotCfg with custom servo starting positions
     *
     * @param hardwareMap         the hardwareMap from the opmode
     * @param servoStartPresetMap the custom servo starting positions
     */
    public SampleRobotCfg(HardwareMap hardwareMap, Map&lt;ServoName, Enum&gt; servoStartPresetMap) {
        super(hardwareMap);

        // create the twoMotors object
        twoMotors = new TwoMotors(
                //get the left and right motors and wrap it with the EVLib Motor interface
                Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers),
                Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers),
                false, //true for speed mode, false for power mode
                MAX_SPEED
        );

        servos = new Servos(ServoCfg.createServoMap(hardwareMap, servoStartPresetMap));
    }

    /**
     * gives the opmodes access to the drive motors
     *
     * @return the drive motors
     */
    public TwoMotors getTwoMotors() {
        return twoMotors;
    }

    /**
     * gives the opmodes access to the servos
     *
     * @return the servos
     */
    @Override
    public Servos getServos() {
        return servos;
    }

    @Override
    public void act() {

    }

    @Override
    public void stop() {

    }
}
</code></pre>
<p>With the servos now configured, we can move on to <a href="evlib/Adding-Servos-to-TeleOp.html">Adding Servos to TeleOp</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>To use the servos in TeleOp, you have to first get the servo from the robotCfg:</p>
<p><code>armServo = robotCfg.getServo(SampleRobotCfg.SampleServoName.ARM_SERVO);</code></p>
<p>Then you can move the servo to a preset with:</p>
<p><code>armServo.goToPreset(SampleRobotCfg.ArmServoPresets.RIGHT); </code></p>
<p>You can also specify the speed if you want the servo to turn more slowly:</p>
<p><code>armServo.goToPreset(SampleRobotCfg.ArmServoPresets.RIGHT, 0.2); </code></p>
<p>The following is the new TeleOp program with the servos added.</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleTeleOp.java">/sample/v3/SampleTeleOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.opmodes.AbstractTeleOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample TeleOp program that will allow you to control 2 motors with the left and right joysticks
 * This one also has controls for 2 servos:
 * arm servo:
 * dpad_left - go to LEFT
 * dpad_down - go to MIDDLE
 * dpad_right - go to RIGHT
 *
 * leg servo:
 * a button - go to DOWN
 * b button - go to MIDDLE
 * x button - go to UP
 *
 * I guess you could say that this opmode cost us ...
 * ... an arm and a leg!
 */

@TeleOp(name = &quot;SampleTeleOp V3&quot;)
public class SampleTeleOp extends AbstractTeleOp&lt;SampleRobotCfg&gt; {
    private ServoControl armServo, legServo;

    @Override
    protected Function getJoystickScalingFunction() {
        //use an exponentially based function for the joystick scaling to allow fine control
        return Functions.eBased(5);
//        return Functions.squared();
//        return Functions.cubed();
//        return Functions.none();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        //create and return a SampleRobotCfg for the library to use
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        //it will save logs in /FTC/logs/teleop[....].csv on the robot controller phone
        return new Logger(&quot;teleop&quot;, &quot;.csv&quot;, ImmutableList.of(
                //each one of these is a column in the log file
                new Logger.Column(&quot;driver1.left_stick_y&quot;, driver1.left_stick_y),
                new Logger.Column(&quot;driver1.right_stick_y&quot;, driver1.right_stick_y),
                new Logger.Column(&quot;Accelerometer X&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return robotCfg.getAccelerometer().getX();
                    }
                }),
                new Logger.Column(&quot;ARM_SERVO position&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return armServo.getCurrentPosition();
                    }
                }),
                new Logger.Column(&quot;LEG_SERVO position&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return legServo.getCurrentPosition();
                    }
                })
        ));
    }

    @Override
    protected void setup() {
        //get the arm and leg servos from the SampleRobotCfg
        armServo = robotCfg.getServo(SampleRobotCfg.SampleServoName.ARM_SERVO);
        legServo = robotCfg.getServo(SampleRobotCfg.SampleServoName.LEG_SERVO);
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {
        //set the motor powers to the joystick values
        robotCfg.getTwoMotors().runMotors(
                driver1.left_stick_y.getValue(),
                driver1.right_stick_y.getValue()
        );

        //if the left dpad was just pressed
        if (driver1.dpad_left.justPressed()) {
            //move the servo arm to the LEFT position
            armServo.goToPreset(SampleRobotCfg.ArmServoPresets.LEFT);
        }
        //if the down dpad was just pressed
        if (driver1.dpad_down.justPressed()) {
            //move the servo arm to the MIDDLE position
            armServo.goToPreset(SampleRobotCfg.ArmServoPresets.MIDDLE);
        }
        //if the right dpad was just pressed
        if (driver1.dpad_right.justPressed()) {
            //move the servo arm to the RIGHT position
            armServo.goToPreset(SampleRobotCfg.ArmServoPresets.RIGHT);
        }


        //if the a button was just pressed
        if (driver1.a.justPressed()) {
            //move the leg servo to the DOWN position
            legServo.goToPreset(SampleRobotCfg.LegServoPresets.DOWN);
        }
        //if the b button was just pressed
        if (driver1.b.justPressed()) {
            //move the leg servo to the MIDDLE position
            legServo.goToPreset(SampleRobotCfg.LegServoPresets.MIDDLE);
        }
        //if the x button was just pressed
        if (driver1.x.justPressed()) {
            //move the leg servo to the UP position
            legServo.goToPreset(SampleRobotCfg.LegServoPresets.UP);
        }
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>The next step is <a href="evlib/Adding-Servos-to-Autonomous.html">Adding Servos to Autonomous</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Adding servos to the autonomous is a bit more tricky than adding them to TeleOp.
First we have to add convenience methods in the SampleStateMachineBuilder</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleStateMachineBuilder.java">/sample/v3/SampleStateMachineBuilder.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.statemachine.EVStates;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample extension of the StateMachineBuilder.
 * This subclass adds convenience methods for any opmodes that use the SampleRobotConfig.
 */

public class SampleStateMachineBuilder extends StateMachineBuilder {
    /**
     * The SampleRobotCfg to get the drive motors from
     */
    private final SampleRobotCfg sampleRobotCfg;

    /**
     * Create a SampleStateMachineBuilder, passing it the SampleRobotCfg
     * The SampleRobotCfg's drive motors will be passed to the drive state every time
     *
     * @param firstStateName the state to start with
     * @param sampleRobotCfg the robot's configuration
     */
    public SampleStateMachineBuilder(StateName firstStateName, SampleRobotCfg sampleRobotCfg) {
        super(firstStateName);
        this.sampleRobotCfg = sampleRobotCfg;
    }

    /**
     * convenience method for adding a drive state
     *
     * @param stateName the name of the state
     * @param nextStateName the name of the state to go to after the drive is complete
     * @param distance the distance to drive
     * @param velocity the velocity to drive at
     */
    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity) {
        //add the drive state with the motors and speed from sampleRobotCfg
        add(EVStates.drive(stateName, nextStateName, distance, SampleRobotCfg.MAX_SPEED, sampleRobotCfg.getTwoMotors(), velocity));
    }

    /**
     * add a servo init state that sets all the servos to their starting positions
     *
     * @param stateName the name of the state
     * @param nextStateName the state to go to after the servos are initialized
     */
    public void addServoInit(StateName stateName, StateName nextStateName) {
        add(EVStates.servoInit(stateName, nextStateName, sampleRobotCfg.getServos()));
    }

    /**
     * turn a servo to a preset
     *
     * @param stateName the name of the state
     * @param nextStateName the state to go to after the servo is done turning
     * @param servoName the name of the servo as defined in SampleRobotCfg.ServoName
     * @param servoPreset the servo preset defined in SampleRobotCfg.ArmServoPresets and SampleRobotCfg.LegServoPresets
     * @param speed the speed to run the servo at
     * @param waitForDone wether or not to wait for the servo to turn to move to the next state
     */
    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum servoPreset, double speed, boolean waitForDone) {
        //get the servo
        ServoControl servoControl = sampleRobotCfg.getServo(servoName);
        //add the state that will run the command
        add(EVStates.servoTurn(stateName, nextStateName, servoControl, servoPreset, speed, waitForDone));
    }

    /**
     * turn a servo to a preset at max speed
     *
     * @param stateName the name of the state
     * @param nextStateName the state to go to after the servo is done turning
     * @param servoName the name of the servo as defined in SampleRobotCfg.ServoName
     * @param servoPreset the servo preset defined in SampleRobotCfg.ArmServoPresets and SampleRobotCfg.LegServoPresets
     * @param waitForDone wether or not to wait for the servo to turn to move to the next state
     */
    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum servoPreset, boolean waitForDone) {
        //get the servo
        ServoControl servoControl = sampleRobotCfg.getServo(servoName);
        //add the state that will run the command
        add(EVStates.servoTurn(stateName, nextStateName, servoControl, servoPreset, waitForDone));
    }


}
</code></pre>
<p>Then comes the easy part -- adding the servo init and turn states to the autonomous:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleAuto.java">/sample/v3/SampleAuto.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.opmodes.AbstractAutoOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample autonomous that:
 * 1. Initializes the servos
 * 2. Drives forward 2 feet
 * 3. Turns a servo arm
 */

@Autonomous(name=&quot;SampleAuto V3&quot;)
public class SampleAuto extends AbstractAutoOp&lt;SampleRobotCfg&gt; {

    /**
     * defines all the possible states for the state machine
     * modify this to have whatever states you want
     */
    private enum S implements StateName {
        SERVO_INIT,
        DRIVE,
        SERVO_ARM,
        STOP
    }

    @Override
    public StateMachine buildStates() {
        //create a new builder for the states, starting with the SERVO_INIT state
        //we are using the custom builder and passing it the robotCfg
        SampleStateMachineBuilder b = new SampleStateMachineBuilder(S.SERVO_INIT, robotCfg);

        //add the servo initialization state
        b.addServoInit(S.SERVO_INIT, S.DRIVE);

        //define the DRIVE state to drive for 2 feet and move to the STOP state
        b.addDrive(S.DRIVE, S.SERVO_ARM, Distance.fromFeet(2), 0.5);

        //add the servo turn state
        b.addServo(S.SERVO_ARM, S.STOP, SampleRobotCfg.SampleServoName.ARM_SERVO, SampleRobotCfg.ArmServoPresets.RIGHT, true);

        //define the STOP state to be empty (and never exit) so the state machine will stop
        b.addStop(S.STOP);

        //build and return the StateMachine
        return b.build();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {

    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>The next step in the tutorial is <a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html">Vuforia and OpenCV Beacon Color Detection</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Vuforia and OpenCV are image processing libraries. <a href="https://www.vuforia.com/">Vuforia</a> is by <a href="http://www.ptc.com/">PTC</a> and is built in to the latest version of the FTC app. It has high-level functions for tracking objects and augmented reality. It is very useful for finding the position of the beacon target images.</p>
<p><a href="http://opencv.org/">OpenCV</a> is an open source library that is more low-level, and because of this it is possible to write the procedures yourself and optimize them for better performance.</p>
<p>Before you can use this example, you have to:</p>
<ul>
<li>Set up OpenCV. A guide is available on our website at <del>http://www.gearbox4h.org/opencv/</del> (no longer exists)</li>
<li>Create a Vuforia developer account and get a license key from https://developer.vuforia.com/license-manager</li>
</ul>
<p>This example uses EVLib functionality to:</p>
<ul>
<li>Initialize Vuforia</li>
<li>Find the &quot;Gears&quot; beacon target image (this is controlled by the TeamColor.RED input)</li>
<li>Crop the beacon out of the frame based on the target image location</li>
<li>Find the beacon's color</li>
</ul>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleVuforiaOp.java">sample/v3/SampleVuforiaOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import org.firstinspires.ftc.teamcode.R;

import ftc.electronvolts.statemachine.EndConditions;
import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.BasicResultReceiver;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.ResultReceiver;
import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.Telem;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.opmodes.AbstractAutoOp;
import ftc.evlib.statemachine.EVStates;
import ftc.evlib.vision.framegrabber.VuforiaFrameFeeder;
import ftc.evlib.vision.processors.BeaconColorResult;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 12/15/16
 */
@Autonomous(name = &quot;SampleVuforiaOp V3&quot;)
public class SampleVuforiaOp extends AbstractAutoOp&lt;RobotCfg&gt; {
    //get a key (for free) and paste it below by creating an account at https://developer.vuforia.com/license-manager
    private static final String LICENSE_KEY = &quot;&quot;;

    private static final int FRAME_SIZE = 16;
//    private static final int FRAME_SIZE = 8;
//    private static final int FRAME_SIZE = 64;

    private static final int FRAME_WIDTH = 3 * FRAME_SIZE;
    private static final int FRAME_HEIGHT = 4 * FRAME_SIZE;
//    private static final int FRAME_WIDTH = 11 * FRAME_SIZE;
//    private static final int FRAME_HEIGHT = 9 * FRAME_SIZE;

    private enum S implements StateName {
        WAIT_FOR_VUFORIA_INIT,
        FIND_BEACON_COLOR,
        DISPLAY,
        UNKNOWN_BEACON_COLOR,
        BEACON_COLOR_TIMEOUT
    }

    private ResultReceiver&lt;VuforiaFrameFeeder&gt; vuforiaReceiver;
    private ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult;

    @Override
    public StateMachine buildStates() {
        vuforiaReceiver = VuforiaFrameFeeder.initInNewThread(LICENSE_KEY, R.id.cameraMonitorViewId, FRAME_WIDTH, FRAME_HEIGHT);

        StateMachineBuilder b = new StateMachineBuilder(S.WAIT_FOR_VUFORIA_INIT);
        beaconColorResult = new BasicResultReceiver&lt;&gt;();

        b.addEmpty(S.WAIT_FOR_VUFORIA_INIT, b.ts(EndConditions.receiverReady(vuforiaReceiver), S.FIND_BEACON_COLOR));
        b.add(EVStates.findBeaconColorState(S.FIND_BEACON_COLOR, S.DISPLAY, S.UNKNOWN_BEACON_COLOR, S.BEACON_COLOR_TIMEOUT, Time.fromSeconds(10), vuforiaReceiver, beaconColorResult, TeamColor.RED, 4, true));

        b.add(EVStates.displayBeaconColorResult(S.DISPLAY, beaconColorResult));
        b.add(EVStates.displayBeaconColorResult(S.UNKNOWN_BEACON_COLOR, beaconColorResult));
        b.add(EVStates.displayBeaconColorResult(S.BEACON_COLOR_TIMEOUT, beaconColorResult));

        return b.build();
    }

    @Override
    protected RobotCfg createRobotCfg() {
        return new RobotCfg(hardwareMap) {
            @Override
            public void act() {

            }

            @Override
            public void stop() {

            }
        };
    }

    @Override
    protected Logger createLogger() {
        //it will save logs in /FTC/logs/vuforiaOp[....].csv on the robot controller phone
        return new Logger(&quot;vuforiaOp&quot;, &quot;.csv&quot;, ImmutableList.of(
                //each one of these is a column in the log file
                new Logger.Column(&quot;state&quot;, new InputExtractor&lt;StateName&gt;() {
                    @Override
                    public StateName getValue() {
                        return stateMachine.getCurrentStateName();
                    }
                }),
                new Logger.Column(&quot;beaconColor&quot;, new InputExtractor&lt;BeaconColorResult&gt;() {
                    @Override
                    public BeaconColorResult getValue() {
                        return beaconColorResult.getValue();
                    }
                })
        ));
    }

    @Override
    protected void setup_act() {
        Telem.displayVuforiaReadiness(vuforiaReceiver);
    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {
        telemetry.addData(&quot;state&quot;, stateMachine.getCurrentStateName());
        Telem.displayVuforiaReadiness(vuforiaReceiver);
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>This concludes the tutorial for now. Check back later for more updates and sample code, or go on to
the <a href="evlib/Features.html">Features</a> page for an index of other things you can do with EVLib.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="additional-features"><a class="header" href="#additional-features">Additional Features</a></h2>
<p>EVLib includes the <a href="https://github.com/FTC7393/state-machine-framework/wiki">state-machine-framework</a>, so all the features of the state-machine-framework can be used from EVLib.</p>
<ul>
<li><a href="evlib/Motor-and-MotorEnc.html">the Motor interfaces</a></li>
<li><a href="evlib/Creating-Motors.html">creating motors and continuous servos</a></li>
<li><a href="evlib/NMotors.html">grouping motors</a></li>
<li><a href="evlib/Mecanum-Wheels.html">driving mecanum wheels</a></li>
<li><a href="evlib/Mecanum-Control.html">control of mecanum wheels</a></li>
<li><a href="evlib/Servo-Config.html">servo configuration</a></li>
<li><a href="evlib/Servo-Speed-Control.html">servo speed control</a></li>
<li><a href="evlib/AbstractOp.html">abstract opmodes</a></li>
<li><a href="evlib/AbstractTeleOp.html">abstract teleop</a></li>
<li><a href="evlib/AbstractAutoOp.html">abstract autonomous</a></li>
<li><a href="evlib/AbstractServoTuneOp.html">tuning the servo presets</a></li>
<li><a href="evlib/AbstractOptionsOp.html">selecting options for autonomous</a></li>
<li><a href="evlib/GamepadManager.html">gamepad button edge detection and joystick scaling</a></li>
<li><a href="evlib/EVStates.html">EVStates factory class</a></li>
<li><a href="evlib/EVEndConditions.html">EVEndConditions factory class</a></li>
<li><a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></li>
<li><a href="evlib/Analog-Sensors.html">analog sensors</a></li>
<li><a href="evlib/Digital-Sensors.html">digital sensors</a></li>
<li><a href="evlib/OpenCV-Frame-Grabbing.html">frame grabbing with OpenCV</a></li>
<li><a href="evlib/OpenCV-Image-Processing.html">image processing with OpenCV</a></li>
<li><a href="evlib/CalibratedLineSensor.html">line sensor</a></li>
<li><a href="evlib/DoubleLineSensor.html">double line sensor</a></li>
<li><a href="evlib/ColorSensor.html">color sensor</a></li>
<li><a href="evlib/LineFinder.html">line finder</a></li>
<li><a href="evlib/AveragedSensor.html">averaging analog sensors</a></li>
<li><a href="evlib/Telem.html">global telemetry</a></li>
<li><a href="evlib/StepTimer.html">step timer for logging</a></li>
<li><a href="evlib/FileUtil.html">file utilities</a></li>
<li>[[LineSensorArray]] that uses the i2c <a href="https://www.sparkfun.com/products/13582">SparkFun Line Follower Array</a></li>
<li><a href="evlib/Vuforia-Frame-Grabbing.html">frame grabbing with Vuforia</a></li>
<li><a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html">image processing with Vuforia</a></li>
<li>[[Joystick Recorder]] for &quot;playback&quot; in autonomous</li>
</ul>
<h2 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h2>
<ul>
<li>[[TaskWeb]] to manage executing and moving between multiple tasks on the field</li>
<li>[[Particle Detection]] for autonomous recollection</li>
<li>[[Position Tracker]] to read encoders for position info and return to a set location after driving</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
