<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FTC Programming with ElectronVolts</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="intro/ftc_framework.html"><strong aria-hidden="true">1.2.</strong> The FTC Framework</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Starting Out</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="starter/program/index.html"><strong aria-hidden="true">2.1.</strong> A Starter Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="starter/program/config.html"><strong aria-hidden="true">2.1.1.</strong> Robot Config</a></li><li class="chapter-item expanded "><a href="starter/program/tele_op.html"><strong aria-hidden="true">2.1.2.</strong> TeleOp Program</a></li><li class="chapter-item expanded "><a href="starter/program/install.html"><strong aria-hidden="true">2.1.3.</strong> Compile and Install</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="opmodes/index.html"><strong aria-hidden="true">3.</strong> Operation Modes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="opmodes/base.html"><strong aria-hidden="true">3.1.</strong> Base Operation Mode</a></li><li class="chapter-item expanded "><a href="evlib/AbstractTeleOp.html"><strong aria-hidden="true">3.2.</strong> abstract teleop</a></li><li class="chapter-item expanded "><a href="evlib/AbstractAutoOp.html"><strong aria-hidden="true">3.3.</strong> abstract autonomous</a></li><li class="chapter-item expanded "><a href="evlib/AbstractServoTuneOp.html"><strong aria-hidden="true">3.4.</strong> tuning the servo presets</a></li><li class="chapter-item expanded "><a href="evlib/AbstractOptionsOp.html"><strong aria-hidden="true">3.5.</strong> selecting options for autonomous</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> The State Machine</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/EVStates.html"><strong aria-hidden="true">4.1.</strong> EVStates factory class</a></li><li class="chapter-item expanded "><a href="evlib/EVEndConditions.html"><strong aria-hidden="true">4.2.</strong> EVEndConditions factory class</a></li><li class="chapter-item expanded "><a href="evlib/EVStateMachineBuilder.html"><strong aria-hidden="true">4.3.</strong> EVStateMachineBuilder</a></li><li class="chapter-item expanded "><a href="state_machine_framework/State.html"><strong aria-hidden="true">4.4.</strong> the State interface</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Simple-State-Machine.html"><strong aria-hidden="true">4.5.</strong> Simple State Machine</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Custom-States.html"><strong aria-hidden="true">4.6.</strong> Custom States</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Custom-StateMachineBuilder.html"><strong aria-hidden="true">4.7.</strong> Custom StateMachineBuilder</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Custom-EndConditions.html"><strong aria-hidden="true">4.8.</strong> Custom EndConditions</a></li><li class="chapter-item expanded "><a href="state_machine_framework/BasicAbstractState.html"><strong aria-hidden="true">4.9.</strong> states with built-in end conditions</a></li><li class="chapter-item expanded "><a href="state_machine_framework/EndCondition.html"><strong aria-hidden="true">4.10.</strong> separate end conditions</a></li><li class="chapter-item expanded "><a href="state_machine_framework/StateMap.html"><strong aria-hidden="true">4.11.</strong> linking end conditions with next states</a></li><li class="chapter-item expanded "><a href="state_machine_framework/AbstractState.html"><strong aria-hidden="true">4.12.</strong> states with flexible end conditions</a></li><li class="chapter-item expanded "><a href="state_machine_framework/States.html"><strong aria-hidden="true">4.13.</strong> factory class for states</a></li><li class="chapter-item expanded "><a href="state_machine_framework/EndConditions.html"><strong aria-hidden="true">4.14.</strong> factory class for end conditions</a></li><li class="chapter-item expanded "><a href="state_machine_framework/StateMachineBuilder.html"><strong aria-hidden="true">4.15.</strong> conveniently building a statemachine</a></li><li class="chapter-item expanded "><a href="state_machine_framework/StateMachine.html"><strong aria-hidden="true">4.16.</strong> running the state machine</a></li><li class="chapter-item expanded "><a href="state_machine_framework/DeadZone.html"><strong aria-hidden="true">4.17.</strong> dead-zone interface and factory class</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Hardware</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="state_machine_framework/ControlLoop.html"><strong aria-hidden="true">5.1.</strong> control loop interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state_machine_framework/PIDController.html"><strong aria-hidden="true">5.1.1.</strong> PID controller</a></li><li class="chapter-item expanded "><a href="state_machine_framework/ProportionalController.html"><strong aria-hidden="true">5.1.2.</strong> proportional controller</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Motors and Movement</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Motor-and-MotorEnc.html"><strong aria-hidden="true">5.2.1.</strong> the Motor interfaces</a></li><li class="chapter-item expanded "><a href="evlib/Creating-Motors.html"><strong aria-hidden="true">5.2.2.</strong> creating motors and continuous servos</a></li><li class="chapter-item expanded "><a href="evlib/NMotors.html"><strong aria-hidden="true">5.2.3.</strong> grouping motors</a></li><li class="chapter-item expanded "><a href="evlib/Mecanum-Wheels.html"><strong aria-hidden="true">5.2.4.</strong> [BROKEN] driving mecanum wheels</a></li><li class="chapter-item expanded "><a href="evlib/Mecanum-Control.html"><strong aria-hidden="true">5.2.5.</strong> [BROKEN] control of mecanum wheels</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Sensors</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Analog-Sensors.html"><strong aria-hidden="true">5.3.1.</strong> analog sensors</a></li><li class="chapter-item expanded "><a href="evlib/AveragedSensor.html"><strong aria-hidden="true">5.3.2.</strong> averaging analog sensors</a></li><li class="chapter-item expanded "><a href="evlib/Digital-Sensors.html"><strong aria-hidden="true">5.3.3.</strong> digital sensors</a></li><li class="chapter-item expanded "><a href="evlib/CalibratedLineSensor.html"><strong aria-hidden="true">5.3.4.</strong> line sensor</a></li><li class="chapter-item expanded "><a href="evlib/DoubleLineSensor.html"><strong aria-hidden="true">5.3.5.</strong> double line sensor</a></li><li class="chapter-item expanded "><a href="evlib/ColorSensor.html"><strong aria-hidden="true">5.3.6.</strong> color sensor</a></li><li class="chapter-item expanded "><a href="evlib/LineFinder.html"><strong aria-hidden="true">5.3.7.</strong> line finder</a></li></ol></li><li class="chapter-item expanded "><a href="evlib/GamepadManager.html"><strong aria-hidden="true">5.4.</strong> gamepad button edge detection and joystick scaling</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Utilities</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Math</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="state_machine_framework/Angle.html"><strong aria-hidden="true">6.1.1.</strong> angle unit class</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Distance.html"><strong aria-hidden="true">6.1.2.</strong> distance unit class</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Time.html"><strong aria-hidden="true">6.1.3.</strong> time unit class</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Velocity.html"><strong aria-hidden="true">6.1.4.</strong> velocity unit class</a></li><li class="chapter-item expanded "><a href="state_machine_framework/AngularVelocity.html"><strong aria-hidden="true">6.1.5.</strong> angular velocity unit class</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Vector2D.html"><strong aria-hidden="true">6.1.6.</strong> 2-D Vectors</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Vector3D.html"><strong aria-hidden="true">6.1.7.</strong> 3-D Vectors</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Utility.html"><strong aria-hidden="true">6.1.8.</strong> value limiting functions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Debugging</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Telem.html"><strong aria-hidden="true">6.2.1.</strong> global telemetry</a></li><li class="chapter-item expanded "><a href="evlib/StepTimer.html"><strong aria-hidden="true">6.2.2.</strong> step timer for logging</a></li><li class="chapter-item expanded "><a href="evlib/FileUtil.html"><strong aria-hidden="true">6.2.3.</strong> file utilities</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Logger.html"><strong aria-hidden="true">6.2.4.</strong> file logging</a></li><li class="chapter-item expanded "><a href="state_machine_framework/OptionsFile.html"><strong aria-hidden="true">6.2.5.</strong> storing values in a file</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Primitives</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="state_machine_framework/InputExtractor.html"><strong aria-hidden="true">6.3.1.</strong> InputExtractor</a></li><li class="chapter-item expanded "><a href="state_machine_framework/DigitalInputEdgeDetector.html"><strong aria-hidden="true">6.3.2.</strong> digital edge detection</a></li><li class="chapter-item expanded "><a href="state_machine_framework/AnalogInputScaler.html"><strong aria-hidden="true">6.3.3.</strong> analog scaling</a></li><li class="chapter-item expanded "><a href="state_machine_framework/Functions.html"><strong aria-hidden="true">6.3.4.</strong> function interface and factory class</a></li><li class="chapter-item expanded "><a href="state_machine_framework/ResultReceiver.html"><strong aria-hidden="true">6.3.5.</strong> passing results between threads</a></li><li class="chapter-item expanded "><a href="state_machine_framework/TeamColor.html"><strong aria-hidden="true">6.3.6.</strong> team color</a></li><li class="chapter-item expanded "><a href="state_machine_framework/MatchTimer.html"><strong aria-hidden="true">6.3.7.</strong> timing a match</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state_machine_framework/StateTimer.html"><strong aria-hidden="true">6.3.7.1.</strong> simple timer</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="metaprogramming/options.html"><strong aria-hidden="true">6.4.</strong> Setting Options</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state_machine_framework/Converters.html"><strong aria-hidden="true">6.4.1.</strong> adding more conversions to the OptionsFile</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="evlib/Home.html"><strong aria-hidden="true">7.</strong> Evlib [WIP]</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="evlib/Importing-Into-Your-Project.html"><strong aria-hidden="true">7.1.</strong> Importing Into Your Project</a></li><li class="chapter-item expanded "><a href="evlib/Sample-Code.html"><strong aria-hidden="true">7.2.</strong> Sample Code</a></li><li class="chapter-item expanded "><a href="evlib/Using-EVLib-Minimally.html"><strong aria-hidden="true">7.3.</strong> Using EVLib Minimally</a></li><li class="chapter-item expanded "><a href="evlib/Logging-Example.html"><strong aria-hidden="true">7.4.</strong> Logging Example</a></li><li class="chapter-item expanded "><a href="evlib/Robot-Configuration.html"><strong aria-hidden="true">7.5.</strong> Robot Configuration</a></li><li class="chapter-item expanded "><a href="evlib/Basic-TeleOp-Program.html"><strong aria-hidden="true">7.6.</strong> Basic TeleOp Program</a></li><li class="chapter-item expanded "><a href="evlib/Basic-Autonomous-Program.html"><strong aria-hidden="true">7.7.</strong> Basic Autonomous Program</a></li><li class="chapter-item expanded "><a href="evlib/Customizing-StateMachineBuilder.html"><strong aria-hidden="true">7.8.</strong> Customizing StateMachineBuilder</a></li><li class="chapter-item expanded "><a href="evlib/Servo-Presets.html"><strong aria-hidden="true">7.9.</strong> Servo Presets</a></li><li class="chapter-item expanded "><a href="evlib/Adding-Servos-to-the-Configuration.html"><strong aria-hidden="true">7.10.</strong> Adding Servos to the Configuration</a></li><li class="chapter-item expanded "><a href="evlib/Adding-Servos-to-TeleOp.html"><strong aria-hidden="true">7.11.</strong> Adding Servos to TeleOp</a></li><li class="chapter-item expanded "><a href="evlib/Adding-Servos-to-Autonomous.html"><strong aria-hidden="true">7.12.</strong> Adding Servos to Autonomous</a></li><li class="chapter-item expanded "><a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html"><strong aria-hidden="true">7.13.</strong> Vuforia and OpenCV Beacon Color Detection</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="evlib/Features.html">Evlib Feature Index [WIP]</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">FTC Programming with ElectronVolts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Building working, successful, and long-lasting code is hard. Moving requirements and new features make every year a surgical process, carefully transplanting what code warks and cutting off what doesn't. Fortunately for FTC programmers, libraries are here to provide some stability and a more reasonable starting point.</p>
<p>This tutorial teaches two libraries together: The Qualcomm framework that all FTC teams are <em>required</em> to use, and the ElectronVolts library written by Team 7393, a step above the Qualcomm framework. However, this tutorial leans heavily into the ElectronVolts library. This book is <em>not</em> meant to teach how to do text-based programming, so if you don't know any, you should go study up on Java. Alternatively, if you've already know a curly-brace/c-like language, then it might work out for you to just wing it. This also isn't meant to be a primer on how to use the robot apps; that can be found on the FTC <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki">github wiki</a>. </p>
<h1 id="the-electronvolts-library"><a class="header" href="#the-electronvolts-library">The ElectronVolts Library</a></h1>
<h4 id="what-it-is"><a class="header" href="#what-it-is">What it is:</a></h4>
<ul>
<li>A tool for writing FTC code faster</li>
<li>Classes for reducing boilerplate code</li>
<li>What this book is trying to get you to use</li>
</ul>
<h4 id="what-it-isnt"><a class="header" href="#what-it-isnt">What it isn't:</a></h4>
<ul>
<li>Magic</li>
<li>Required for FTC participation</li>
</ul>
<p>The ElectronVolts library is some code on top of the FTC framework, assisting you with writing code legibly. However, learning <em>yet another</em> framework is a time sink, and if the FTC library suits your purposes, it's what you should stick with. Evlib contains helpful stuff, but it only helps if used correctly. You should weigh the costs and benefits of including this new framework, and weigh these problems:</p>
<ul>
<li>Value fudging</li>
<li>Untraceable logic</li>
<li>Insanity</li>
</ul>
<h2 id="library-structure"><a class="header" href="#library-structure">Library Structure</a></h2>
<p>The library is split up into two parts: <code>electronvolts</code> and <code>evlib</code>. The <code>electronvolts</code> code consists of helper classes which support <code>evlib</code>, is the part of the library you will be using most often.</p>
<p>In the following tutorials, you'll see the <code>LinearOpMode</code>. There are many other items that Qualcomm provides, and can be used along with the ElectronVolts library, but the ElectronVolts library contains its own, preferred Operation Modes, which you will see in the <a href="intro/../starter/program/README.html">A Starter Program</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Note: Whenever *nix is used here, it refers to operating systems which are somehow based off Unix, like Linux, BSD, and such (excluding Apple operating systems).</p>
<h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<h3 id="java"><a class="header" href="#java">Java</a></h3>
<blockquote>
<p>This step can usually be ignored, since almost every computer has java preinstalled.</p>
</blockquote>
<p>To start, you must first have Java installed. Java 8 or 11 should work, and if you can get Java 16, even better. Windows or MacOS users should go to <a href="https://www.oracle.com/java/technologies/downloads/">the Oracle site</a> and follow the installation instructions for your OS. *nix users should follow the distribution-dependent instructions for installing java.</p>
<h3 id="android-studio"><a class="header" href="#android-studio">Android Studio</a></h3>
<p>Android Studio is an &quot;IDE&quot;, or Integrated Development Environment. It serves the same purpose as a text editor, but has &quot;Integrations&quot;, such as code formatting or <a href="https://www.jetbrains.com/help/idea/version-control-integration.html">version control</a>. The most important integration for FTC is donwloading programs onto Android devices.</p>
<p>To install Android Studio for Windows or MacOS computers, go to the <a href="https://developer.android.com/studio/">Android Studio</a> site and follow the installation instructions for your OS. *nix users should follow the distribution-dependent instructions for installing Android Studio.</p>
<p>You should definitely spend some time customizing and familiarizing yourself with Android Studio.</p>
<h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<h3 id="ftc-framework"><a class="header" href="#ftc-framework">FTC Framework</a></h3>
<p>Your project is based off the Qualcomm framework. To begin a new FTC project, copy all of the code from <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">the FTC repository</a> into your own project. You can do this by clicking the &quot;Code&quot; button, then clicking &quot;Download ZIP&quot;, as shown.</p>
<p><img src="intro/./setup_github_download.png" alt="Download from Github" /></p>
<p>It is better, though, to use Version Control to do this. If you are familiar with github and have a github account, you can do this by &quot;forking&quot; the FTC repository and using that instead.</p>
<p>You can then start writing your code in the <code>TeamCode/src/main/java</code> directory.  In Android Studio, you can open this directory by switching from Project to Android view as shown, then navigating to <code>TeamCode/java</code>.</p>
<p><img src="intro/./setup_android_project_view.png" alt="Android project view" /></p>
<h3 id="evlib"><a class="header" href="#evlib">Evlib</a></h3>
<p>The latest version of Evlib is not available in its own repository. You can find a copy of it on the <a href="https://github.com/ftc7393/FtcRobotController">ElectronVolts github page</a>, on the <code>evlib-release</code> branch. Copy all the files in the <code>./Evlib</code> directory to the same location in your project, then update the <code>settings.gradle</code> file like so:</p>
<pre><code class="language-diff">  include ':FtcRobotController'
  include ':TeamCode'
+ include ':Evlib'
</code></pre>
<p>We are currently working on an alternative method to install evlib using the same method as before. Check <a href="intro/../evlib/Importing-Into-Your-Project.html">the original page</a> for updates.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-the-robot-works"><a class="header" href="#how-the-robot-works">How the robot works</a></h2>
<p>This part is review for those who've already done FTC.</p>
<p>The REV robotics core communicates over wifi with a phone, which controls the robot core. The robot core, in turn, can control connected hardware. You can read more on the <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/The-FTC-Control-System">FTC docs page</a>.</p>
<h2 id="ftc-framework-1"><a class="header" href="#ftc-framework-1">FTC Framework</a></h2>
<p>The FTC framework expects your code to be written in a certain way so that it can use it in its own classes. In particular, you need to have a class which is marked as &quot;runnable&quot; (either as autonomous or teleop) and is usable (inherits from the <code>com.qualcomm.robotcore.eventloop.opmode.OpMode</code> class).</p>
<p>For example, a wrong way to write FTC code:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = &quot;FooOp&quot;)
public class FooOp {
    public static void main(String[] args) {
        Servo s = (Servo) hardwareMap.get(&quot;myServo&quot;);
        int i = 0;

        while (true) {
            s.setPosition(i);
            i = (i + 10) % 180;
        }
    }
}
</code></pre>
<p>There are a few things wrong with this.</p>
<ul>
<li>The <code>hardwareMap</code> does not even exist, so you can't control any hardware.</li>
<li>The <code>main</code> method here will not be run at all -- Qualcomm has their own <code>main</code> code, so yours will not be run.</li>
<li>The <code>@Autonomous</code> annotation is wrong -- this class is not an &quot;Operation Mode&quot;, which is what the framework is expecting. This will probably result in some strange runtime error (TODO: Add a picture of that runtime error).</li>
</ul>
<p>Here is a correct implementation:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.Servo;

@Autonomous(name = &quot;FooOp&quot;)
public class FooOp extends LinearOpMode {
    @Override
    public void runOpMode() {
        Servo s = (Servo) hardwareMap.get(&quot;myServo&quot;);
        int i = 0;

        waitForStart();

        while (true) {
            s.setPosition(i);
            i = (i + 10) % 180;
        }
    }
}
</code></pre>
<p>All the mentioned problems in the previous code have been corrected here:</p>
<ul>
<li>The <code>hardwareMap</code> now exists: It exists in the superclasses of <code>FooOp</code>.</li>
<li>The <code>@Autonomous</code> annotation now makes sense: It is annotating a class which is a Linear Operation Mode. The Qualcomm framework can now correctly detect and run it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-starter-program"><a class="header" href="#a-starter-program">A Starter Program</a></h1>
<p>To start an ElectronVolts <code>TeleOp</code> project, make a new copy of the Qualcomm framework and add this into your TeamCode directory:</p>
<pre><code> java
 ├── MyRobotCfg.java
 └── MyTeleOp.java
</code></pre>
<p>Then add the ElectronVolts library into the directory like so:</p>
<pre><code> java
 ├── MyRobotCfg.java
 ├── MyTeleOp.java
 └── ftc
     ├── electronvolts
     │   └┄┄
     ├── evlib
     ┆   └┄┄
</code></pre>
<p>Once you've set up those files, you can start writing FTC code.</p>
<p>The end product should look something like below. This is just for later reference (i.e. when your code stops working); keep reading for the rest of the walkthrough.</p>
<pre><code class="language-java">MyRobotCfg.java

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}

MyTeleOp.java

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {
    DcMotor myMotor;

    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {
        myMotor = robotCfg.getMyMotor();
    }

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {
        double power = gamepad1.left_trigger - gamepad1.right_trigger;
        myMotor.setPower(power);
    }

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-config"><a class="header" href="#robot-config">Robot Config</a></h1>
<p>In order to access hardware, the Qualcomm framework provides an object called the <code>hardwareMap</code>, which is something like a TypeMap, except each type also has its own map between <code>String</code> and the hardware you want.</p>
<p>ElectronVolts takes this a step further by making the abstract class <code>RobotCfg</code>, which can be used to preload all of the names out of the <code>hardwareMap</code> and let you get it directly.</p>
<p><img src="starter/program/./config_hardware.png" alt="Hardware presented by default" /></p>
<p>(a side note: I call it hardware here, but it's really a reference to the hardware. As in, an object which you can use to control the hardware.)</p>
<p>Importantly, Robot Configs <em>decouple the hardware team from the software team</em>. When the hardware team connects a device to the Robot's brain, that change needs to be reflected in the code. If the hardware specification and the software logic are in the same place, it makes it hard for both teams to read and write. With the Robot Config, the hardware team can declare in one place what hardware they are using in their robot, and the software team only has to read from one place to figure out what hardware is being used.</p>
<p>This also means that this section is great for <em>both hardware and software team</em> to understand.</p>
<p><strong>The library is still not magic</strong>.</p>
<p>If you write code that isn't readable, then putting it all in one place won't necessarily make it better.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Start with a Robot Config like so:</p>
<pre><code class="language-java">MyRobotCfg.java

import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}

</code></pre>
<p>Right now, this config represents an empty bot. It has one brain, one phone, and that's it. This is already pretty powerful – without any custom logic, you have direct access to all the phone's sensors. This is sufficient for an abstract example, but what if we want to add motors to a bot?</p>
<p>Let's start by adding a simple DC motor to a bot, which on the robot core has been <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/Configuring-Your-Hardware">programmed</a> to be called &quot;bruh&quot;:</p>
<pre><code class="language-java">public class MyRobotCfg extends RobotCfg {
    public final DcMotor myMotor;

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }
}
</code></pre>
<p>Some code is not shown for conciseness.</p>
<p>This also works with the getter pattern, like so:</p>
<pre><code class="language-java">public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }
}
</code></pre>
<p>Now, when the software team needs the motor, and has a <code>MyRobotCfg</code>, they can call <code>myRobotCfg.getMyMotor()</code> to receive and move the motor.</p>
<p>The complete code should look like this:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.HardwareMap;
import ftc.evlib.hardware.config.RobotCfg;

public class MyRobotCfg extends RobotCfg {
    private final DcMotor myMotor;

    public DcMotor getMyMotor() {
        return myMotor;
    }

    public MyRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);
        myMotor = hardwareMap.get(DcMotorEx.class, &quot;bruh&quot;);
    }

    @Override
    public void start() {}

    @Override
    public void act() {}

    @Override
    public void stop() {}
}
</code></pre>
<p>This is all the code you need to move to the next step. If there are some other types of hardware you'd like to add, find them in the <a href="https://javadoc.io/doc/org.firstinspires.ftc">FTC javadoc</a>, or see some more types we've made in the <a href="starter/program/../../hardware/index.html">Hardware section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teleop-program"><a class="header" href="#teleop-program">TeleOp Program</a></h1>
<p>A TeleOp is Tele-Operation: A period of time when <em>you</em>, the human, control the robot. A TeleOp therefore needs take input from a source (in 2021, an xbox controller), and somehow transform it into actions done by the robot. That's the part you make.</p>
<p>Let's get right into it, with the following starter code:</p>
<pre><code class="language-java">MyTeleOp.java

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {
    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg();
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {}

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {}

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<p>This is a <em>lot</em> of methods, and we'll break it down more in the chapter 3. For now, we'll set the goal of moving the motor counterclockwise with the left trigger of the controller, and clockwise with the right trigger.</p>
<p>To start, we need to figure out how much the motor should move. To do this, we'll need to transform the input from the controller into an output for the motor to be able to use.</p>
<pre><code class="language-java">protected void act() {
    double power = gamepad1.left_trigger - gamepad1.right_trigger;
}
</code></pre>
<p>You can see that <code>gamepad1.left_trigger</code> is not a reference to hardware, but a value. This is another one of the ElectronVolts library's simplifications: Managing the input values. Next, we want to send this computed value to the DC motor.</p>
<pre><code class="language-java">protected void act() {
    double power = gamepad1.left_trigger - gamepad1.right_trigger;
    robotCfg.getMyMotor().setPower(power);
}
</code></pre>
<p>This is relatively straightforward. Now, after the program is initialized and the play button is pressed, the <code>act</code> function will run in a loop, so you don't have to worry about the power only being set once.</p>
<p>The completed code should look like this:</p>
<pre><code class="language-java">import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

@TeleOp(name = &quot;My TeleOp&quot;)
public class MyTeleOp extends AbstractTeleOp&lt;MyRobotCfg&gt; {

    DcMotor myMotor;

    @Override
    protected MyRobotCfg createRobotCfg() {
        return new MyRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {}

    @Override
    protected void setup_act() {}

    @Override
    protected void go() {}

    @Override
    protected void act() {
        double power = gamepad1.left_trigger - gamepad1.right_trigger;
        robotCfg.getMyMotor().setPower(power);
    }

    @Override
    protected void end() {}

    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.linear(1.0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-and-install"><a class="header" href="#compile-and-install">Compile and Install</a></h1>
<p><img src="starter/program/./install_buttons.png" alt="Android Studio buttons" /></p>
<p>When using Android Studio normally, the box highlighted here will look like this. The hammer icon on the left is the &quot;build&quot; button - it compiles the code you've written using a tool called Gradle. The play button on the right triggers a &quot;deploy&quot; - it compiles your code, but also copies the compiled code into the robot, if it's connected by USB.</p>
<p>To download your code, you must either have a USB or WiFi connection to the Control Hub.
If you use a WiFi connection, it is recommended to use an external wifi card or adapter to be able to connect to
both the internet and robot at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation-modes"><a class="header" href="#operation-modes">Operation Modes</a></h1>
<p>Operation Modes are the entry point for your code. Each of them contain &quot;runtime stages&quot;, which are called at a certain point during the OpMode's lifetime.</p>
<p>For example, as soon as you press the init button on the driver station, the <code>setup</code> method (which is in almost all of our opmodes) is run. If you want to run code during an opmode, you should do it in one of those stages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-operation-mode"><a class="header" href="#base-operation-mode">Base Operation Mode</a></h1>
<p>The class <code>ftc.evlib.opmodes.AbstractOp</code> represents the most basic conventional OpMode. It allows you to make an opmode that is linked to a <a href="opmodes/Robot-Configuration.html">Robot Configuration</a>. This class can be used directly by extending it, but it is recommended that you extend <a href="opmodes/AbstractTeleOp.html">AbstractTeleOp</a> or <a href="opmodes/AbstractAutoOp.html">AbstractAutoOp</a> instead to take advantage of their features as well as these.</p>
<p><code>AbstractOp</code> takes care of the following:</p>
<ul>
<li>Timing the match</li>
<li>Logging values to a file</li>
<li>Updating the servos</li>
<li>Giving global access to the telemetry</li>
<li>Storing the robotCfg</li>
</ul>
<h3 id="runtime-stages"><a class="header" href="#runtime-stages">Runtime stages</a></h3>
<p>In order to use the <code>AbstractOp</code>, you must extend and implement the following methods, representing stages that the robot goes through during its operation. The OpMode moves through seven runtime stages, three of which are utility stages. Here they are in order:</p>
<ol>
<li>
<p><code>setup</code>: This method is run once when the init button is pressed.</p>
</li>
<li>
<p><code>setup_act</code>: After <code>setup</code> has run, this method is run in a loop, which exits when the play button is pressed. This method is guaranteed to not stop before it completes.</p>
</li>
<li>
<p><code>go</code>: This method is run once at the time when the play button is pressed.</p>
</li>
<li>
<p><code>pre_act</code>: This method is always run before every time <code>act</code> runs.</p>
</li>
<li>
<p><code>act</code>: After <code>go</code> has run, this method is run in a loop until the OpMode is stopped by the Driver Station or by the game time.</p>
</li>
<li>
<p><code>post_act</code>: This method is always run after every time <code>act</code> runs.</p>
</li>
<li>
<p><code>end</code>: This method is run once after the OpMode is stopped by the Driver Station or by the game timer.</p>
</li>
</ol>
<p>You usually don't deal with all of these directly, since some such as <code>pre_act</code> and <code>post_act</code> are used for supporting more specific OpModes. Others, such as <code>setup</code> and <code>act</code>, are usually meant for you to implement.</p>
<p>You can find the definition of this class at <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractOp.java">ftc/evlib/opmodes/AbstractOp.java</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>AbstractTeleOp extends <a href="evlib/../opmodes/base.html">AbstractOp</a> and adds code to handle the gamepads. You can use this to make a TeleOp by extending this class. <a href="evlib/Basic-TeleOp-Program.html">Here</a> is and example. Inside your class you have access to driver1 and driver2, which are instances of the <a href="evlib/GamepadManager.html">GamepadManager</a> class. They add edge detection and scaling to the gamepads. See also: <a href="evlib/AbstractAutoOp.html">AbstractAutoOp</a></p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractTeleOp.java">ftc/evlib/opmodes/AbstractTeleOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.GamepadManager;
import ftc.evlib.hardware.config.RobotCfg;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * extends AbstractOp and adds gamepad edge detection and scaling, and a 2 minute timer
 *
 * @see AbstractOp
 * @see GamepadManager
 */
public abstract class AbstractTeleOp&lt;Type extends RobotCfg&gt; extends AbstractOp&lt;Type&gt; {
    public GamepadManager driver1;
    public GamepadManager driver2;

    /**
     * This is implemented by the teleop opmode
     *
     * @return a Function to scale the joysticks by
     */
    protected abstract Function getJoystickScalingFunction();

    @Override
    public Time getMatchTime() {
        return Time.fromMinutes(2); //teleop is 2 minutes
    }

    @Override
    public void start() {
        //set the joystick deadzone
//        gamepad1.setJoystickDeadzone(.1F);
//        gamepad2.setJoystickDeadzone(.1F);

        //get the scaling function
        Function f = getJoystickScalingFunction();
        if (f == null) {
            //if it is null set it to none
            f = Functions.none();
        }

        //apply the function to the gamepads and store them
        driver1 = new GamepadManager(gamepad1, f);
        driver2 = new GamepadManager(gamepad2, f);
        super.start();
    }

    @Override
    public void pre_act() {
        //update the joystick values
        driver1.update();
        driver2.update();
    }

    @Override
    public void post_act() {

    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>AbstractAutoOp extends <a href="evlib/../opmodes/base.html">AbstractOp</a> and adds code to run a state machine. You can create an autonomous by extending this class and creating the StateMachine in the buildStates() method. <a href="evlib/Basic-Autonomous-Program.html">Here</a> is an example. See also: <a href="evlib/AbstractTeleOp.html">AbstractTeleOp</a></p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractAutoOp.java">ftc/evlib/opmodes/AbstractAutoOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.hardware.config.RobotCfg;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/13/16
 *
 * extends AbstractOp and adds a 30 second timer and a state machine
 *
 * @see AbstractOp
 * @see StateMachine
 */
public abstract class AbstractAutoOp&lt;Type extends RobotCfg&gt; extends AbstractOp&lt;Type&gt; {
    protected StateMachine stateMachine;

    /**
     * This is implemented by the autonomous opmode
     * It is called where the setup would have been
     *
     * @return A state machine to be run
     */
    public abstract StateMachine buildStates();

    @Override
    public Time getMatchTime() {
        return Time.fromSeconds(30); //autonomous is 30 seconds
    }

    @Override
    public void setup() {
        stateMachine = buildStates(); //get the state machine from the opmode
    }

    @Override
    public void pre_act() {

    }

    @Override
    public void post_act() {
        stateMachine.act(); //update the state machine
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Go to <a href="evlib/Servo-Presets.html">Servo Presets</a> to see how to extend this class to tune the servos.</p>
<p>Here is AbstractServoTuneOp, which can be extended to tune servos for any <a href="evlib/Robot-Configuration.html">Robot Configuration</a>.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractServoTuneOp.java">ftc/evlib/opmodes/AbstractServoTuneOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import java.util.ArrayList;
import java.util.List;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.Utility;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.files.OptionsFile;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.servos.ServoCfg;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.util.EVConverters;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/30/16
 *
 * extends AbstractTeleOp and adds tuning of servo presets with the joysticks.
 *
 * Subclasses of this are very simple since this does most of the work.
 *
 * It allows you to change your servo presets without changing the code and re-deploying it to the
 * phone. This means that you can swap out a servo and re-tune it without having to go into the
 * program and fix magic numbers. Note:  It only works if you use presets everywhere instead of
 * hardcoded values.
 *
 * How to use for your robot:
 * Create a subclass of this (AbstractServoTuneOp).
 * return a new instance of your RobotCfg (it has the servos) in createRobotCfg().
 *
 * Subclass example:
 *
 * &lt;code&gt;
 *
 * \@TeleOp(name = &quot;MyRobot ServoTuneOp&quot;)
 * public class MyRobotServoTuneOp extends AbstractServoTuneOp {
 * \@Override protected RobotCfg createRobotCfg() {
 * return new MyRobotCfg(hardwareMap);
 * }
 * }
 * &lt;/code&gt;
 *
 * How to operate:
 * Use the dpad up and down to cycle through all the servos
 * Use the dpad left and right to move through the presets for that servo.
 * Use the left and right joystick y values to change the servo position.
 * Press start to save the current preset of the current servo to the current value.
 *
 * The presets are saved in files that are retrieved when you run other opmodes to find the value of each preset.
 *
 * @see ServoControl
 * @see ServoCfg
 */
public abstract class AbstractServoTuneOp extends AbstractTeleOp&lt;RobotCfg&gt; {
    /**
     * The index of the servo in the list
     */
    private int servoIndex = 0;

    /**
     * The index of the preset for the current servo
     */
    private int presetIndex = 0;

    /**
     * records whether or not a new servo has been selected
     */
    private boolean servoIndexChanged = true;

    /**
     * records whether or not a new servo preset has been selected
     */
    private boolean servoPresetIndexChanged = true;

    /**
     * The list of current positions for each servo
     */
    private final List&lt;Double&gt; servoPositions = new ArrayList&lt;&gt;();

    /**
     * The list of servo names
     */
    private List&lt;ServoName&gt; servoNames;

    /**
     * The list of preset names for the current servo
     */
    private List&lt;Enum&gt; presetNames;

    /**
     * The list of preset values for the current servo
     */
    private List&lt;Double&gt; presetValues;

    /**
     * The current servo
     */
    private ServoControl servo;

    /**
     * @return no joystick scaling
     */
    @Override
    protected Function getJoystickScalingFunction() {
        return Functions.none();
    }

    /**
     * @return no match timer
     */
    @Override
    public Time getMatchTime() {
        return null;
    }

    /**
     * @return no logging
     */
    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {
        //get a list of servo names from the RobotCfg
        servoNames = robotCfg.getServos().getServoNames();

        //add servo positions to be the same length as servoNames
        for (ServoName ignored : servoNames) {
            servoPositions.add(0.5);
        }
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {


        //if dpad up is pressed
        if (driver1.dpad_up.justPressed() || driver2.dpad_up.justPressed()) {
            servoIndex += 1; //move to the next servo
            //wrap around if the index is too large
            if (servoIndex &gt; servoNames.size() - 1) servoIndex = 0;
            servoIndexChanged = true; //signal that the index changed
        }

        //if dpad down is pressed
        if (driver1.dpad_down.justPressed() || driver2.dpad_down.justPressed()) {
            servoIndex -= 1; //move to the previous servo
            //wrap around if the index is too small
            if (servoIndex &lt; 0) servoIndex = servoNames.size() - 1;
            servoIndexChanged = true; //signal that the index changed
        }

        //if a different servo was selected
        if (servoIndexChanged) {
            servoIndexChanged = false;

            servo = robotCfg.getServo(servoNames.get(servoIndex));//get the servo
            presetNames = new ArrayList&lt;&gt;(servo.getPresets().keySet()); //get the preset names from the servo
            presetValues = new ArrayList&lt;&gt;(servo.getPresets().values()); //get the presets from the servo

            presetIndex = 0; //start at the first preset for the new servo
            servoPresetIndexChanged = true; //signal to reload the servo preset
        }

        //get the servo position
        double servoPosition = servoPositions.get(servoIndex);

        //if the dpad left was just pressed
        if (driver1.dpad_left.justPressed() || driver2.dpad_left.justPressed()) {
            presetIndex -= 1; //select the previous servo preset
            //wrap around if the index is too small
            if (presetIndex &lt; 0) presetIndex = presetValues.size() - 1;
            servoPresetIndexChanged = true; //signal that the index changed
        }

        //if the dpad right was just pressed
        if (driver1.dpad_right.justPressed() || driver2.dpad_right.justPressed()) {
            presetIndex += 1; //select the next servo preset
            //wrap around if the index is too large
            if (presetIndex &gt; presetValues.size() - 1) presetIndex = 0;
            servoPresetIndexChanged = true; //signal that the index changed
        }

        //is the servo preset index changed
        if (servoPresetIndexChanged) {
            servoPresetIndexChanged = false;
            servoPosition = presetValues.get(presetIndex); //set the servo to the preset position
        }

        telemetry.addData(&quot;Press start to set the current preset to the current value&quot;, &quot;&quot;);
        //if start is pressed, save the current preset to a file
        if (driver1.start.justPressed() || driver2.start.justPressed()) {
            //set the current selected preset to the current servo position
            servo.getPresets().put(presetNames.get(presetIndex), servoPosition);
            presetValues.set(presetIndex, servoPosition);

            OptionsFile optionsFile = new OptionsFile(EVConverters.getInstance()); //create an OptionsFile

            //put the preset names and presets into the OptionsFile
            for (int i = 0; i &lt; presetNames.size(); i++) {
                optionsFile.set(presetNames.get(i).name(), presetValues.get(i).toString());
            }

            optionsFile.writeToFile(ServoCfg.getServoFile(servoNames.get(servoIndex))); //store the OptionsFile to a file
        }

        //modify the servo position using the joysticks
        servoPosition += 2e-4 * matchTimer.getDeltaTime() * (driver1.left_stick_y.getValue() + 0.1 * driver1.right_stick_y.getValue() + driver2.left_stick_y.getValue() + 0.1 * driver2.right_stick_y.getValue());

        //limit the position
        servoPosition = Utility.servoLimit(servoPosition);

        //set the servo to the position
        servo.setPosition(servoPosition);

        //store the position
        servoPositions.set(servoIndex, servoPosition);

        //display telemetry about the servo
        telemetry.addData(&quot;Servo Name&quot;, servoNames.get(servoIndex));
        telemetry.addData(&quot;Servo Preset Name&quot;, presetNames.get(presetIndex));
        telemetry.addData(&quot;Servo Preset Value&quot;, servoPosition);
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date. You can find a new guide to options <a href="evlib/../metaprogramming/options.html">here</a></p>
</blockquote>
<p>AbstractOptionsOp extends <a href="evlib/../opmodes/base.html">AbstractOp</a>. You can use it to take input from the gamepad and store settings for autonomous in a file on the robot phone. It uses <a href="https://github.com/FTC7393/state-machine-framework/wiki/OptionsFile">OptionsFile</a> from the state-machine-framework.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/opmodes/AbstractOptionsOp.java">ftc/evlib/opmodes/AbstractOptionsOp.java</a></p>
<pre><code class="language-java">package ftc.evlib.opmodes;

import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.files.OptionsFile;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.util.EVConverters;
import ftc.evlib.util.FileUtil;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/29/16
 *
 * extends AbstractTeleOp and adds saving and loading an OptionsFile and removes the match timer
 *
 * @see AbstractTeleOp
 * @see OptionsFile
 */
public abstract class AbstractOptionsOp extends AbstractTeleOp&lt;RobotCfg&gt; {
    private final String filename;
    public OptionsFile optionsFile;

    /**
     * The filename will be set by the subclasses
     *
     * @param filename the name of the file where the options are stored
     */
    public AbstractOptionsOp(String filename) {
        this.filename = filename;
    }

    /**
     * @return a dummy RobotCfg
     */
    @Override
    protected RobotCfg createRobotCfg() {
        return new RobotCfg(hardwareMap) {
            @Override
            public void act() {

            }

            @Override
            public void stop() {

            }
        };
    }

    @Override
    protected Logger createLogger() {
        //the OptionsOp has no logging
        return null;
    }

    @Override
    public Time getMatchTime() {
        //the OptionsOp has no time limit
        return null;
    }

    /**
     * Load the options from the file
     */
    public void loadOptionsFile() {
        optionsFile = new OptionsFile(EVConverters.getInstance(), FileUtil.getOptionsFile(filename));
    }

    /**
     * save the options from the file
     */
    public void saveOptionsFile() {
        optionsFile.writeToFile(FileUtil.getOptionsFile(filename));
    }

    @Override
    protected void setup() {
        //load the file when the opmode starts
        loadOptionsFile();
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    public void post_act() {
        super.post_act();

        //display telemetry instructions
        telemetry.addData(&quot;* back button =&gt; erase changes&quot;, &quot;&quot;);
        //reload the file if the back button is pressed
        if (driver1.back.justPressed()) loadOptionsFile();

        //display telemetry instructions
        telemetry.addData(&quot;* start button =&gt; save&quot;, &quot;&quot;);
        //save the file if the start button is pressed
        if (driver1.start.justPressed()) saveOptionsFile();

        telemetry.addData(&quot;* Stop the opmode to save and quit.&quot;, &quot;&quot;);
    }

    @Override
    protected void end() {
        //save the file when the opmode ends
        saveOptionsFile();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>EVStates</strong> | <a href="evlib/EVEndConditions.html">EVEndConditions</a> | <a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></p>
<hr />
<p>EVStates is a factory class that extends States from the state-machine-framework. It inherits all the factory methods from States, and adds its own that relate to FTC.</p>
<p>Some that we use frequently are:</p>
<ul>
<li><strong>mecanumDrive</strong> -- drives with the mecanum wheels and stabilizes with the gyro</li>
<li><strong>servoTurn</strong> -- turns a servo to a <a href="evlib/Servo-Presets.html">preset</a> at a given <a href="evlib/Servo-Speed-Control.html">speed</a></li>
<li><strong>calibrateGyro</strong> -- waits for the gyro sensor to finish calibrating</li>
</ul>
<p>Some others that are also useful are:</p>
<ul>
<li><strong>drive</strong> -- drives with a <a href="evlib/TwoMotors.html">TwoMotors</a> object</li>
<li><strong>turn</strong> -- tuns with a TwoMotors object</li>
<li><strong>oneWheelTurn</strong> -- powers one wheel to turn</li>
<li><strong>motorTurn</strong> -- turns a motor</li>
</ul>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/statemachine/EVStates.java">ftc/evlib/statemachine/EVStates.java</a></p>
<pre><code class="language-java">package ftc.evlib.statemachine;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.hardware.GyroSensor;

import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;

import java.util.List;

import ftc.electronvolts.statemachine.AbstractState;
import ftc.electronvolts.statemachine.BasicAbstractState;
import ftc.electronvolts.statemachine.EndCondition;
import ftc.electronvolts.statemachine.EndConditions;
import ftc.electronvolts.statemachine.State;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.statemachine.States;
import ftc.electronvolts.statemachine.Transition;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.ResultReceiver;
import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.Telem;
import ftc.evlib.hardware.control.LineUpControl;
import ftc.evlib.hardware.control.MecanumControl;
import ftc.evlib.hardware.control.RotationControl;
import ftc.evlib.hardware.control.RotationControls;
import ftc.evlib.hardware.control.TranslationControl;
import ftc.evlib.hardware.control.TranslationControls;
import ftc.evlib.hardware.mechanisms.Shooter;
import ftc.evlib.hardware.motors.MecanumMotors;
import ftc.evlib.hardware.motors.Motor;
import ftc.evlib.hardware.motors.NMotors;
import ftc.evlib.hardware.motors.TwoMotors;
import ftc.evlib.hardware.sensors.DigitalSensor;
import ftc.evlib.hardware.sensors.DistanceSensor;
import ftc.evlib.hardware.sensors.DoubleLineSensor;
import ftc.evlib.hardware.sensors.LineSensorArray;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.Servos;
import ftc.evlib.vision.framegrabber.FrameGrabber;
import ftc.evlib.vision.framegrabber.VuforiaFrameFeeder;
import ftc.evlib.vision.processors.BeaconColorResult;
import ftc.evlib.vision.processors.BeaconName;
import ftc.evlib.vision.processors.CloseUpColorProcessor;
import ftc.evlib.vision.processors.ImageProcessor;
import ftc.evlib.vision.processors.ImageProcessorResult;
import ftc.evlib.vision.processors.Location;
import ftc.evlib.vision.processors.RGBBeaconProcessor;
import ftc.evlib.vision.processors.VuforiaBeaconColorProcessor;

import static ftc.evlib.driverstation.Telem.telemetry;
import static ftc.evlib.vision.framegrabber.GlobalFrameGrabber.frameGrabber;
import static ftc.evlib.vision.framegrabber.VuforiaFrameFeeder.beacons;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 5/10/16
 *
 * @see State
 * @see EVStateMachineBuilder
 */
public class EVStates extends States {

    /**
     * Displays the left and right color of a BeaconColorResult
     *
     * @param stateName the name of the state
     * @param receiver  the ResultReceiver to get the color from
     * @return the created State
     * @see BeaconColorResult
     */
    public static State displayBeaconColorResult(StateName stateName, final ResultReceiver&lt;BeaconColorResult&gt; receiver) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                Telem.displayBeaconColorResult(receiver);
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * Displays the color of a BeaconColorResult.BeaconColor
     *
     * @param stateName the name of the state
     * @param receiver  the ResultReceiver to get the color from
     * @return the created State
     * @see BeaconColorResult
     */
    public static State displayBeaconColor(StateName stateName, final ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; receiver) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                Telem.displayBeaconColor(receiver);
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * Uses vuforia to find the beacon target image, then uses opencv to determine the beacon color
     *
     * @param stateName         the name of the state
     * @param successState      the state to go to if it succeeds
     * @param failState         the state to go to if it fails
     * @param timeoutState      the state to go to if it times out
     * @param timeoutTime       the time before it will time out
     * @param vuforiaReceiver   the ResultReceiver to get the VuforiaFramFeeder object from
     * @param beaconColorResult the ResultReceiver to store the result in
     * @param teamColor         your team's color to decide which beacons to look for
     * @param numFrames         the number of frames to process
     * @param saveImages        whether or not to save the frames for logging
     * @return the created State
     * @see VuforiaFrameFeeder
     * @see VuforiaBeaconColorProcessor
     */
    //TODO assume that vuforia is initialized in findBeaconColorState
    public static State findBeaconColorState(StateName stateName, final StateName successState, final StateName failState, final StateName timeoutState, Time timeoutTime, final ResultReceiver&lt;VuforiaFrameFeeder&gt; vuforiaReceiver, final ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult, TeamColor teamColor, final int numFrames, final boolean saveImages) {
        final List&lt;BeaconName&gt; beaconNames = BeaconName.getNamesForTeamColor(teamColor);
        final EndCondition timeout = EndConditions.timed(timeoutTime);

        return new BasicAbstractState(stateName) {
            private VuforiaFrameFeeder vuforia = null;
            private VuforiaBeaconColorProcessor processor = null;
            private BeaconName beaconName;
            private int beaconIndex = 0; //index of the beaconNames list
            private boolean timedOut = false;

            @Override
            public void init() {
                timeout.init();
                timedOut = false;

                if (beaconIndex &gt;= beaconNames.size()) {
                    beaconIndex = 0;
                    //we should never go here
                }
                beaconName = beaconNames.get(beaconIndex);
                if (processor != null) {
                    processor.setBeaconName(beaconName);
                }
            }

            @Override
            public boolean isDone() {
                if (vuforia == null &amp;&amp; vuforiaReceiver.isReady()) {
                    vuforia = vuforiaReceiver.getValue();
//                    if (vuforia == null) {
//                        Log.e(&quot;EVStates&quot;, &quot;vuforia is null!!!!!!!!!!!!!&quot;);
//                    }

                    processor = new VuforiaBeaconColorProcessor(vuforia);
                    processor.setBeaconName(beaconName);

                    VuforiaTrackable beacon = beacons.get(beaconName);
                    beacon.getTrackables().activate();

                    frameGrabber.setImageProcessor(processor);
                    frameGrabber.setSaveImages(saveImages);
                    frameGrabber.grabContinuousFrames();
                }
                timedOut = timeout.isDone();
                return timedOut || processor != null &amp;&amp; processor.getResultsFound() &gt;= numFrames;
            }

            @Override
            public StateName getNextStateName() {
                beaconIndex++;
                frameGrabber.stopFrameGrabber();
                VuforiaTrackable beacon = beacons.get(beaconName);
                beacon.getTrackables().deactivate();

                BeaconColorResult result = processor.getAverageResult();
                processor.reset();
                BeaconColorResult.BeaconColor leftColor = result.getLeftColor();
                BeaconColorResult.BeaconColor rightColor = result.getRightColor();
                if ((leftColor == BeaconColorResult.BeaconColor.RED &amp;&amp; rightColor == BeaconColorResult.BeaconColor.BLUE)
                        || (leftColor == BeaconColorResult.BeaconColor.BLUE &amp;&amp; rightColor == BeaconColorResult.BeaconColor.RED)) {
                    beaconColorResult.setValue(result);
                    return successState;
                } else {
                    beaconColorResult.setValue(new BeaconColorResult());
                    if (timedOut) {
                        return timeoutState;
                    } else {
                        return failState;
                    }
                }
            }
        };
    }

    public static State findColorState(StateName stateName, final StateName successState, final StateName unknownState, final ResultReceiver&lt;VuforiaFrameFeeder&gt; vuforiaReceiver, final ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; colorResult, final boolean saveImages) {
        return new BasicAbstractState(stateName) {
            private VuforiaFrameFeeder vuforia = null;
            private CloseUpColorProcessor processor = null;
            private boolean timedOut = false;

            @Override
            public void init() {
                vuforia = vuforiaReceiver.getValue();
                processor = new CloseUpColorProcessor();

                frameGrabber.setImageProcessor(processor);
                frameGrabber.setSaveImages(saveImages);
                frameGrabber.grabSingleFrame();
            }

            @Override
            public boolean isDone() {
                return frameGrabber.isResultReady();
            }

            @Override
            public StateName getNextStateName() {
                BeaconColorResult.BeaconColor result = (BeaconColorResult.BeaconColor) frameGrabber.getResult().getResult();
                colorResult.setValue(result);
                if (result == BeaconColorResult.BeaconColor.RED || result == BeaconColorResult.BeaconColor.BLUE) {
                    return successState;
                } else {
                    return unknownState;
                }
            }
        };
    }

    public static State beaconColorSwitch(StateName stateName, final StateName redState, final StateName blueState, final StateName unknownState, ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; colorResult) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                BeaconColorResult.BeaconColor result = (BeaconColorResult.BeaconColor) frameGrabber.getResult().getResult();
                switch (result) {
                    case RED:
                        return redState;
                    case BLUE:
                        return blueState;
                    default:
                        return unknownState;
                }
            }
        };
    }

    /**
     * use the camera to detect and drive up to the beacon
     *
     * @param stateName       the name of the state
     * @param doneState       the state to go to if it works
     * @param lostObjectState the state to go to if it cannot find the beacon
     * @param timeoutState    the state to go to if it times out
     * @param timeoutMillis   the number of milliseconds before the timeout
     * @param mecanumControl  the mecanum wheels
     * @param frameGrabber    access to the camera frames
     * @return the created State
     */
    public static State mecanumCameraTrack(StateName stateName, final StateName doneState, final StateName lostObjectState, final StateName timeoutState, long timeoutMillis, final MecanumControl mecanumControl, final FrameGrabber frameGrabber, ImageProcessor&lt;? extends Location&gt; imageProcessor) {
        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);
        final TranslationControl beaconTrackingControl = TranslationControls.cameraTracking(frameGrabber, imageProcessor);
        final long timeoutTime = System.currentTimeMillis() + timeoutMillis;

        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                mecanumControl.setTranslationControl(beaconTrackingControl);
            }

            @Override
            public boolean isDone() {
                return !mecanumControl.translationWorked() || beaconTrackingControl.getTranslation().getLength() &lt; 0.1 || System.currentTimeMillis() &gt;= timeoutTime;
            }

            @Override
            public StateName getNextStateName() {
                mecanumControl.stop();

                if (beaconTrackingControl.getTranslation().getLength() &lt; 0.1) {
                    return doneState;
                } else {
                    if (!mecanumControl.translationWorked()) {
                        return lostObjectState;
                    } else {
                        return timeoutState;
                    }
                }
            }
        };
    }

    /**
     * @param stateName      the name of the state
     * @param nextStateName  the name of the next state
     * @param imageProcessor the object that processes the image
     * @param resultReceiver the object that stores the image
     * @return the created State
     */
    public static State processFrame(StateName stateName, final StateName nextStateName, final ImageProcessor imageProcessor, final ResultReceiver&lt;ImageProcessorResult&gt; resultReceiver) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                frameGrabber.setImageProcessor(imageProcessor);
                frameGrabber.grabSingleFrame();
            }

            @Override
            public boolean isDone() {
                return frameGrabber.isResultReady();
            }

            @Override
            public StateName getNextStateName() {
                resultReceiver.setValue(frameGrabber.getResult());
                return nextStateName;
            }
        };
    }

    /**
     * @param stateName           the name of the state
     * @param unknownUnknownState if both sides are unknown
     * @param unknownRedState     if the left is unknown and the right is red
     * @param unknownBlueState    if the left is unknown and the right is blue
     * @param redUnknownState     if the left is red and the right is unknown
     * @param redRedState         if the left is red and the right is red
     * @param redBlueState        if the left is red and the right is blue
     * @param blueUnknownState    if the left is blue and the right is unknown
     * @param blueRedState        if the left is blue and the right is red
     * @param blueBlueState       if the left is blue and the right is blue
     * @return the created State
     */
    public static State processBeaconPicture(StateName stateName,
                                             final StateName unknownUnknownState, final StateName unknownRedState, final StateName unknownBlueState,
                                             final StateName redUnknownState, final StateName redRedState, final StateName redBlueState,
                                             final StateName blueUnknownState, final StateName blueRedState, final StateName blueBlueState
    ) {

        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                frameGrabber.setImageProcessor(new RGBBeaconProcessor());
                frameGrabber.grabSingleFrame();
            }

            @Override
            public boolean isDone() {
                return frameGrabber.isResultReady();
            }

            @Override
            public StateName getNextStateName() {
                BeaconColorResult beaconColorResult = (BeaconColorResult) frameGrabber.getResult().getResult();
                BeaconColorResult.BeaconColor leftColor = beaconColorResult.getLeftColor();
                BeaconColorResult.BeaconColor rightColor = beaconColorResult.getRightColor();

                if (leftColor == BeaconColorResult.BeaconColor.RED) {
                    if (rightColor == BeaconColorResult.BeaconColor.RED) {
                        return redRedState;
                    } else if (rightColor == BeaconColorResult.BeaconColor.BLUE) {
                        return redBlueState;
                    } else {
                        return redUnknownState;
                    }
                } else if (leftColor == BeaconColorResult.BeaconColor.BLUE) {
                    if (rightColor == BeaconColorResult.BeaconColor.RED) {
                        return blueRedState;
                    } else if (rightColor == BeaconColorResult.BeaconColor.BLUE) {
                        return blueBlueState;
                    } else {
                        return blueUnknownState;
                    }
                } else {
                    if (rightColor == BeaconColorResult.BeaconColor.RED) {
                        return unknownRedState;
                    } else if (rightColor == BeaconColorResult.BeaconColor.BLUE) {
                        return unknownBlueState;
                    } else {
                        return unknownUnknownState;
                    }
                }
            }
        };
    }

    /**
     * @param stateName the name of the state
     * @param nMotors   the motors to turn off
     * @return the created State
     */
    public static State stop(StateName stateName, final NMotors nMotors) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                nMotors.stop();
            }

            @Override
            public boolean isDone() {
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName      the name of the state
     * @param mecanumControl the motors to turn off
     * @return the created State
     */
    public static State stop(StateName stateName, final MecanumControl mecanumControl) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                mecanumControl.stop();
            }

            @Override
            public boolean isDone() {
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName the name of the state
     * @param message   the message to display to the driver station
     * @param value     the value associated with that message
     * @return the created State
     */
    public static State telemetry(StateName stateName, final String message, final double value) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                telemetry.addData(message, value);
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName the name of the state
     * @param message1  the first message to display to the driver station
     * @param input1    an InputExtractor that returns the value associated with the first message
     * @param message2  the second message to display to the driver station
     * @param input2    an InputExtractor that returns the value associated with the second message
     * @return the created State
     */
    public static State telemetry(StateName stateName, final String message1, final InputExtractor&lt;Double&gt; input1, final String message2, final InputExtractor&lt;Double&gt; input2) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                telemetry.addData(message1, input1.getValue());
                telemetry.addData(message2, input2.getValue());
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * @param stateName   the name of the state
     * @param transitions the list of transitions to the next states
     * @param message     the message to display to the driver station
     * @param value       the value associated with that message
     * @return the created State
     */
    public static State telemetry(StateName stateName, List&lt;Transition&gt; transitions, final String message, final double value) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
            }

            @Override
            public void run() {
                telemetry.addData(message, value);
            }

            @Override
            public void dispose() {
            }
        };
    }

    /**
     * @param stateName   the name of the state
     * @param transitions the list of transitions to the next states
     * @param message1    the first message to display to the driver station
     * @param input1      an InputExtractor that returns the value associated with the first message
     * @param message2    the second message to display to the driver station
     * @param input2      an InputExtractor that returns the value associated with the second message
     * @return the created State
     */
    public static State telemetry(StateName stateName, List&lt;Transition&gt; transitions, final String message1, final InputExtractor&lt;Double&gt; input1, final String message2, final InputExtractor&lt;Double&gt; input2) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
            }

            @Override
            public void run() {
                telemetry.addData(message1, input1.getValue());
                telemetry.addData(message2, input2.getValue());
            }

            @Override
            public void dispose() {
            }
        };
    }

    /**
     * @param stateName     the name of the state
     * @param nextStateName the name of the next state
     * @param servos        the servos to be initialized
     * @return the created State
     * @see Servos
     */
    public static State servoInit(StateName stateName, final StateName nextStateName, final Servos servos) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return servos.areServosDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * @param stateName     the name of the state
     * @param nextStateName the name of the next state
     * @param gyro          the gyro sensor to be calibrated
     * @return the created State
     * @see GyroSensor
     */
    public static State calibrateGyro(StateName stateName, final StateName nextStateName, final GyroSensor gyro) {
        gyro.calibrate();
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return !gyro.isCalibrating();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * @param stateName        the name of the state
     * @param nextStateName    the name of the next state
     * @param doubleLineSensor the 2 line sensors to be calibrated
     * @return the created State
     * @see DoubleLineSensor
     */
    public static State calibrateLineSensor(StateName stateName, final StateName nextStateName, final DoubleLineSensor doubleLineSensor) {
        doubleLineSensor.calibrate();
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return doubleLineSensor.isReady();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * Turn a servo to a preset at max speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPreset   the preset to go to
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, StateName nextStateName, ServoControl servoControl, Enum servoPreset, boolean waitForDone) {
        return servoTurn(stateName, nextStateName, servoControl, servoPreset, ServoControl.MAX_SPEED, waitForDone);
    }

    /**
     * Turn a servo to a preset at a given speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPreset   the preset to go to
     * @param speed         the speed to turn the servo at
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, final StateName nextStateName, final ServoControl servoControl, final Enum servoPreset, final double speed, final boolean waitForDone) {
        return new BasicAbstractState(stateName) {

            @Override
            public void init() {
                servoControl.goToPreset(servoPreset, speed);
            }

            @Override
            public boolean isDone() {
                return !waitForDone || servoControl.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * Turn a servo to a position at max speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPosition the position to go to
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, StateName nextStateName, ServoControl servoControl, double servoPosition, boolean waitForDone) {
        return servoTurn(stateName, nextStateName, servoControl, servoPosition, ServoControl.MAX_SPEED, waitForDone);
    }

    /**
     * Turn a servo to a position at a given speed
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to next
     * @param servoControl  the servo
     * @param servoPosition the position to go to
     * @param speed         the speed to turn the servo at
     * @param waitForDone   whether to wait for the servo to finish turning or move to the next state immediately
     * @return the created State
     * @see ServoControl
     */
    public static State servoTurn(StateName stateName, final StateName nextStateName, final ServoControl servoControl, final double servoPosition, final double speed, final boolean waitForDone) {
        return new BasicAbstractState(stateName) {

            @Override
            public void init() {
                servoControl.setPosition(servoPosition, speed);
            }

            @Override
            public boolean isDone() {
                return !waitForDone || servoControl.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }


    /**
     * drive using the mecanum wheels
     * travels for a certain amount of time defined by the robots speed and a desired distance
     *
     * @param stateName       the name of the state
     * @param nextStateName   the next state to go to
     * @param distance        the distance to travel
     * @param mecanumControl  the mecanum wheels
     * @param gyro            the gyro sensor
     * @param velocity        the velocity to drive at
     * @param direction       the direction to drive
     * @param orientation     the angle to rotate to
     * @param maxAngularSpeed the max speed to rotate to that angle
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     * @see Distance
     */
    public static State mecanumDrive(StateName stateName, final StateName nextStateName, Distance distance, final MecanumControl mecanumControl, final GyroSensor gyro, final double velocity, final Angle direction, final Angle orientation, final Angle tolerance, final double maxAngularSpeed) {
        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);
        double speedMetersPerMillisecond = mecanumControl.getMaxRobotSpeed().metersPerMillisecond() * velocity;
        final double durationMillis = Math.abs(distance.meters() / speedMetersPerMillisecond);
        final EndCondition gyroEC = EVEndConditions.gyroCloseTo(gyro, orientation, tolerance);
        return new BasicAbstractState(stateName) {
            long startTime = 0;

            @Override
            public void init() {
                mecanumControl.setControl(
                        TranslationControls.constant(velocity, direction),
                        RotationControls.gyro(gyro, orientation, maxAngularSpeed)
                );
                startTime = System.currentTimeMillis();
            }

            @Override
            public boolean isDone() {
                long now = System.currentTimeMillis();
                long elapsedTime = now - startTime;
                if (elapsedTime &gt;= durationMillis) {
                    mecanumControl.setTranslationControl(TranslationControls.ZERO);
                    return gyroEC.isDone();
                }
                return false;
            }

            @Override
            public StateName getNextStateName() {
                mecanumControl.stop();
                return nextStateName;
            }
        };
    }

    /**
     * drive using the mecanum wheels
     *
     * @param stateName       the name of the state
     * @param transitions     the list of transitions to the next states
     * @param mecanumControl  the mecanum wheels
     * @param gyro            the gyro sensor
     * @param velocity        the velocity to drive at
     * @param direction       the direction to drive
     * @param orientation     the angle to rotate to
     * @param maxAngularSpeed the max speed to rotate to that angle
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     */
    public static State mecanumDrive(StateName stateName, List&lt;Transition&gt; transitions, final MecanumControl mecanumControl, final GyroSensor gyro, final double velocity, final Angle direction, final Angle orientation, final double maxAngularSpeed) {
        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
//                OptionsFile optionsFile = new OptionsFile(EVConverters.getInstance(), FileUtil.getOptionsFile(&quot;AutoOptions.txt&quot;));
//
//                double max = optionsFile.get(&quot;gyro_max&quot;, Double.class);
//                double gain = optionsFile.get(&quot;gyro_gain&quot;, Double.class);

                mecanumControl.setControl(
                        TranslationControls.constant(velocity, direction),
                        RotationControls.gyro(gyro, orientation, maxAngularSpeed)
//                        RotationControls.gyro(gyro, orientation, max, false, gain)
                );
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                mecanumControl.stop();
            }
        };
    }

    /**
     * @param stateName      the name of the state
     * @param transitions    the list of transitions to the next states
     * @param mecanumControl the mecanum wheels
     * @param gyro           the gyro sensor
     * @param velocity       the velocity to drive at
     * @param direction      the direction to drive
     * @param orientation    the angle to rotate to
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     */
    public static State mecanumDrive(StateName stateName, List&lt;Transition&gt; transitions, MecanumControl mecanumControl, GyroSensor gyro, double velocity, Angle direction, Angle orientation) {
        return mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, direction, orientation, RotationControl.DEFAULT_MAX_ANGULAR_SPEED);
    }

    /**
     * drive using the mecanum wheels
     * travels for a certain amount of time defined by the robots speed and a desired distance
     *
     * @param stateName      the name of the state
     * @param nextStateName  the next state to go to
     * @param distance       the distance to travel
     * @param mecanumControl the mecanum wheels
     * @param gyro           the gyro sensor
     * @param velocity       the velocity to drive at
     * @param direction      the direction to drive
     * @param orientation    the angle to rotate to
     * @return the created State
     * @see MecanumControl
     * @see GyroSensor
     * @see Distance
     */
    public static State mecanumDrive(StateName stateName, StateName nextStateName, Distance distance, final MecanumControl mecanumControl, final GyroSensor gyro, final double velocity, final Angle direction, final Angle orientation, final Angle tolerance) {
        return mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance, RotationControl.DEFAULT_MAX_ANGULAR_SPEED);
    }

    /**
     * follow a line with the mecanum wheels
     *
     * @param stateName           the name of the state
     * @param transitions         the list of transitions to the next states
     * @param lostLineState       what state to go to if the line is lost
     * @param mecanumControl      the mecanum wheels
     * @param doubleLineSensor    the 2 line sensors
     * @param velocity            the velocity to drive at
     * @param lineFollowDirection the direction (left or right) to follow the line at
     * @return the created State
     * @see MecanumControl
     * @see TranslationControls
     */
    public State mecanumLineFollow(StateName stateName, List&lt;Transition&gt; transitions, StateName lostLineState, final MecanumControl mecanumControl, final DoubleLineSensor doubleLineSensor, final double velocity, final TranslationControls.LineFollowDirection lineFollowDirection) {
        transitions.add(new Transition(new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return !mecanumControl.translationWorked();
            }
        }, lostLineState));

        mecanumControl.setDriveMode(MecanumMotors.MecanumDriveMode.NORMALIZED);

        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                mecanumControl.setTranslationControl(TranslationControls.lineFollow(doubleLineSensor, lineFollowDirection, velocity));
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                mecanumControl.stop();
            }
        };
    }


    /**
     * Drive forward or backward with two motors
     *
     * @param stateName   the name of the state
     * @param transitions the transitions to new states
     * @param twoMotors   the motors to move
     * @param velocity    the velocity to drive at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State drive(StateName stateName, List&lt;Transition&gt; transitions, final TwoMotors twoMotors, final double velocity) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                twoMotors.runMotors(velocity, velocity);
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                twoMotors.runMotors(0, 0);
            }
        };
    }

    /**
     * Turn left or right
     *
     * @param stateName   the name of the state
     * @param transitions the transitions to new states
     * @param twoMotors   the motors to move
     * @param velocity    the velocity to turn at (negative for turning left)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, List&lt;Transition&gt; transitions, final TwoMotors twoMotors, final double velocity) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                twoMotors.runMotors(velocity, -velocity);
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                twoMotors.runMotors(0, 0);
            }
        };
    }

    /**
     * Turn with one wheel
     *
     * @param stateName    the name of the state
     * @param transitions  the transitions to new states
     * @param twoMotors    the motors to move
     * @param isRightWheel tells which wheel to turn
     * @param velocity     the velocity to turn the wheel at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State oneWheelTurn(StateName stateName, List&lt;Transition&gt; transitions, final TwoMotors twoMotors, final boolean isRightWheel, final double velocity) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                if (isRightWheel) {
                    twoMotors.runMotors(0, velocity);
                } else {
                    twoMotors.runMotors(velocity, 0);
                }
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                twoMotors.runMotors(0, 0);
            }
        };
    }


    /**
     * Drive for a certain distance
     *
     * @param stateName     the name of the state
     * @param nextStateName the state to go to after the drive is done
     * @param distance      the distance to drive
     * @param twoMotors     the motors to move
     * @param velocity      the velocity to drive at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State drive(StateName stateName, StateName nextStateName, Distance distance, TwoMotors twoMotors, double velocity) {
        double speedMetersPerMillisecond = twoMotors.getMaxRobotSpeed().metersPerMillisecond() * velocity;
        double durationMillis = Math.abs(distance.meters() / speedMetersPerMillisecond);
        return drive(stateName, ImmutableList.of(
                new Transition(
                        EndConditions.timed((long) durationMillis),
                        nextStateName
                )
        ), twoMotors, velocity);
    }

    /**
     * Turn for a certain angle by calculating the time required for that angle
     *
     * @param stateName        the name of the state
     * @param nextStateName    the state to go to when done turning
     * @param angle            the angle to turn
     * @param minRobotTurnTime the time it takes for the robot to turn
     * @param twoMotors        the motors to run
     * @param velocity         the velocity to turn (negative for turning left)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, StateName nextStateName, Angle angle, Time minRobotTurnTime, TwoMotors twoMotors, double velocity) {
        double speedRotationsPerMillisecond = velocity / minRobotTurnTime.milliseconds();
        double durationMillis = Math.abs(angle.degrees() / 360 / speedRotationsPerMillisecond);
        return turn(stateName, ImmutableList.of(
                new Transition(
                        EndConditions.timed((long) durationMillis),
                        nextStateName
                )
        ), twoMotors, velocity);
    }

    /**
     * Turn for a certain angle using a gyro sensor
     *
     * @param stateName     the name of the state
     * @param nextStateName the state to go to when done turning
     * @param angle         the angle to turn
     * @param gyro          the gyro sensor to use
     * @param twoMotors     the motors to turn
     * @param velocity      the velocity to turn at (negative to turn left)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, StateName nextStateName, Angle angle, GyroSensor gyro, TwoMotors twoMotors, double velocity) {
        return turn(stateName, ImmutableList.of(
                new Transition(
                        EVEndConditions.gyroCloseToRelative(gyro, angle, Angle.fromDegrees(5)),
                        nextStateName
                )
        ), twoMotors, velocity);
    }

    /**
     * Turn with one wheel for a certain angle by calculating the time needed to turn that angle
     *
     * @param stateName        the name of the state
     * @param nextStateName    the state to go to when done turning
     * @param angle            the angle to turn
     * @param minRobotTurnTime the time it takes for the robot to turn
     * @param twoMotors        the motors to turn
     * @param isRightWheel     tells which wheel to turn
     * @param velocity         the velocity to turn the wheel at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State oneWheelTurn(StateName stateName, StateName nextStateName, Angle angle, Time minRobotTurnTime, TwoMotors twoMotors, boolean isRightWheel, double velocity) {
        double speedRotationsPerMillisecond = velocity / minRobotTurnTime.milliseconds();
        double durationMillis = Math.abs(2 * angle.degrees() / 360 / speedRotationsPerMillisecond);
        velocity = Math.abs(velocity) * Math.signum(angle.radians());
        if (isRightWheel) {
            velocity *= -1;
        }
        return oneWheelTurn(stateName, ImmutableList.of(
                new Transition(
                        EndConditions.timed((long) durationMillis),
                        nextStateName
                )
        ), twoMotors, isRightWheel, velocity);
    }

    /**
     * Turn with one wheel for a certain angle using a gyro sensor
     *
     * @param stateName     the name of the state
     * @param nextStateName the state to go to after the turn is done
     * @param angle         the angle to turn
     * @param gyro          the gyro sensor to use
     * @param twoMotors     the motors to turn
     * @param isRightWheel  which wheel to use
     * @param velocity      the velocity to turn the wheel at (negative for backwards)
     * @return the created State
     * @see TwoMotors
     */
    public static State turn(StateName stateName, StateName nextStateName, Angle angle, GyroSensor gyro, TwoMotors twoMotors, boolean isRightWheel, double velocity) {
        velocity = Math.abs(velocity) * Math.signum(angle.radians());
        if (isRightWheel) {
            velocity *= -1;
        }
        return oneWheelTurn(stateName, ImmutableList.of(
                new Transition(
                        EVEndConditions.gyroCloseToRelative(gyro, angle, Angle.fromDegrees(5)),
                        nextStateName
                )
        ), twoMotors, isRightWheel, velocity);
    }

    /**
     * Turn a motor at a given power
     *
     * @param stateName   the name of the state
     * @param transitions the transitions to new states
     * @param motor       the motor to be turned
     * @param power       the power to turn the motor at
     * @return the created State
     * @see TwoMotors
     */
    public static State motorTurn(StateName stateName, List&lt;Transition&gt; transitions, final Motor motor, final double power) {
        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                motor.setPower(power);
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                motor.setPower(0);
            }
        };
    }

    /**
     * Line up with the beacon using the line sensor array and distance sensor
     *
     * @param stateName         the name of the state
     * @param successState      the state to go to if the line up succeeds
     * @param failState         the state to go to if the line up fails
     * @param mecanumControl    the mecanum wheels
     * @param direction         the direction angle to face
     * @param gyro              the gyro to use for rotation stabilization
     * @param distSensor        the distance sensor to detect distance from the beacon
     * @param lineSensorArray   the line sensor array to line up sideways with the line
     * @param teamColor         the team you are on and ...
     * @param beaconColorResult ... the beacon configuration to decide which button to line up with
     * @param distance          the distance from the beacon to line up to
     * @return the created State
     * @see LineUpControl
     */
    public static State beaconLineUp(StateName stateName, final StateName successState, final StateName failState, final MecanumControl mecanumControl, final Angle direction, final GyroSensor gyro, final DistanceSensor distSensor, final LineSensorArray lineSensorArray, TeamColor teamColor, final ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult, final Distance distance) {
//        final EndCondition distEndCondition = EVEndConditions.distanceSensorLess(distSensor, Distance.add(distance, Distance.fromInches(4)));
        final EndCondition distEndCondition = EVEndConditions.distanceSensorLess(distSensor, distance);
        final EndCondition gyroEndCondition = EVEndConditions.gyroCloseTo(gyro, direction, 2);

        final BeaconColorResult.BeaconColor myColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor);
        final BeaconColorResult.BeaconColor opponentColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor.opposite());

        return new BasicAbstractState(stateName) {
            private boolean success;
            LineUpControl.Button buttonToLineUpWith;

            @Override
            public void init() {
                buttonToLineUpWith = null;
                if (beaconColorResult.isReady()) {
                    BeaconColorResult result = beaconColorResult.getValue();
                    BeaconColorResult.BeaconColor leftColor = result.getLeftColor();
                    BeaconColorResult.BeaconColor rightColor = result.getRightColor();
                    if (leftColor == myColor &amp;&amp; rightColor == opponentColor) {
                        buttonToLineUpWith = LineUpControl.Button.LEFT;
                    }
                    if (leftColor == opponentColor &amp;&amp; rightColor == myColor) {
                        buttonToLineUpWith = LineUpControl.Button.RIGHT;
                    }
                }

                success = buttonToLineUpWith != null;

                LineUpControl lineUpControl = new LineUpControl(lineSensorArray, buttonToLineUpWith, distSensor, distance, gyro, direction);

                mecanumControl.setTranslationControl(lineUpControl);
                mecanumControl.setRotationControl(lineUpControl);

                distEndCondition.init();
                gyroEndCondition.init();
            }

            @Override
            public boolean isDone() {

                if (!mecanumControl.translationWorked()) {
                    success = false;
                }
                return !success || distEndCondition.isDone();
            }

            @Override
            public StateName getNextStateName() {
                mecanumControl.stop();
                return success ? successState : failState;
            }
        };
    }

    public static State shoot(StateName stateName, final StateName nextStateName, final Shooter shooter, final int shots) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                shooter.shoot(shots);
            }

            @Override
            public boolean isDone() {
//                shooter.act();
                return shooter.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    public static State gyroStabilize(StateName stateName, StateName nextStateName, final MecanumControl mecanumControl, final GyroSensor gyro, final Angle orientation, Angle tolerance) {
        List&lt;Transition&gt; transitions = ImmutableList.of(
                new Transition(EVEndConditions.gyroCloseTo(gyro, orientation, tolerance), nextStateName)
        );

        return new AbstractState(stateName, transitions) {
            @Override
            public void init() {
                mecanumControl.setTranslationControl(TranslationControls.ZERO);
                mecanumControl.setRotationControl(RotationControls.gyro(gyro, orientation));
            }

            @Override
            public void run() {

            }

            @Override
            public void dispose() {
                mecanumControl.stop();
            }
        };
    }

    public static State switchPressed(StateName stateName, StateName pressedStateName, StateName timeoutStateName, DigitalSensor digitalSensor, Time timeout) {
        return empty(stateName, ImmutableList.of(
                new Transition(EndConditions.inputExtractor(digitalSensor), pressedStateName),
                new Transition(EndConditions.timed((long) timeout.milliseconds()), timeoutStateName)
        ));
    }

    public static State initShooter(StateName stateName, final StateName nextStateName, final Shooter shooter) {
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {
                shooter.initialize();
            }

            @Override
            public boolean isDone() {
                return shooter.isDone();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }


    public static State beaconColorSwitch(StateName stateName, final StateName leftButtonState, final StateName rightButtonState, final StateName unknownState, TeamColor teamColor, final ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult) {

        final BeaconColorResult.BeaconColor myColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor);
        final BeaconColorResult.BeaconColor opponentColor = BeaconColorResult.BeaconColor.fromTeamColor(teamColor.opposite());

        return new BasicAbstractState(stateName) {
            private StateName nextState = unknownState;

            @Override
            public void init() {
                if (beaconColorResult.isReady()) {
                    BeaconColorResult result = beaconColorResult.getValue();
                    BeaconColorResult.BeaconColor leftColor = result.getLeftColor();
                    BeaconColorResult.BeaconColor rightColor = result.getRightColor();
                    if (leftColor == myColor &amp;&amp; rightColor == opponentColor) {
                        nextState = leftButtonState;
                    }
                    if (leftColor == opponentColor &amp;&amp; rightColor == myColor) {
                        nextState = rightButtonState;
                    }
                }

            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                return nextState;
            }
        };
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="evlib/EVStates.html">EVStates</a> | <strong>EVEndConditions</strong> | <a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></p>
<hr />
<p>EVEndConditions is a factory class that extends EndConditions from the state-machine-framework. It inherits all the factory methods from EndConditions, and adds its own that relate to FTC.</p>
<p>Some of the useful ones are:</p>
<ul>
<li><strong>analogSensorGreater</strong> -- waits for an <a href="evlib/Analog-Sensors.html">AnalogSensor</a> to be greater than a certain value</li>
<li><strong>analogSensorLess</strong> -- waits for an <a href="evlib/Analog-Sensors.html">AnalogSensor</a> to be less than a certain value</li>
<li><strong>gyroCloseTo</strong> -- waits for a gyro sensor to be close to a certain value</li>
<li><strong>distanceSensorGreater</strong> -- waits for a <a href="evlib/DistanceSensor.html">DistanceSensor</a> to be greater than a certain value</li>
<li><strong>distanceSensorLess</strong> -- waits for a <a href="evlib/DistanceSensor.html">DistanceSensor</a> to be less than a certain value</li>
</ul>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/statemachine/EVEndConditions.java">ftc/evlib/statemachine/EVEndConditions.java</a></p>
<pre><code class="language-java">package ftc.evlib.statemachine;

import com.qualcomm.robotcore.hardware.GyroSensor;

import ftc.electronvolts.statemachine.EndCondition;
import ftc.electronvolts.statemachine.EndConditions;
import ftc.electronvolts.util.Vector2D;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.sensors.AnalogSensor;
import ftc.evlib.hardware.sensors.ColorSensor;
import ftc.evlib.hardware.sensors.DistanceSensor;
import ftc.evlib.hardware.sensors.DoubleLineSensor;
import ftc.evlib.hardware.sensors.LineFinder;
import ftc.evlib.hardware.sensors.LineSensorArray;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 5/10/16
 * &lt;p&gt;
 * Factory class for EndCondition
 * extends EndConditions, which has some useful factory methods already
 *
 * @see EndCondition
 * @see EndConditions
 */
public class EVEndConditions extends EndConditions {

    /**
     * wait for a line of any color
     *
     * @param doubleLineSensor   the two line sensors
     * @param detectionsRequired the number of detections in a row to look for (to avoid false positives)
     * @return the created EndCondition
     * @see DoubleLineSensor
     */
    public static EndCondition foundLine(final DoubleLineSensor doubleLineSensor, final int detectionsRequired) {
        return new EndCondition() {
            int detections;

            @Override
            public void init() {
                detections = 0;
            }

            @Override
            public boolean isDone() {
                DoubleLineSensor.LinePosition linePosition = doubleLineSensor.getPosition();
                if (linePosition == DoubleLineSensor.LinePosition.LEFT || linePosition == DoubleLineSensor.LinePosition.MIDDLE || linePosition == DoubleLineSensor.LinePosition.RIGHT) {
                    detections++;
                    if (detections &gt; detectionsRequired) {
                        return true;
                    }
                } else {
                    detections = 0;
                }
                return false;
            }
        };
    }

    /**
     * wait for a line of a certain color
     *
     * @param lineFinder         two line sensors and a reflective color sensor
     * @param lineColor          the color of line to look for
     * @param detectionsRequired the number of detections in a row to look for (to avoid false positives)
     * @return the created EndCondition
     * @see LineFinder
     */
    public static EndCondition foundColoredLine(final LineFinder lineFinder, final LineFinder.LineColor lineColor, final int detectionsRequired) {
        return new EndCondition() {
            int detections;

            @Override
            public void init() {
                detections = 0;
                lineFinder.startLookingFor(lineColor);
            }

            @Override
            public boolean isDone() {
                if (lineFinder.getValue()) {
                    detections++;
                    if (detections &gt; detectionsRequired) {
                        return true;
                    }
                } else {
                    detections = 0;
                }
                return false;
            }
        };
    }

    /**
     * look for a value from a sensor that is greater/less than a target value
     *
     * @param analogSensor the sensor
     * @param target       the target sensor value
     * @param greater      true if the sensor value needs to be greater than the target value
     * @return the created EndCondition
     * @see AnalogSensor
     */
    public static EndCondition analogSensor(final AnalogSensor analogSensor, final double target, final boolean greater) {
        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                if (greater) {
                    return (analogSensor.getValue() &gt;= target);
                } else {
                    return (analogSensor.getValue() &lt;= target);
                }
            }
        };
    }

    /**
     * look for a value from a sensor that is greater than a target value
     *
     * @param analogSensor the sensor
     * @param value        the target value
     * @return the created EndCondition
     * @see AnalogSensor
     */
    public static EndCondition analogSensorGreater(AnalogSensor analogSensor, double value) {
        return analogSensor(analogSensor, value, true);
    }

    /**
     * look for a value from a sensor that is less than a target value
     *
     * @param analogSensor the sensor
     * @param value        the target value
     * @return the created EndCondition
     * @see AnalogSensor
     */
    public static EndCondition analogSensorLess(AnalogSensor analogSensor, double value) {
        return analogSensor(analogSensor, value, false);
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro             the gyro sensor
     * @param targetDegrees    the target value (in degrees)
     * @param toleranceDegrees the accepted tolerance to be considered &quot;close to&quot; (in degrees)
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(GyroSensor gyro, double targetDegrees, double toleranceDegrees) {
        return gyroCloseTo(gyro, Angle.fromDegrees(targetDegrees), Angle.fromDegrees(toleranceDegrees));
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro             the gyro sensor
     * @param target           the target value
     * @param toleranceDegrees the accepted tolerance to be considered &quot;close to&quot; (in degrees)
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(GyroSensor gyro, Angle target, double toleranceDegrees) {
        return gyroCloseTo(gyro, target, Angle.fromDegrees(toleranceDegrees));
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro          the gyro sensor
     * @param targetDegrees the target value (in degrees)
     * @param tolerance     the accepted tolerance to be considered &quot;close to&quot;
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(GyroSensor gyro, double targetDegrees, Angle tolerance) {
        return gyroCloseTo(gyro, Angle.fromDegrees(targetDegrees), tolerance);
    }

    /**
     * wait until the gyro heading is close to a target value
     *
     * @param gyro      the gyro sensor
     * @param target    the target value
     * @param tolerance the accepted tolerance to be considered &quot;close to&quot;
     * @return the created EndCondition
     * @see GyroSensor
     */
    public static EndCondition gyroCloseTo(final GyroSensor gyro, Angle target, final Angle tolerance) {
        final Vector2D targetVector = new Vector2D(1, target);
        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                Vector2D gyroVector = new Vector2D(1, Angle.fromDegrees(gyro.getHeading()));
                Angle separation = Vector2D.signedAngularSeparation(targetVector, gyroVector);
                return Math.abs(separation.radians()) &lt;= tolerance.radians();
            }
        };
    }

    /**
     * wait until the gyro heading is close to a target value relative to the starting heading
     *
     * @param gyro      the gyro sensor
     * @param target    the target value relative to the starting heading
     * @param tolerance the accepted tolerance to be considered &quot;close to&quot;
     * @return the created State
     * @see GyroSensor
     */
    public static EndCondition gyroCloseToRelative(final GyroSensor gyro, Angle target, final Angle tolerance) {
        final Vector2D targetVector = new Vector2D(1, target);
        return new EndCondition() {
            double gyroInit = 0;

            @Override
            public void init() {
                gyroInit = gyro.getHeading();
            }

            @Override
            public boolean isDone() {
                Vector2D gyroVector = new Vector2D(1, Angle.fromDegrees(gyro.getHeading() - gyroInit));
                Angle separation = Vector2D.signedAngularSeparation(targetVector, gyroVector);
                return Math.abs(separation.degrees()) &lt;= tolerance.degrees();
            }
        };
    }

    /**
     * wait for a reflection of red light with a color sensor
     *
     * @param colorSensor the sensor
     * @return the created EndCondition
     * @see ColorSensor
     */
    public static EndCondition colorSensorRedLight(final ColorSensor colorSensor) {
        return new EndCondition() {
            @Override
            public void init() {
                colorSensor.setColorRed();
            }

            @Override
            public boolean isDone() {
                return colorSensor.getValue();
            }
        };
    }

    /**
     * wait for a reflection of blue light with a color sensor
     *
     * @param colorSensor the sensor
     * @return the created EndCondition
     * @see ColorSensor
     */
    public static EndCondition colorSensorBlueLight(final ColorSensor colorSensor) {
        return new EndCondition() {
            @Override
            public void init() {
                colorSensor.setColorBlue();
            }

            @Override
            public boolean isDone() {
                return colorSensor.getValue();
            }
        };
    }

    /**
     * Wait for any sensor to activate on a line sensor array
     *
     * @param lineSensorArray the sensor
     * @return the created State
     * @see LineSensorArray
     */
    public static EndCondition lineSensorArrayAny(final LineSensorArray lineSensorArray) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return lineSensorArray.getNumSensorsActive() &gt; 0;
            }
        };
    }

    /**
     * Wait for a distance sensor to cross a threshold
     *
     * @param distanceSensor the distance sensor
     * @param target         the target value
     * @param greater        whether to wait for the sensor to be greater or less than the target
     * @return the created State
     * @see DistanceSensor
     */
    public static EndCondition distanceSensor(final DistanceSensor distanceSensor, final Distance target, final boolean greater) {
        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                if (greater) {
                    return (distanceSensor.getDistance().meters() &gt;= target.meters());
                } else {
                    return (distanceSensor.getDistance().meters() &lt;= target.meters());
                }
            }
        };
    }

    /**
     * Wait for a distance sensor to be less than a certain distance
     *
     * @param distanceSensor the distance sensor
     * @param target         the target Distance
     * @return the created State
     * @see DistanceSensor
     */
    public static EndCondition distanceSensorLess(DistanceSensor distanceSensor, Distance target) {
        return distanceSensor(distanceSensor, target, false);
    }

    /**
     * Wait for a distance sensor to be greater than a certain distance
     *
     * @param distanceSensor the distance sensor
     * @param target         the target Distance
     * @return the created State
     * @see DistanceSensor
     */
    public static EndCondition distanceSensorGreater(DistanceSensor distanceSensor, Distance target) {
        return distanceSensor(distanceSensor, target, true);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="evlib/EVStates.html">EVStates</a> | <a href="evlib/EVEndConditions.html">EVEndConditions</a> | <strong>EVStateMachineBuilder</strong></p>
<hr />
<p>EVStateMachineBuilder is a builder class that extends StateMachineBuilder from the state-machine-framework. It inherits all the convenience methods from StateMachineBuilder, and adds its own that relate to FTC.</p>
<p>When you create the EVStateMachineBuilder, you pass in servos, sensors, motors, etc. Then you can call the convenience methods to add servo states, drive states, etc. without passing in the objects again. If you don't have one of the object, a gyro for example, you can pass in a null value and not use any of the gyro convenience methods.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/statemachine/EVStateMachineBuilder.java">ftc/evlib/statemachine/EVStateMachineBuilder.java</a></p>
<pre><code class="language-java">package ftc.evlib.statemachine;

import com.qualcomm.robotcore.hardware.GyroSensor;

import java.util.List;

import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.statemachine.Transition;
import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.control.MecanumControl;
import ftc.evlib.hardware.mechanisms.Shooter;
import ftc.evlib.hardware.sensors.DistanceSensor;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.hardware.servos.Servos;
import ftc.evlib.vision.framegrabber.FrameGrabber;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 5/10/16
 * &lt;p&gt;
 * Builder that uses the EVStates Factory class to create states and build them into a StateMachine
 * extends StateMachineBuilder which has the basic builder methods as well as some useful addXYZ methods
 *
 * @see EVStates
 * @see StateMachineBuilder
 */
public class EVStateMachineBuilder extends StateMachineBuilder {
    private final TeamColor teamColor;
    private final Angle tolerance;
    private final MecanumControl mecanumControl;
    private final GyroSensor gyro;
    private final FrameGrabber frameGrabber;
    private final Servos servos;
    private final DistanceSensor distanceSensor;
    private final Shooter shooter;

    /**
     * any of the parameters can be null if the robot does not have it
     *
     * @param firstStateName the state to start with
     * @param teamColor      the alliance you are on
     * @param tolerance      the tolerance on gyro angles
     * @param gyro           the gyro sensor
     * @param frameGrabber   access to the camera
     * @param servos         the servos
     * @param distanceSensor the distance sensor
     * @param mecanumControl the mecanum wheel controller
     * @param shooter        the helper class for the mecanism that shoots the particles
     */
    public EVStateMachineBuilder(StateName firstStateName, TeamColor teamColor, Angle tolerance, GyroSensor gyro, FrameGrabber frameGrabber, Servos servos, DistanceSensor distanceSensor, MecanumControl mecanumControl, Shooter shooter) {
        super(firstStateName);
        this.teamColor = teamColor;
        this.tolerance = tolerance;
        this.mecanumControl = mecanumControl;
        this.gyro = gyro;
        this.frameGrabber = frameGrabber;
        this.servos = servos;
        this.distanceSensor = distanceSensor;
        this.shooter = shooter;
    }

    public EVStateMachineBuilder(StateName firstStateName, EVStateMachineBuilder b) {
        this(firstStateName, b.teamColor, b.tolerance, b.gyro, b.frameGrabber, b.servos, b.distanceSensor, b.mecanumControl, b.shooter);
    }

//    public void addCameraTracking(StateName stateName, StateName doneState, StateName lostObjectState, long timeoutMillis, StateName timeoutState, ImageProcessor&lt;? extends Location&gt; imageProcessor) {
//        add(EVStates.mecanumCameraTrack(stateName, doneState, lostObjectState, timeoutMillis, timeoutState, mecanumControl, frameGrabber, imageProcessor));
//    }

    //convenience methods for adding different types of States

    public void addServoInit(StateName stateName, StateName nextStateName) {
        add(EVStates.servoInit(stateName, nextStateName, servos));
    }

    public void addCalibrateGyro(StateName stateName, StateName nextStateName) {
        add(EVStates.calibrateGyro(stateName, nextStateName, gyro));
    }

    public void addStop(StateName stateName) {
        add(EVStates.stop(stateName, mecanumControl));
    }

    ///// START DRIVE STATES /////
    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, double directionDegrees, double orientationDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees), maxAngularSpeed));
    }

    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, double directionDegrees, double orientationDegrees) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees)));
    }

    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, Angle direction, Angle orientation, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, direction, orientation, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, List&lt;Transition&gt; transitions, double velocity, Angle direction, Angle orientation) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, velocity, direction, orientation));
    }


    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, double directionDegrees, double orientationDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees), tolerance, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, double directionDegrees, double orientationDegrees) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, Angle.fromDegrees(directionDegrees), Angle.fromDegrees(orientationDegrees), tolerance));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation, Angle tolerance, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance, maxAngularSpeed));
    }

    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity, Angle direction, Angle orientation, Angle tolerance) {
        add(EVStates.mecanumDrive(stateName, nextStateName, distance, mecanumControl, gyro, velocity, direction, orientation, tolerance));
    }
    ///// END DRIVE STATES /////

    ///// START TURN STATES /////
    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, double orientationDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees), maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, double orientationDegrees) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees)));
    }

    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, Angle orientation, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), orientation, maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, List&lt;Transition&gt; transitions, Angle orientation) {
        add(EVStates.mecanumDrive(stateName, transitions, mecanumControl, gyro, 0, Angle.zero(), orientation));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, double orientationDegrees, double toleranceDegrees, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees), Angle.fromDegrees(toleranceDegrees), maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, double orientationDegrees, double toleranceDegrees) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), Angle.fromDegrees(orientationDegrees), Angle.fromDegrees(toleranceDegrees)));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, Angle orientation, Angle tolerance, double maxAngularSpeed) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), orientation, tolerance, maxAngularSpeed));
    }

    public void addGyroTurn(StateName stateName, StateName nextStateName, Angle orientation, Angle tolerance) {
        add(EVStates.mecanumDrive(stateName, nextStateName, Distance.zero(), mecanumControl, gyro, 0, Angle.zero(), orientation, tolerance));
    }
    ///// END TURN STATES /////

    ///// START SERVO STATES /////
    private ServoControl getServo(ServoName servoName) {
        if (!servos.getServoMap().containsKey(servoName)) {
            throw new IllegalArgumentException(&quot;ServoName \&quot;&quot; + servoName + &quot;\&quot; was not found in the servoMap&quot;);
        }
        return servos.getServoMap().get(servoName);

    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, double position, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), position, waitForDone));
    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, double position, double speed, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), position, speed, waitForDone));
    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum preset, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), preset, waitForDone));
    }

    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum preset, double speed, boolean waitForDone) {
        add(EVStates.servoTurn(stateName, nextStateName, getServo(servoName), preset, speed, waitForDone));
    }
    ///// END SERVO STATES /////

    public void addTelem(StateName stateName, String message, double value, List&lt;Transition&gt; transitions) {
        add(EVStates.telemetry(stateName, transitions, message, value));
    }

    public void addTelem(StateName stateName, String message, double value) {
        add(EVStates.telemetry(stateName, message, value));
    }

//    public void addBeaconLineUp(StateName stateName, StateName successState, StateName failState, Angle direction, ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult, Distance distance) {
//        add(EVStates.beaconLineUp(stateName, successState, failState, mecanumControl, direction, gyro, distanceSensor, lineSensorArray, teamColor, beaconColorResult, distance));
//    }

    public void addShoot(StateName stateName, StateName nextStateName, int shots) {
        add(EVStates.shoot(stateName, nextStateName, shooter, shots));
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In Java, an interface sets requirements for the classes that implement it. The methods on the interface have no code that executes, but they tell what the method name, parameters, and return type will be.</p>
<p>The State interface says that each implementation of the State interface must have an act() method which returns the name of the state to be run next call of the loop method. It can return its own name or the name of another state if the current state is done. It also has to have a getName() method which returns the State's StateName. The state interface is used for all other states, including <a href="state_machine_framework/BasicAbstractState.html">BasicAbstractState</a> and <a href="state_machine_framework/AbstractState.html">AbstractState</a>.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/State.java">ftc/electronvolts/statemachine/State.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * This is the core of the state machine framework. It is the interface that
 * defines the required behavior of all the classes that call themselves a
 * &quot;State&quot;. This way anything that receives a State object knows exactly what
 * methods that object has, regardless of the state's internal structure or
 * function.
 */
public interface State {
    /**
     * Act is run in every single loop
     *
     * @return Returns the name of the next state. Returns null to stay
     *         in the current state.
     */
    StateName act();
}
</code></pre>
<p>The next step in the guide is to write a <a href="state_machine_framework/Simple-State-Machine.html">Simple State Machine</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Let's say you have a state machine drawing that looks like this:</p>
<pre><code> _______        ____________        ______
|       \      |            |      /      \
| START  \ ==&gt; |  wait for  | ==&gt; |  STOP  |
|        /     |  1 second  |     |        |
|_______/      |____________|      \______/
</code></pre>
<p>To create a state machine based on this diagram, first create an enum that implements [StateName](The State Interface.md) with your list of states:</p>
<pre><code class="language-java">enum S implements StateName {
    WAIT,
    STOP
};
</code></pre>
<p>Then create a <a href="state_machine_framework/StateMachineBuilder.html">StateMachineBuilder</a>, giving it the state to start with:</p>
<pre><code class="language-java">StateMachineBuilder b = new StateMachineBuilder(S.WAIT);
</code></pre>
<p>Add all the states to the builder:</p>
<pre><code class="language-java">//add a wait state named WAIT for 1000 milliseconds, then go to the state named STOP
b.addWait(S.WAIT, S.STOP, 1000);

//add a stop state named STOP
b.addStop(S.STOP);
</code></pre>
<p>Build the state machine and save it to a variable.</p>
<pre><code class="language-java">StateMachine stateMachine = b.build();
</code></pre>
<p>Add the following to a loop method to run the state machine:</p>
<pre><code class="language-java">stateMachine.act();

//use this for the FTC app:
telemetry.addData(&quot;State&quot;, stateMachine.getCurrentStateName());

//use this for other usages:
System.out.println(&quot;State: &quot; + stateMachine.getCurrentStateName());
</code></pre>
<p>On the telemetry of the FTC app, or the console in other applications, this will be displayed:</p>
<pre><code>State: WAIT
State: WAIT
State: WAIT
State: WAIT
...
State: WAIT
State: WAIT
State: STOP
State: STOP
State: STOP
State: STOP
...
</code></pre>
<p>Congratulations! You made your first state machine!</p>
<p>The next step is to create <a href="state_machine_framework/Custom-States.html">Custom States</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>First, create a class that extends the <a href="state_machine_framework/States.html">States</a> factory class. It will inherit all the methods from <a href="state_machine_framework/States.html">States</a>.</p>
<pre><code class="language-java">public class MyStates extends States {

}
</code></pre>
<p>You can add methods to it such as a gyro calibration state or a telemetry state:</p>
<pre><code class="language-java">public class MyStates extends States {
    public static State calibrateGyro(StateName stateName, final GyroSensor gyro, final StateName nextStateName){
        gyro.calibrate();
        return new BasicAbstractState(stateName) {
            @Override
            public void init() {}

            @Override
            public boolean isDone() {
                return !gyro.isCalibrating();
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }
    
    
    public static State telemetry(Map&lt;StateName, EndCondition&gt; transitions, final String message, final double value) {
        return new AbstractState(transitions) {
            @Override
            public void init() {
            }

            @Override
            public void run() {
                telemetry.addData(message, value);
            }

            @Override
            public void dispose() {
            }
        };
    }
</code></pre>
<p>The next step is to create a <a href="state_machine_framework/Custom-StateMachineBuilder.html">Custom StateMachineBuilder</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Make a class that extends <a href="state_machine_framework/StateMachineBuilder.html">StateMachineBuilder</a> and calls the superconstructor.</p>
<pre><code class="language-java">public class MyStateMachineBuilder extends StateMachineBuilder {
    public MyStateMachineBuilder(StateName firstStateName) {
        super(firstStateName);
    }
}

</code></pre>
<p>Then add a convenience method to it that uses your method you made in [MyStates](Custom States.md).</p>
<pre><code class="language-java">public class MyStateMachineBuilder extends StateMachineBuilder {
    public MyStateMachineBuilder(StateName firstStateName) {
        super(firstStateName);
    }
    
    public void addCalibrateGyro(StateName stateName, GyroSensor gyro, StateName nextStateName){
        add(stateName, MyStates.calibrateGyro(gyro, nextStateName));
    }
    
    public void addTelem(StateName stateName, String message, double value, Map&lt;StateName, EndCondition&gt; transitions) {
        add(stateName, EVStates.telemetry(transitions, message, value));
    }
}

</code></pre>
<p>You can even pass in objects in the constructor to be used multiple times, such as the gyro sensor or telemetry.</p>
<pre><code class="language-java">public class MyStateMachineBuilder extends StateMachineBuilder {
    private final Telemetry telemetry;
    
    public MyStateMachineBuilder(StateName firstStateName, Telemetry telemetry) {
        super(firstStateName);
        this.telemetry = telemetry;
    }
    
    public void addCalibrateGyro(StateName stateName, GyroSensor gyro, StateName nextStateName){
        add(stateName, MyStates.calibrateGyro(gyro, nextStateName));
    }
    
    public void addTelem(StateName stateName, String message, double value, Map&lt;StateName, EndCondition&gt; transitions) {
        add(stateName, EVStates.telemetry(transitions, message, value));
    }
}

</code></pre>
<p>The next step is to create <a href="state_machine_framework/Custom-EndConditions.html">Custom EndConditions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>To create your own EndConditions, all you have to do is make a class that extends <a href="state_machine_framework/EndConditions.html">EndConditions</a>.</p>
<pre><code class="language-java">public class EVEndConditions extends EndConditions {

}
</code></pre>
<p>And add some methods to it, for example a gyro end condition.</p>
<pre><code class="language-java">public class EVEndConditions extends EndConditions {

    public static EndCondition gyroCloseTo(final GyroSensor gyro, double targetDegrees, final double toleranceDegrees){
        final Vector3D targetVector = Vector3D.fromPolar2D(1, Angle.fromDegrees(targetDegrees));
        return new EndCondition() {
            @Override
            public void init() {}

            @Override
            public boolean isDone() {
                Vector3D gyroVector = Vector3D.fromPolar2D(1, Angle.fromDegrees(gyro.getHeading()));
                Angle separation = Vector3D.signedAngularSeparation(targetVector, gyroVector);
                return Math.abs(separation.getValueDegrees()) &lt;= toleranceDegrees;
            }
        };
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>BasicAbstractState is a basic implementation of the <a href="state_machine_framework/State.html">State</a> interface that separates the act() method into three methods: init(), isDone(), and getNextStateName().</p>
<ul>
<li>The init() method is called the first time the state is run. You can reset timers, turn on motors, etc.</li>
<li>The isDone() method is called every loop after init(). You can check sensors, timers, or encoders, and return true when the state needs to exit.</li>
<li>The getNextStateName() method is called after the state is done (when the isDone() method returns true). Here you can decide what state to enter next, or have one state that is always next.</li>
</ul>
<p>Examples of BasicAbstractState (and <a href="state_machine_framework/AbstractState.html">AbstractState</a>) are found in the <a href="state_machine_framework/States.html">States</a> factory class.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/BasicAbstractState.java">ftc/electronvolts/statemachine/BasicAbstractState.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * BasicAbstractState removes the need to use transitions. It requires that the
 * state manages when it should be completed. It is used when the end condition
 * is directly linked to the state's action, such as a state that turns a servo
 * and exits when the servo is done, or a state that detects red or blue using a
 * color sensor and activates a different state based on the result.
 */
public abstract class BasicAbstractState implements State {
    private boolean isRunning = false;

    /**
     * Implementation of the act() method in the State interface
     * 
     * Runs init() on the first call of the act() method, then isDone() on
     * subsequent calls. If isDone() returns true, getNextStateName is called
     * and the value from it is returned as the next state
     * 
     * @return The name of the state to be run next cycle (returns null if there
     *         are no state changes)
     */
    @Override
    public StateName act() {
        if (!isRunning) {
            init();
            isRunning = true;
        }
        if (isDone()) {
            isRunning = false;
            return getNextStateName();
        }
        return null;
    }

    /**
     * Run once when the state is initialized This can do tasks such as setting
     * servo positions or turning on LED's
     */
    public abstract void init();

    /**
     * Run every cycle after init() This can do tasks such as checking if a
     * sensor is calibrated, updating a value, exiting right away or even never
     * exiting at all.
     *
     * @return true if state is finished executing
     */
    public abstract boolean isDone();

    /**
     * The possible next states are passed in through the constructor, and one
     * of them is chosen here. This lets the state define how the decision is
     * made about the next state. It could have any number of next states for
     * any number of reasons, for example: 0 next states for a stop state, 1
     * next state for a servo turn state, 3 next states for a detect color state
     * (red, blue, or unknown)
     *
     * @return the name of the next state to be executed
     */
    public abstract StateName getNextStateName();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>This is an interface used to tell when a state is done. Every implementation of it must have an “init” method, where sensors or motors can be reset, and values can be initialized. It also must have an “isDone” method, where it can read the sensors, motors, etc., and report back to tell if the condition has been met. EndCondition objects are created in the <a href="state_machine_framework/EndConditions.html">EndConditions</a> factory class, and used in the <a href="state_machine_framework/AbstractState.html">AbstractState</a> class with a <a href="state_machine_framework/StateMap.html">StateMap</a>.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/EndCondition.java">ftc/electronvolts/statemachine/EndCondition.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * An EndCondition is used as a condition to tell when something is done. If the
 * end condition is true, the next state is run.
 */
public interface EndCondition {
    /**
     * Run once when the end condition is created Can be used to tell helper
     * classes to initialize Be careful to reset all variables here in case the
     * state is run a second time
     */
    void init();

    /**
     * Run every cycle after init() Used to get values from helper classes to
     * see if the condition is met
     *
     * @return true if condition is met.
     */
    boolean isDone();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>The StateMap class stores the next <a href="state_machine_framework/StateName.html">StateName</a>s and their corresponding <a href="state_machine_framework/EndCondition.html">EndCondition</a>s. It has several of() methods for easily creating StateMap objects. It is used in <a href="state_machine_framework/AbstractState.html">AbstractState</a> to keep track of the transitions out of a state.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/StateMap.java">ftc/electronvolts/statemachine/StateMap.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

import java.util.HashMap;
import java.util.Map;

/**
 * This file was made by the electronVolts, FTC team 7393
 */
public class StateMap extends HashMap&lt;StateName, EndCondition&gt; {
    private static final long serialVersionUID = 3897898537401872088L;

    public static class Entry implements Map.Entry&lt;StateName, EndCondition&gt; {
        private final StateName key;
        private EndCondition value;

        public Entry(StateName key, EndCondition value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public StateName getKey() {
            return key;
        }

        @Override
        public EndCondition getValue() {
            return value;
        }

        @Override
        public EndCondition setValue(EndCondition value) {
            EndCondition old = this.value;
            this.value = value;
            return old;
        }
    }

    public static StateMap of() {
        return new StateMap();
    }

    public static StateMap of(StateName k1, EndCondition v1) {
        return of(new Entry(k1, v1));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2) {
        return of(new Entry(k1, v1), new Entry(k2, v2));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4, StateName k5, EndCondition v5) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4), new Entry(k5, v5));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4, StateName k5, EndCondition v5, StateName k6, EndCondition v6) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4), new Entry(k5, v5), new Entry(k5, v5), new Entry(k6, v6));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4, StateName k5, EndCondition v5, StateName k6, EndCondition v6, StateName k7, EndCondition v7) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4), new Entry(k5, v5), new Entry(k5, v5), new Entry(k6, v6), new Entry(k7, v7));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4, StateName k5, EndCondition v5, StateName k6, EndCondition v6, StateName k7, EndCondition v7, StateName k8, EndCondition v8) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4), new Entry(k5, v5), new Entry(k5, v5), new Entry(k6, v6), new Entry(k7, v7), new Entry(k8, v8));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4, StateName k5, EndCondition v5, StateName k6, EndCondition v6, StateName k7, EndCondition v7, StateName k8, EndCondition v8, StateName k9, EndCondition v9) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4), new Entry(k5, v5), new Entry(k5, v5), new Entry(k6, v6), new Entry(k7, v7), new Entry(k8, v8), new Entry(k9, v9));
    }

    public static StateMap of(StateName k1, EndCondition v1, StateName k2, EndCondition v2, StateName k3, EndCondition v3, StateName k4, EndCondition v4, StateName k5, EndCondition v5, StateName k6, EndCondition v6, StateName k7, EndCondition v7, StateName k8, EndCondition v8, StateName k9, EndCondition v9, StateName k10, EndCondition v10) {
        return of(new Entry(k1, v1), new Entry(k2, v2), new Entry(k3, v3), new Entry(k4, v4), new Entry(k5, v5), new Entry(k5, v5), new Entry(k6, v6), new Entry(k7, v7), new Entry(k8, v8), new Entry(k9, v9), new Entry(k10, v10));
    }

    /**
     * @throws IllegalArgumentException if separate entries have the same key
     */
    public static StateMap of(Entry... entries) {
        StateMap stateMap = new StateMap();
        for (Entry entry : entries) {
            if (stateMap.containsKey(entry.key)) {
                throw new IllegalArgumentException(&quot;Separate entries cannot have the same key.&quot;);
            }
            stateMap.put(entry.key, entry.value);
        }
        return stateMap;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>We have established that all states need an &quot;act&quot; method, but what if the state needs a method that runs once before the main loop starts or a method that runs after the state ends? And what about moving from one state to the next?</p>
<p>AbstractState is a more complex (than <a href="state_machine_framework/BasicAbstractState.html">BasicAbstractState</a>) implementation of the <a href="state_machine_framework/State.html">State</a> interface that separates the State's functionality from the transitions to other states. It separates the act() method into three methods: init(), run(), and dispose().</p>
<ul>
<li>The init() method is called the first time the state is run. You can reset values, turn on motors, etc.</li>
<li>The run() method is called every loop after init(). You can update motor powers, display values on telemetry, etc.</li>
<li>The dispose() method is called after the state is done. You can turn off motors, close files, etc.</li>
</ul>
<p>The way AbstractState handles the transitions to other states is by using <a href="state_machine_framework/StateMap.html">StateMap</a>. When it is created, a map of StateName to EndCondition is passed in.</p>
<p>You can see examples of AbstractState (and <a href="state_machine_framework/BasicAbstractState.html">BasicAbstractState</a>) in the <a href="state_machine_framework/States.html">States</a> factory class.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/AbstractState.java">ftc/electronvolts/statemachine/AbstractState.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

import java.util.Map;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * AbstractState is a simple state that handles transitions.
 */
public abstract class AbstractState implements State {
    // Map of possible transitions to other states
    private final Map&lt;StateName, EndCondition&gt; transitions;

    private boolean isRunning = false;

    /**
     * An abstract state must contain a map of transitions, containing end
     * conditions and their respective next state names.
     *
     * @param transitions the map of EndCondition to NextState
     * @see Transition
     */
    public AbstractState(Map&lt;StateName, EndCondition&gt; transitions) {
        this.transitions = transitions;
    }


    /**
     * Implementation of the act() method in the State interface
     * Cycles through Transitions to run one of the next states if its
     * EndCondition has been met. Does &quot;edge detection&quot; on the state, running
     * init() for the first cycle, run() for subsequent cycles, and dispose()
     * for the last cycle.
     *
     * @return The name of the state to be run next cycle (returns itself if
     *         there are no state changes)
     */
    @Override
    public StateName act() {
        if (!isRunning) {
            init();
            isRunning = true;
            for(Map.Entry&lt;StateName, EndCondition&gt; entry : transitions.entrySet()) {
                EndCondition endCondition = entry.getValue();
                endCondition.init();
            }
        }
        for(Map.Entry&lt;StateName, EndCondition&gt; entry : transitions.entrySet()) {
            StateName stateName = entry.getKey();
            EndCondition endCondition = entry.getValue();
            if (endCondition.isDone()) {
                dispose();
                isRunning = false;
                return stateName;
            }
        }
        run();
        return null;
    }

    /**
     * Run once when the state is initialized.
     * This can run tasks such as starting motors.
     */
    public abstract void init();

    /**
     * Run every cycle after init()
     * This can do tasks such as gyro stabilization or line following
     */
    public abstract void run();

    /**
     * Run once when the state is finished before the next state is initialized.
     * This can do any cleaning up, such as stopping any started motors.
     */
    public abstract void dispose();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>The States factory class is used to keep all the implementations of the <a href="state_machine_framework/State.html">State</a> interface in a central location. All of these implementations use <a href="state_machine_framework/BasicAbstractState.html">BasicAbstractState</a> or <a href="state_machine_framework/AbstractState.html">AbstractState</a>. These factory methods are used in the <a href="state_machine_framework/StateMachineBuilder.html">StateMachineBuilder</a>.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/States.java">ftc/electronvolts/statemachine/States.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

import java.util.Map;

import ftc.electronvolts.util.ResultReceiver;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A factory class containing methods that return several useful states.
 *
 * To write your own State factory, make a class that extends this one and add
 * your own methods. It will inherit all these methods as well, so that when you
 * use your class, you will have access to all these methods and your own in one
 * place.
 */
public class States {
    /**
     * Creates a state machine inside a state of another state machine
     * &quot;Yo, dawg, we heard you like states so we put a state machine inside a
     * state of another state machine so your state can act while your state
     * machine acts, dawg.&quot;
     * 
     * @param subStateToState map that links the sub states to the states in the main state machine
     * @param stateMachineBuilder the builder to add the sub-states to
     * @return the created State
     */
    public static State subStates(final Map&lt;StateName, StateName&gt; subStateToState, final StateMachineBuilder stateMachineBuilder) {
        for (Map.Entry&lt;StateName, StateName&gt; entry : subStateToState.entrySet()) {
            StateName subState = entry.getKey();
            stateMachineBuilder.addStop(subState);
        }
        final StateMachine stateMachine = stateMachineBuilder.build();
        return new BasicAbstractState() {
            private StateName nextStateName;

            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                stateMachine.act();
                for (Map.Entry&lt;StateName, StateName&gt; entry : subStateToState.entrySet()) {
                    StateName subState = entry.getKey();
                    StateName state = entry.getValue();
                    // if the current state is one of the ending sub-states
                    if (stateMachine.getCurrentStateName() == subState) {
                        // go to the corresponding super-state
                        nextStateName = state;
                        return true;
                    }
                }
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * &quot;Go back from whence you came -- and never return!&quot;
     * 
     * A state that never returns
     *
     * @return the created state
     */
    public static State stop() {
        return new BasicAbstractState() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return false;
            }

            @Override
            public StateName getNextStateName() {
                return null;
            }
        };
    }

    /**
     * &quot;An empty-head thinks mischief is fun, but a mindful person relishes wisdom.&quot;
     * (Proverbs 2^10-1)
     * 
     * An empty state.
     *
     * @param transitions the transitions to be considered
     * @return the created State
     */
    public static State empty(Map&lt;StateName, EndCondition&gt; transitions) {
        return new AbstractState(transitions) {
            @Override
            public void init() {
            }

            @Override
            public void run() {
            }

            @Override
            public void dispose() {
            }
        };
    }

    /**
     * &quot;Stop! The cup is full!&quot; said Tokusan.
     * 
     * &quot;Exactly,&quot; said Master Ryutan. &quot;You are like this cup; you are full of
     * ideas. You come and ask for teaching, but your cup is full; I can't put
     * anything in. Before I can teach you, you'll have to empty your cup.&quot;
     * 
     * An empty state.
     *
     * @param nextStateName the next state to be run
     * @return the created State
     */
    public static State empty(final StateName nextStateName) {
        return new BasicAbstractState() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * &quot;She set up a great loom in her palace, and set to weaving a web of
     * threads long and fine. Then she said to us: 'Young men, my suitors
     * now that the great Odysseus has perished, wait, though you are eager
     * to marry me, until I finish this web, so that my weaving will not be
     * useless and wasted.'&quot;
     * ~Penelope, the Odyssey
     * 
     * A state used to run a thread. Useful for off-loading computer intensive
     * tasks such as image processing.
     *
     * @param nextStateName the next state to be run immediately
     * @param thread the thread to be run at the start of the state
     * @return the created State
     */
    public static State runThread(final StateName nextStateName, final Thread thread) {
        return new BasicAbstractState() {
            @Override
            public void init() {
                thread.start();
            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                return nextStateName;
            }
        };
    }

    /**
     * &quot;The power of the Executive Branch is vested in the President of the
     * United States, who also acts as head of state and Commander-in-Chief of
     * the armed forces.&quot;
     * 
     * This is used to do branching and decision trees in the state machine
     * can be used for doing different things depending on which side of the
     * field you are on
     *
     * @param trueStateName the state to go to if the condition is true
     * @param falseStateName the state to go to if the condition is false
     * @param condition the boolean to decide which branch to go to
     * @return the created State
     */
    public static State branch(final StateName trueStateName, final StateName falseStateName, final boolean condition) {
        return new BasicAbstractState() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                if (condition) {
                    return trueStateName;
                } else {
                    return falseStateName;
                }
            }
        };
    }

    /**
     * &quot;Established by Article I of the Constitution, the Legislative Branch
     * consists of the House of Representatives and the Senate, which together
     * form the United States Congress.&quot;
     * 
     * This is used to do branching and decision trees in the state machine
     * can be used for doing different things depending on which side of the
     * field you are on
     *
     * @param trueStateName the state to go to if the condition is true
     * @param falseStateName the state to go to if the condition is false
     * @param nullStateName the state to go to if the condition is null
     * @param condition the boolean to decide which branch to go to
     * @return the created State
     */
    public static State branch(final StateName trueStateName, final StateName falseStateName, final StateName nullStateName, final Boolean condition) {
        return new BasicAbstractState() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                if (condition == null) {
                    return nullStateName;
                } else if (condition) {
                    return trueStateName;
                } else {
                    return falseStateName;
                }
            }
        };
    }

    /**
     * &quot;Where the Executive and Legislative branches are elected by the people,
     * members of the Judicial Branch are appointed by the President and
     * confirmed by the Senate.&quot;
     * 
     * This is used to do branching and decision trees in the state machine
     * using a result
     * acquired while it is running, and to communicate between threads
     *
     * @param trueStateName the state to go to if the receiver returns true
     * @param falseStateName the state to go to if the receiver returns false
     * @param nullStateName the state to go to if the receiver returns null
     * @param receiver the receiver that decides which branch to go to
     * @return the created State
     */
    public static State branch(final StateName trueStateName, final StateName falseStateName, final StateName nullStateName, final ResultReceiver&lt;Boolean&gt; receiver) {
        return new BasicAbstractState() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return receiver.isReady();
            }

            @Override
            public StateName getNextStateName() {
                if (receiver.getValue() == null) {
                    return nullStateName;
                } else if (receiver.getValue()) {
                    return trueStateName;
                } else {
                    return falseStateName;
                }
            }
        };
    }

    /**
     * Count von Count: Five bananas. Six bananas. SEVEN BANANAS!
     * [thunder strikes]
     * Count von Count: Ah, ah, ah. Now, that was silly. Wouldn't you agree, my
     * bats? Ah, ah, ah.
     * 
     * Moves to continueStateName for the first n times it is called, then moves
     * to doneStateName after that
     * 
     * @param continueStateName will be transitioned to first
     * @param doneStateName will be transitioned to after
     * @param n the number of times to return continueStateName
     * @return the created State
     */
    public static State count(final StateName continueStateName, final StateName doneStateName, final int n) {
        return new BasicAbstractState() {
            int i = 0;

            @Override
            public void init() {
                i++;
            }

            @Override
            public boolean isDone() {
                return true;
            }

            @Override
            public StateName getNextStateName() {
                return i &lt;= n ? continueStateName : doneStateName;
            }
        };
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date (unsupported feature)</p>
</blockquote>
<p>EndConditions is a factory for the most commonly used <a href="state_machine_framework/EndCondition.html">EndCondition</a> objects. Storing all of these end conditions in one place allows programmers to write and debug code quickly. These end conditions range from simple tasks such as reporting whether or not a certain amount of time has passed to more complicated tasks like reporting if a sensor has reached a certain value. See also: <a href="state_machine_framework/States.html">States</a></p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/EndConditions.java">ftc/electronvolts/statemachine/EndConditions.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

import java.util.Collection;

import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.MatchTimer;
import ftc.electronvolts.util.ResultReceiver;
import ftc.electronvolts.util.units.Time;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * This is a factory class for the EndCondition interface.
 * It contains methods which return some useful end conditions that can be used
 * not only in the state machine, but also anywhere in your code.
 *
 * To write your own EndCondition factory, make a class that extends this one
 * and add your own methods. It will inherit all these methods as well, so that
 * when you use your class, you will have access to all these methods and your
 * own in one place.
 */
public class EndConditions {
    /**
     * An end condition that finishes after a certain amount of time
     *
     * @param durationMillis the amount of time to wait before finishing
     * @return the created EndCondition
     */
    public static EndCondition timed(final long durationMillis) {
        return new EndCondition() {
            private long endTime;

            @Override
            public void init() {
                endTime = System.currentTimeMillis() + durationMillis;
            }

            @Override
            public boolean isDone() {
                return System.currentTimeMillis() &gt;= endTime;
            }
        };
    }

    /**
     * An end condition that finishes after a certain amount of time
     *
     * @param duration the amount of time to wait before finishing
     * @return the created EndCondition
     */
    public static EndCondition timed(Time duration) {
        return timed((long) duration.milliseconds());
    }

    /**
     * An end condition that finishes after a certain amount of time since the
     * start of the match has passed
     *
     * @param matchTimer a reference to the match timer object
     * @param millisFromMatchStart how many millis from the match start to wait
     * @return the created EndCondition
     */
    public static EndCondition matchTimed(final MatchTimer matchTimer, final long millisFromMatchStart) {

        return new EndCondition() {
            @Override
            public void init() {
            }

            @Override
            public boolean isDone() {
                return matchTimer.getElapsedTime() &gt;= millisFromMatchStart;
            }
        };
    }
    
    /**
     * An end condition that finishes after a certain amount of time since the
     * start of the match has passed
     *
     * @param matchTimer a reference to the match timer object
     * @param timeFromMatchStart how long from the match start to wait
     * @return the created EndCondition
     */
    public static EndCondition matchTimed(MatchTimer matchTimer, Time timeFromMatchStart) {
        return matchTimed(matchTimer, (long) timeFromMatchStart.milliseconds());
    }

    /**
     * An end condition that returns the opposite of another end condition
     *
     * @param endCondition the end condition to use
     * @return the created EndCondition
     */
    public static EndCondition not(final EndCondition endCondition) {
        return new EndCondition() {
            @Override
            public void init() {
                endCondition.init();
            }

            @Override
            public boolean isDone() {
                return !endCondition.isDone();
            }
        };
    }

    /**
     * An end condition that finishes if it has been initialized a certain
     * amount of times
     *
     * @param maxCount the maximum amount of times for the end condition to be
     *            initialized
     * @return the created EndCondition
     */
    public static EndCondition count(final int maxCount) {
        return new EndCondition() {
            private int counter = 0;

            @Override
            public void init() {
                counter++;
            }

            @Override
            public boolean isDone() {
                return counter &gt;= maxCount;
            }
        };
    }

    /**
     * An end condition that executes a certain number of loops before finishing
     *
     * @param maxCount The number of loops to allow the execution of
     * @return the created EndCondition
     */
    public static EndCondition loopCount(final int maxCount) {
        return new EndCondition() {
            private int counter;

            @Override
            public void init() {
                counter = 0;
            }

            @Override
            public boolean isDone() {
                counter++;
                return counter &gt;= maxCount;
            }
        };
    }

    /**
     * An end condition that finishes if all of the specified end conditions are
     * true
     *
     * @param endConditions a list containing all of the end conditions
     * @return the created EndCondition
     */
    public static EndCondition all(final Collection&lt;EndCondition&gt; endConditions) {
        return new EndCondition() {
            @Override
            public void init() {
                for (EndCondition e : endConditions) {
                    e.init();
                }
            }

            @Override
            public boolean isDone() {
                for (EndCondition e : endConditions) {
                    if (!e.isDone()) {
                        return false;
                    }
                }
                return true;
            }
        };
    }

    /**
     * An end condition that finishes if any of the specified end conditions are
     * true
     *
     * @param endConditions a list containing all of the end conditions
     * @return the created EndCondition
     */
    public static EndCondition any(final Collection&lt;EndCondition&gt; endConditions) {
        return new EndCondition() {
            @Override
            public void init() {
                for (EndCondition e : endConditions) {
                    e.init();
                }
            }

            @Override
            public boolean isDone() {
                for (EndCondition e : endConditions) {
                    if (e.isDone()) {
                        return true;
                    }
                }
                return false;
            }
        };
    }

    /**
     * An end condition that never finishes
     *
     * @return the created EndCondition
     */
    public static EndCondition never() {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return false;
            }
        };
    }

    /**
     * An end condition that only allows the state to execute one loop
     *
     * @return the created EndCondition
     */
    public static EndCondition now() {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return true;
            }
        };
    }

    // The following few end conditions use input extractors
    // They may or may not be useful to most people since it would usually be
    // easier to write your
    // own end condition instead of using these

    /**
     * This could be used for an end condition that uses the joystick
     *
     * @param inputExtractor an extracted boolean
     * @return the created EndCondition
     */
    public static EndCondition inputExtractor(final InputExtractor&lt;Boolean&gt; inputExtractor) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                return inputExtractor.getValue();
            }
        };
    }

    /**
     * compares the values of two input extractors
     *
     * @param inputExtractorA the first input extractor
     * @param inputExtractorB the second input extractor
     * @param inclusive whether or not the values being equal satisfies the
     *            condition
     * @return the created EndCondition
     */
    public static EndCondition aGreaterThanB(final InputExtractor&lt;Double&gt; inputExtractorA, final InputExtractor&lt;Double&gt; inputExtractorB, final boolean inclusive) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                if (inclusive) {
                    return inputExtractorA.getValue() &gt;= inputExtractorB.getValue();
                } else {
                    return inputExtractorA.getValue() &gt; inputExtractorB.getValue();
                }
            }
        };
    }

    /**
     * @param inputExtractor the input extractor
     * @param target the target value
     * @param inclusive whether or not the values being equal satisfies the
     *            condition
     * @return the created EndCondition
     */
    public static EndCondition valueGreater(final InputExtractor&lt;Double&gt; inputExtractor, final double target, final boolean inclusive) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                if (inclusive) {
                    return inputExtractor.getValue() &gt;= target;
                } else {
                    return inputExtractor.getValue() &gt; target;
                }
            }
        };
    }

    /**
     * @param inputExtractor the input extractor
     * @param target the target value
     * @param inclusive whether or not the values being equal satisfies the
     *            condition
     * @return the created EndCondition
     */
    public static EndCondition valueLess(final InputExtractor&lt;Double&gt; inputExtractor, final double target, final boolean inclusive) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                if (inclusive) {
                    return inputExtractor.getValue() &lt;= target;
                } else {
                    return inputExtractor.getValue() &lt; target;
                }
            }
        };
    }

    /**
     * @param inputExtractor the input extractor
     * @param min the lower edge of the target range
     * @param max the upper edge of the target range
     * @param inclusive whether or not the value being equal to the min or max
     *            satisfies the condition
     *            when min = max, this should be true.
     * @return the created EndCondition
     */
    public static EndCondition valueBetween(final InputExtractor&lt;Double&gt; inputExtractor, final double min, final double max, final boolean inclusive) {
        return new EndCondition() {
            @Override
            public void init() {

            }

            @Override
            public boolean isDone() {
                double value = inputExtractor.getValue();
                if (inclusive) {
                    return min &lt;= value &amp;&amp; value &lt;= max;
                } else {
                    return min &lt; value &amp;&amp; value &lt; max;
                }
            }
        };
    }

    /**
     * @param inputExtractor the input extractor
     * @param target the target value
     * @param tolerance the tolerance +/- the value to be accepted as meeting
     *            the condition
     * @param inclusive whether or not the value being on the edge of the
     *            tolerance satisfies the condition.
     *            when the tolerance is 0, this should be true.
     * @return the created EndCondition
     */
    public static EndCondition valueCloseTo(InputExtractor&lt;Double&gt; inputExtractor, double target, double tolerance, boolean inclusive) {
        return valueBetween(inputExtractor, target - tolerance, target + tolerance, inclusive);
    }
    
    /**
     * An EndCondition that waits for a ResultReceiver to have a result
     * 
     * @param receiver the ResultReceiver of any type
     * @return the created EndCondition
     */
    public static EndCondition receiverReady(final ResultReceiver&lt;?&gt; receiver) {
        return new EndCondition() {
            @Override
            public void init() {
                
            }
            
            @Override
            public boolean isDone() {
                return receiver.isReady();
            }
        };
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>StateMachineBuilder is responsible for setting up the linkage between the states. It stores a map of the names of the states and the state itself. It also includes convenience methods to easily add pre-defined <a href="state_machine_framework/States.html">States</a> to the state machine, reducing the complexity of adding states. When all the states are done being added, the build method is called, which returns a <a href="state_machine_framework/StateMachine.html">StateMachine</a> object.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/StateMachineBuilder.java">ftc/electronvolts/statemachine/StateMachineBuilder.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

import java.util.HashMap;
import java.util.Map;

import ftc.electronvolts.util.MatchTimer;
import ftc.electronvolts.util.ResultReceiver;
import ftc.electronvolts.util.units.Time;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * The state machine builder simplifies the creation of the state machine. The
 * builder requires an enum with values for each state. See the wiki for an
 * example of how to use it.
 *
 * To write your own StateMachine builder, make a class that extends this one
 * and add your own convenience methods such as addDrive or addServoTurn. It
 * will inherit all these methods as well, so that when you use your class, you
 * will have access to all these methods and your own in one place.
 */
public class StateMachineBuilder {
    // the map the links a state's name to the state
    private Map&lt;StateName, State&gt; stateMap = new HashMap&lt;&gt;();
    private final StateName firstStateName;

    /**
     * A constructor for the builder. The State machine must have a state to
     * start with
     *
     * @param firstStateName the first state to be executed in order
     */
    public StateMachineBuilder(StateName firstStateName) {
        this.firstStateName = firstStateName;
    }

    /**
     * Create a new transition
     *
     * @param nextStateName the name of the enum for the next state
     * @param endCondition the end condition for the next state
     * @return a map containing the one transition
     */
    public Map&lt;StateName, EndCondition&gt; t(StateName nextStateName, EndCondition endCondition) {
        return StateMap.of(nextStateName, endCondition);
    }

    /**
     * Create a new transition with a timed end condition
     *
     * @param nextStateName the enum value associated with the next state
     * @param durationMillis the amount of time to wait before advancing to the
     *            next state
     * @return a map containing the one transition
     */
    public Map&lt;StateName, EndCondition&gt; t(StateName nextStateName, long durationMillis) {
        return t(nextStateName, EndConditions.timed(durationMillis));
    }

    /**
     * Create a new transition with a timed end condition
     *
     * @param nextStateName the enum value associated with the next state
     * @param duration the amount of time to wait before advancing to the next
     *            state
     * @return a map containing the one transition
     */
    public Map&lt;StateName, EndCondition&gt; t(StateName nextStateName, Time duration) {
        return t(nextStateName, EndConditions.timed(duration));
    }

    /**
     * Add a state to the state machine
     *
     * @param state the state to be added
     */
    public void add(StateName stateName, State state) {
        stateMap.put(stateName, state);
    }

    /**
     * Add an empty state that waits a certain duration
     *
     * @param stateName the enum value to be associated with the wait state
     * @param nextStateName the name of the next state
     * @param durationMillis the length of time to wait in millis
     */
    public void addWait(StateName stateName, StateName nextStateName, long durationMillis) {
        add(stateName, States.empty(t(nextStateName, EndConditions.timed(durationMillis))));
    }

    /**
     * Add an empty state that waits a certain duration
     *
     * @param stateName the enum value to be associated with the wait state
     * @param nextStateName the name of the next state
     * @param duration the length of time to wait
     */
    public void addWait(StateName stateName, StateName nextStateName, Time duration) {
        add(stateName, States.empty(t(nextStateName, EndConditions.timed(duration))));
    }

    /**
     * Add an empty state that waits until a certain amount of time has passed
     * since the beginning of the match
     *
     * @param stateName the enum value to be associated with the wait state
     * @param nextStateName the name of the next state
     * @param matchTimer a reference to the match timer object
     * @param durationMillis how many millis from the match start to wait
     * @see MatchTimer
     */
    public void addWait(StateName stateName, StateName nextStateName, MatchTimer matchTimer, long durationMillis) {
        add(stateName, States.empty(t(nextStateName, EndConditions.matchTimed(matchTimer, durationMillis))));
    }

    /**
     * Add an empty state that waits until a certain amount of time has passed
     * since the beginning of the match
     *
     * @param stateName the enum value to be associated with the wait state
     * @param nextStateName the name of the next state
     * @param matchTimer a reference to the match timer object
     * @param duration how much time from the match start to wait
     * @see MatchTimer
     */
    public void addWait(StateName stateName, StateName nextStateName, MatchTimer matchTimer, Time duration) {
        add(stateName, States.empty(t(nextStateName, EndConditions.matchTimed(matchTimer, duration))));
    }

    /**
     * @param stateName the enum value to be associated with the wait state
     * @param trueStateName the state to go to if the condition is true
     * @param falseStateName the state to go to if the condition is false
     * @param condition the boolean to decide which branch to go to
     */
    public void addBranch(StateName stateName, StateName trueStateName, StateName falseStateName, boolean condition) {
        add(stateName, States.branch(trueStateName, falseStateName, condition));
    }

    /**
     * @param stateName the enum value to be associated with the wait state
     * @param trueStateName the state to go to if the condition is true
     * @param falseStateName the state to go to if the condition is false
     * @param nullStateName the state to go to if the condition is null
     * @param condition the boolean to decide which branch to go to
     */
    public void addBranch(StateName stateName, StateName trueStateName, StateName falseStateName, StateName nullStateName, Boolean condition) {
        add(stateName, States.branch(trueStateName, falseStateName, nullStateName, condition));
    }

    /**
     * @param stateName the enum value to be associated with the wait state
     * @param trueStateName the state to go to if the receiver returns true
     * @param falseStateName the state to go to if the receiver returns false
     * @param nullStateName the state to go to if the receiver returns null
     * @param receiver the receiver that decides which branch to go to
     */
    public void addBranch(StateName stateName, StateName trueStateName, StateName falseStateName, StateName nullStateName, ResultReceiver&lt;Boolean&gt; receiver) {
        add(stateName, States.branch(trueStateName, falseStateName, nullStateName, receiver));
    }

    /**
     * Adds an empty state that does nothing and moves to the next state
     * 
     * @param stateName the name of the state
     * @param nextStateName the name of the state to go to next
     */
    public void addEmpty(StateName stateName, StateName nextStateName) {
        add(stateName, States.empty(nextStateName));
    }

    public void addEmpty(StateName stateName, Map&lt;StateName, EndCondition&gt; transitions) {
        add(stateName, States.empty(transitions));
    }

    /**
     * Adds a stop state to the stateMap
     *
     * @param stateName name of the stop state
     */
    public void addStop(StateName stateName) {
        add(stateName, States.stop());
    }

    /**
     * A state used to run a thread. Useful for off-loading computer intensive
     * tasks such as image processing.
     *
     * @param stateName the name of the state
     * @param nextStateName the next state to be transitioned to immediately
     * @param thread the thread to be run at the start of the state
     */
    public void addThread(StateName stateName, StateName nextStateName, Thread thread) {
        add(stateName, States.runThread(nextStateName, thread));
    }

    /**
     * Add a state that moves to continueStateName for the first n times it is
     * called, then moves to doneStateName after that
     * 
     * @param stateName the name of the state
     * @param continueStateName will be transitioned to first
     * @param doneStateName will be transitioned to after
     * @param n the number of times to return continueStateName
     */
    public void addCount(StateName stateName, StateName continueStateName, StateName doneStateName, int n) {
        add(stateName, States.count(continueStateName, doneStateName, n));
    }

    /**
     * Build the state machine with the added states
     *
     * @return the created state machine
     * @see StateMachine
     */
    public StateMachine build() {
        return new StateMachine(stateMap, firstStateName);
    }

    /**
     * Build the state machine with the added states
     *
     * @param firstStateName the state to start at
     * @return the created state machine
     * @see StateMachine
     */

    public StateMachine build(StateName firstStateName) {
        return new StateMachine(stateMap, firstStateName);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>StateMachine is responsible for managing the linkage of the states while running. It is usually created from a <a href="state_machine_framework/StateMachineBuilder.html">StateMachineBuilder</a>. To run it, call the act() method each time through the loop. This will have the current <a href="state_machine_framework/State.html">State</a> act and then determine the next State based on what the current State returned. For debugging, you can call getCurrentStateName() each time in the loop and <a href="state_machine_framework/Logger.html">store it to a file</a> or display it on the telemetry.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/statemachine/StateMachine.java">ftc/electronvolts/statemachine/StateMachine.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.statemachine;

import java.util.Map;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * This class uses the stateMap made by the stateMachineBuilder to run the
 * states and perform the transitions between them
 */
public class StateMachine {
    // This links the names of each state to the actual state
    private final Map&lt;StateName, State&gt; stateMap;
    
    // the current active state
    private State currentState;
    
    // the name of the current state
    private StateName currentStateName;

    /**
     * @param stateMap the state machine structure
     * @param firstStateName the name of the state to start with
     */
    public StateMachine(Map&lt;StateName, State&gt; stateMap, StateName firstStateName) {
        this.stateMap = stateMap;
        currentStateName = firstStateName;
        currentState = stateMap.get(firstStateName);
        // if the stateMap does not have the firstStateName as a key, there is
        // no way to fix it here
    }

    /**
     * call this each time through the loop
     * It runs the current state, then looks up the next state based on the name
     * given by the current state.
     */
    public void act() {
        // tell the current state to act and return the next state
        StateName nextStateName = currentState.act();
        // if the next state name returned is null or the same as this state,
        // stay in the current state
        if (nextStateName != null &amp;&amp; nextStateName != currentStateName) {
            // if the state requested exists
            if (stateMap.containsKey(nextStateName)) {
                // update the current state
                currentStateName = nextStateName;
                currentState = stateMap.get(currentStateName);
            }
        }
    }

    /**
     * used for telemetry purposes
     *
     * @return the name of the current state
     */
    public StateName getCurrentStateName() {
        return currentStateName;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>DeadZone is an interface that tells if a given value is inside the dead-zone. It is not very heavily used in the framework.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/DeadZone.java">ftc/electronvolts/util/DeadZone.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A class that defines a deadzone by returning a boolean as a function of a
 * double
 */
public interface DeadZone {
    boolean isInside(double value);
}
</code></pre>
<p>DeadZones is a factory class for the DeadZone interface. It has methods that return DeadZones for min and max, center and delta, and combinations of other DeadZone objects.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/DeadZones.java">ftc/electronvolts/util/DeadZones.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

import java.util.Collection;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A factory class for DeadZone
 */
public class DeadZones {
    /**
     * @param deadZones the list of DeadZones to be combined
     * @return the composite DeadZone
     */
    public static DeadZone any(final Collection&lt;DeadZone&gt; deadZones) {
        return new DeadZone() {
            @Override
            public boolean isInside(double value) {
                for (DeadZone deadZone : deadZones) {
                    if (deadZone.isInside(value)) {
                        return true;
                    }
                }
                return false;
            }
        };
    }

    /**
     * @param deadZones the list of DeadZones to be combined
     * @return the composite DeadZone
     */
    public static DeadZone all(final Collection&lt;DeadZone&gt; deadZones) {
        return new DeadZone() {
            @Override
            public boolean isInside(double value) {
                for (DeadZone deadZone : deadZones) {
                    if (!deadZone.isInside(value)) {
                        return false;
                    }
                }
                return true;
            }
        };
    }

    /**
     * inverts a DeadZone
     *
     * @param deadZone the DeadZone to invert
     * @return the resulting DeadZone
     */
    public static DeadZone not(final DeadZone deadZone) {
        return new DeadZone() {
            @Override
            public boolean isInside(double value) {
                return !deadZone.isInside(value);
            }
        };
    }

    /**
     * a DeadZone that is empty
     *
     * @return the DeadZone
     */
    public static DeadZone noDeadZone() {
        return new DeadZone() {
            @Override
            public boolean isInside(double value) {
                return false;
            }
        };
    }

    /**
     * A DeadZone between min and max
     *
     * @param min the lower edge of the DeadZone
     * @param max the upper edge of the DeadZone
     * @return the DeadZone
     */
    public static DeadZone minMaxDeadzone(final double min, final double max) {
        return new DeadZone() {
            @Override
            public boolean isInside(double value) {
                return (value &gt;= min &amp;&amp; value &lt;= max);
            }
        };
    }

    /**
     * deadzone that ranges from center-delta to center+delta
     * center is usually zero so that the deadzone is +/-delta
     *
     * @param center the center of the deadzone
     * @param delta the delta on either side of the deadzone
     * @return the DeadZone
     */
    public static DeadZone deltaDeadZone(double center, double delta) {
        double min = center - delta;
        double max = center + delta;
        return minMaxDeadzone(min, max);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ControlLoop defines an interface for control loops such as a <a href="state_machine_framework/PIDController.html">PID controller</a> or a <a href="state_machine_framework/ProportionalController.html">proportional controller</a>. The computeCorrection function takes a target value, or setPoint, and an actual value, or input. It computes the power necessary for a motor or other output to bring the input closer to the setPoint.</p>
<p>The initialize() function is meant to reset the persistent (stored between loop cycles) variables. It should be called when the controller has been off for a while.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/ControlLoop.java">ftc/electronvolts/util/ControlLoop.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * An interface that allows for any type of control loop to be used
 * @see PIDController
 */
public interface ControlLoop {
    double computeCorrection(double setPoint, double input);
    void initialize();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>PIDController implements <a href="state_machine_framework/ControlLoop.html">ControlLoop</a>. It computes the correction on an output based on an input and 4 constants: P, I, D, and maximum output. These 4 constants are given when PIDController is created.</p>
<p>The main function is computeCorrection. It takes the target position (setPoint) and the measured actual position (input) as parameters. It finds the delta time (timeChange), and from that calculates the change in the integral-term (iTerm) and the change in input per time (dInput). Then it calculates output:</p>
<pre><code>output = pGain * error + iTerm - dGain * dInput;
</code></pre>
<ul>
<li><code>pGain * error</code> is the <strong>P</strong>roportional term</li>
<li><code>iTerm</code> is the <strong>I</strong>ntegral term that is accumulated over time</li>
<li><code>dGain * dInput</code> is the <strong>D</strong>erivative term that is calculated from the delta input</li>
</ul>
<p>The <code>initialize()</code> function should be called when the controller has been inactive for a while.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/PIDController.java">ftc/electronvolts/util/PIDController.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A PID controller to use for controlling motors and other outputs
 */
public class PIDController implements ControlLoop {
    private final double pGain, iGain, dGain, maxOutput;
    private final boolean hasIOrDComponent;
    private double iTerm = 0, output = 0;
    private double input = 0, lastInput = 0;
    private long lastTime = -1;

    /**
     * create a new PID controller
     *
     * @param pGain p constant (cannot be negative)
     * @param iGain i constant (cannot be negative)
     * @param dGain d constant (cannot be negative)
     * @param maxOutput the max value of the output and iTerm (cannot be
     *            negative)
     */
    public PIDController(double pGain, double iGain, double dGain, double maxOutput) {
        if (pGain &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal pGain constant \&quot;&quot; + pGain + &quot;\&quot;. PID constants cannot be negative.&quot;);
        }
        if (iGain &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal iGain constant \&quot;&quot; + iGain + &quot;\&quot;. PID constants cannot be negative.&quot;);
        }
        if (dGain &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal dGain constant \&quot;&quot; + dGain + &quot;\&quot;. PID constants cannot be negative.&quot;);
        }
        if (maxOutput &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal maxOutput constant \&quot;&quot; + maxOutput + &quot;\&quot;. PID constants cannot be negative.&quot;);
        }

        this.pGain = pGain;
        this.iGain = iGain;
        this.dGain = dGain;
        this.maxOutput = maxOutput;

        hasIOrDComponent = (iGain != 0 || dGain != 0);
    }

    /**
     * @param setPoint the target value
     * @param input the actual value
     * @return the output of the PID
     */
    @Override
    public double computeCorrection(double setPoint, double input) {
        long now = System.currentTimeMillis();
        if (lastTime &lt; 0) {
            lastTime = now;
        }

        //time passed since last cycle
        double dTime = now - lastTime;
        if (dTime &gt; 0 || !hasIOrDComponent) {
            this.input = input;

            // Compute all the working error variables
            double error = setPoint - input;
            iTerm += iGain * error * dTime;
            iTerm = Utility.mirrorLimit(iTerm, maxOutput);

            // compute dInput instead of dError to avoid spikes
            double dInput = 0;
            if (dTime &gt; 0) dInput = (input - lastInput) / dTime;

            // Compute PID Output
            output = pGain * error + iTerm - dGain * dInput;
            output = Utility.mirrorLimit(output, maxOutput);

            // Remember some variables for next time
            lastInput = input;
            lastTime = now;
        }

        return output;
    }

    /**
     * Reset the PIDController to its initial state by resetting the iTerm and
     * the lastTime
     */
    @Override
    public void initialize() {
        lastInput = input;
        iTerm = 0;
        lastTime = -1;
        if (hasIOrDComponent) {
            output = 0;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ProportionalController implements <a href="state_machine_framework/ControlLoop.html">ControlLoop</a>. It provides a curve that is shaped like the following graph (parameters <code>new ProportionalController(0.2, 0.05, 0.1, 0.5)</code>)</p>
<p><img src="https://github.com/FTC7393/state-machine-framework/blob/master/images/PropGraph.png?raw=true" alt="graph" /></p>
<p>The parameters are as follows:</p>
<ul>
<li>gain -- the slope of the line</li>
<li>deadzone -- the portion of the line where y=0</li>
<li>minOutput -- the height of the small flat parts on either side of the deadzone</li>
<li>maxOutput -- the height of the large flat parts on the edges of the graph</li>
</ul>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/ProportionalController.java">ftc/electronvolts/util/ProportionalController.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A proportional controller to use for controlling motors and other outputs
 */
public class ProportionalController implements ControlLoop {
    private final double gain, maxOutput, deadzone, minOutput;

    public ProportionalController(double gain, double deadzone, double minOutput, double maxOutput) {
        if (gain &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal gain constant \&quot;&quot; + gain + &quot;\&quot;. constants cannot be negative.&quot;);
        }
        if (maxOutput &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal maxOutput constant \&quot;&quot; + maxOutput + &quot;\&quot;. constants cannot be negative.&quot;);
        }
        if (deadzone &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal deadzone constant \&quot;&quot; + deadzone + &quot;\&quot;. constants cannot be negative.&quot;);
        }
        if (minOutput &lt; 0) {
            throw new IllegalArgumentException(&quot;Illegal minOutput constant \&quot;&quot; + minOutput + &quot;\&quot;. constants cannot be negative.&quot;);
        }
        if (minOutput &gt; maxOutput) {
            throw new IllegalArgumentException(&quot;minOutput (&quot; + minOutput + &quot;) cannot be grater than maxOutput (&quot; + maxOutput + &quot;)&quot;);
        }
        if (deadzone &gt; minOutput) {
            throw new IllegalArgumentException(&quot;deadzone (&quot; + deadzone + &quot;) cannot be grater than minOutput (&quot; + minOutput + &quot;)&quot;);
        }

        this.gain = gain;
        this.maxOutput = maxOutput;
        this.deadzone = deadzone;
        this.minOutput = minOutput;
    }

    @Override
    public double computeCorrection(double setPoint, double input) {
        double correction = gain * (setPoint - input);

        if (Math.abs(correction) &lt;= deadzone) {
            //return 0 if the error is in the deadzone
            return 0;
        } else if (Math.abs(correction) &lt; minOutput) {
            //return the minimum if it is below
            return Math.signum(correction) * minOutput;
        } else if (Math.abs(correction) &gt; maxOutput) {
            //cap the correction at +/- maxOutput
            return Math.signum(correction) * maxOutput;
        } else {
            return correction;
        }
    }

    @Override
    public void initialize() {
        //not needed for a proportional controller since there are no persistent state variables
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In EVLib there are 2 types of motors. Motor, which has no encoder, and MotorEnc, which has an encoder. A MotorEnc extends Motor, which means that you can use a motor with an encoder as a motor without an encoder. To create instances of these, see the <a href="evlib/Creating-Motors.html">Creating Motors</a> page.</p>
<p>The interface for Motor has only a few methods, and the only way to control it is by setting the power.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/Motor.java">ftc/evlib/hardware/motors/Motor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/11/16
 * 
 * Wrapper class for the DcMotor.
 * This represents the functions a motor without an encoder can do.
 *
 * @see MotorEnc
 * @see Motors
 */
public interface Motor {
    /**
     * The different modes the motor can be in
     */
    enum Mode {
        POWER, //directly control the power
        SPEED, //enable a feedback loop to correct speed (requires encoders)
        POSITION //turn the motor to a certain encoder position (requires encoders)
    }

    /**
     * Control the motor's raw voltage
     *
     * @param power value to set the power to
     */
    void setPower(double power);

    /**
     * Tells the mode the motor is in which is determined by the last command to the motor.
     *
     * @return the current mode
     */
    Mode getMode();

    /**
     * Sends motor commands to the motor controller
     */
    void update();
}
</code></pre>
<p>The MotorEnc interface has all the methods from Motor, plus the ones for the encoder-related functions.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/MotorEnc.java">ftc/evlib/hardware/motors/MotorEnc.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * Wrapper class for DcMotor if the motor has an encoder
 * This interface has all the non-encoder methods from the Motor interface plus the ones shown here.
 * It can be passed in where a non-encoder Motor interface is needed.
 *
 * @see Motor
 * @see Motors
 */
public interface MotorEnc extends Motor {
    /**
     * A PID on the motor controller uses the encoder to regulate the speed of the motor.
     *
     * @param speed value to set the speed to
     */
    void setSpeed(double speed);

    /**
     * A PID on the motor controller uses the encoder to turn the motor to any encoder position.
     *
     * @param encoderTarget      position in encoder ticks to rotate to
     * @param maxCorrectionPower the max power to run the motor at when turning to the position
     */
    void setPosition(int encoderTarget, double maxCorrectionPower);

    /**
     * Set the encoder zero point to the current encoder value
     */
    void resetEncoder();

    /**
     * Get the encoder position relative to the zero value
     *
     * @return the encoder position
     */
    int getEncoderPosition();

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Before you read this, it is helpful to read about the <a href="evlib/Motor-and-MotorEnc.html">Motor and MotorEnc</a> interfaces.</p>
<p>To get a DcMotor from the hardwareMap and wrap it with the Motor interface, you can do the following:</p>
<pre><code class="language-java">Stoppers stoppers = new Stoppers(); //pass this in each time you create a motor
boolean reversed = false;
boolean brake = true;

DcMotor leftDcMotor = hardwareMap.dcMotor.get(&quot;leftMotor&quot;)
Motor leftMotor = Motors.withoutEncoder(leftDcMotor, reversed, brake, stoppers);
</code></pre>
<p>or you can combine them into 1 line:</p>
<pre><code class="language-java">Motor leftMotor = Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers);
</code></pre>
<p>You can also create a Motor from a Continuous servo:</p>
<pre><code class="language-java">boolean reversed = false;
Motor arm = Motors.continuousServo(hardwareMap.crservo.get(&quot;servoArm&quot;), reversed);
</code></pre>
<p>To combine two motors:</p>
<pre><code class="language-java">Motor combined = Motors.combinedWithoutEncoder(leftMotor, arm);
</code></pre>
<p>To combine more than 2 motors:</p>
<pre><code class="language-java">Motor combined = Motors.combinedWithoutEncoder(
        ImmutableList.of(motor1, motor2, motor3, ...)
);
</code></pre>
<p>Here are all the methods for creating motors:</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/Motors.java">ftc/evlib/hardware/motors/Motors.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.HardwareMap;

import java.util.List;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Utility;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/11/16
 *
 * Factory class for creating Motor wrapper classes.
 * Has methods for all the combinations of with/without encoders and forward/reversed.
 *
 * @see Motor
 * @see MotorEnc
 */
public class Motors {
    /**
     * combine two motors with encoders into one motor
     *
     * @param motorEnc1 the first motor (with encoder)
     * @param motorEnc2 the second motor (with encoder)
     * @return the motor that controls both (with encoder support)
     */
    public static MotorEnc combinedWithEncoder(MotorEnc motorEnc1, MotorEnc motorEnc2) {
        return combinedWithEncoder(ImmutableList.of(motorEnc1, motorEnc2));
    }

    /**
     * combines any number of motors with encoders into one
     *
     * @param motorEncs the list of motors to combine (all must have encoders)
     * @return the motor that controls all of them (with encoder support)
     */
    public static MotorEnc combinedWithEncoder(final List&lt;MotorEnc&gt; motorEncs) {
        return new MotorEnc() {
            @Override
            public void setSpeed(double speed) {
                for (MotorEnc motorEnc : motorEncs)
                    motorEnc.setSpeed(speed);
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                for (MotorEnc motorEnc : motorEncs)
                    motorEnc.setPosition(encoderTarget, maxCorrectionPower);
            }

            @Override
            public void resetEncoder() {
                for (MotorEnc motorEnc : motorEncs) motorEnc.resetEncoder();
            }

            @Override
            public int getEncoderPosition() {
                int total = 0;
                for (MotorEnc motorEnc : motorEncs) total += motorEnc.getEncoderPosition();
                if (motorEncs.size() == 0) {
                    return 0;
                } else {
                    return total / motorEncs.size();
                }
            }

            @Override
            public void setPower(double power) {
                for (MotorEnc motorEnc : motorEncs) motorEnc.setPower(power);
            }

            @Override
            public Mode getMode() {
                if (motorEncs.size() == 0) {
                    return Mode.POWER;
                } else {
                    return motorEncs.get(0).getMode();
                }
            }

            @Override
            public void update() {
                for (MotorEnc motorEnc : motorEncs) motorEnc.update();
            }
        };
    }

    /**
     * combine two motors with or without encoders into one motor
     *
     * @param motor1 the first motor
     * @param motor2 the second motor
     * @return the motor that controls both (without encoder support)
     */
    public static Motor combinedWithoutEncoder(Motor motor1, Motor motor2) {
        return combinedWithoutEncoder(ImmutableList.of(motor1, motor2));
    }

    /**
     * combines any number of motors with or without encoders into one
     *
     * @param motors the list of motors to combine
     * @return the motor that controls all of them (without encoder support)
     */
    public static Motor combinedWithoutEncoder(final List&lt;Motor&gt; motors) {
        return new Motor() {
            @Override
            public void setPower(double power) {
                for (Motor motor : motors) motor.setPower(power);
            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {
                for (Motor motor : motors) motor.update();
            }
        };
    }

    /**
     * Initialize a dcMotor by setting parameters and checking that they were set properly
     *
     * @param dcMotor  the motor to initialize
     * @param reversed whether or not the motor direction should be reversed
     * @param brake    whether to brake or float when stopping
     * @param runMode  what mode to start the motor in
     */
    private static void dcMotorInit(DcMotor dcMotor, boolean reversed, boolean brake, DcMotor.RunMode runMode) {
        //reset the encoder position to zero
        do {
            dcMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        } while (dcMotor.getMode() != DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        //determine the motor's direction as a Direction object
        DcMotor.Direction direction;
        if (reversed) {
            direction = DcMotorSimple.Direction.REVERSE;
        } else {
            direction = DcMotorSimple.Direction.FORWARD;
        }

        //set the motor's direction
        do {
            dcMotor.setDirection(direction);
        } while (dcMotor.getDirection() != direction);

        //set the motor's mode
        do {
            dcMotor.setMode(runMode);
        } while (dcMotor.getMode() != runMode);

        //determine the ZeroPowerBehavior
        DcMotor.ZeroPowerBehavior zeroPowerBehavior;
        if (brake) {
            zeroPowerBehavior = DcMotor.ZeroPowerBehavior.BRAKE;
        } else {
            zeroPowerBehavior = DcMotor.ZeroPowerBehavior.FLOAT;
        }

        //set the motor's ZeroPowerBehavior
        do {
            dcMotor.setZeroPowerBehavior(zeroPowerBehavior);
        } while (dcMotor.getZeroPowerBehavior() != zeroPowerBehavior);
    }

    /**
     * Create a Motor from the hardware map
     *
     * @param hardwareMap              the hardwareMap from the opmode
     * @param dcMotorName              the name of the DcMotor in the hardwareMap
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static Motor withoutEncoder(HardwareMap hardwareMap, String dcMotorName, boolean reversed, boolean brake, Stoppers stoppers) {
        return withoutEncoder(hardwareMap.dcMotor.get(dcMotorName), reversed, brake, stoppers);
    }

    /**
     * Create a Motor from a DcMotor
     *
     * @param dcMotor                  the DcMotor to be wrapped
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static Motor withoutEncoder(final DcMotor dcMotor, boolean reversed, boolean brake, Stoppers stoppers) {
        //initialize the motor with no encoder
        dcMotorInit(dcMotor, reversed, brake, DcMotor.RunMode.RUN_WITHOUT_ENCODER);

        stoppers.add(new Stopper() {
            @Override
            public void stop() {
                do {
                    dcMotor.setPower(0);
                } while (dcMotor.getPower() != 0);
            }
        });

        return new Motor() {
            private double power = 0;

            @Override
            public void setPower(double power) {
                this.power = power;
            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {
                dcMotor.setPower(Utility.motorLimit(power));
            }
        };
    }

    /**
     * Convert a Motor.MotorMode to a DcMotor.RunMode
     *
     * @param mode the mode to convert
     * @return the corresponding DcMotor.RunMode
     */
    public static DcMotor.RunMode motorModeToDcMotorRunMode(Motor.Mode mode) {
        switch (mode) {
            case POWER:
                return DcMotor.RunMode.RUN_WITHOUT_ENCODER;
            case SPEED:
                return DcMotor.RunMode.RUN_USING_ENCODER;
            case POSITION:
                return DcMotor.RunMode.RUN_TO_POSITION;
            default:
                return null;
        }
    }

    /**
     * Convert a DcMotor.RunMode to a Motor.Mode
     *
     * @param runMode the mode to convert
     * @return the corresponding Motor.Mode
     */
    public static Motor.Mode dcMotorRunModeToMotorMode(DcMotor.RunMode runMode) {
        switch (runMode) {
            case RUN_WITHOUT_ENCODER:
                return Motor.Mode.POWER;
            case RUN_USING_ENCODER:
                return Motor.Mode.SPEED;
            case RUN_TO_POSITION:
                return Motor.Mode.POSITION;
            default:
                return null;
        }
    }

    /**
     * Create a MotorEnc from the hardware map
     *
     * @param hardwareMap              the hardwareMap from the opmode
     * @param dcMotorName              the name of the DcMotor in the hardwareMap
     * @param maxEncoderTicksPerSecond the encoder ticks per second at max power
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static MotorEnc withEncoder(HardwareMap hardwareMap, String dcMotorName, int maxEncoderTicksPerSecond, boolean reversed, boolean brake, Stoppers stoppers) {
        return withEncoder(hardwareMap.dcMotor.get(dcMotorName), maxEncoderTicksPerSecond, reversed, brake, stoppers);
    }

    /**
     * Create a MotorEnc from a DcMotor
     *
     * @param dcMotor                  the DcMotor to be wrapped
     * @param maxEncoderTicksPerSecond the encoder ticks per second at max power
     * @param reversed                 true if the motor's direction should be reversed
     * @param brake                    true if the motor should brake when stopped
     * @param stoppers                 the Stoppers object to add the motor to
     * @return the created MotorEnc
     */
    public static MotorEnc withEncoder(final DcMotor dcMotor, int maxEncoderTicksPerSecond, boolean reversed, boolean brake, Stoppers stoppers) {
        final Motor.Mode initMode = Motor.Mode.SPEED;
        dcMotorInit(dcMotor, reversed, brake, motorModeToDcMotorRunMode(initMode)); //start with speed mode

        do {
            dcMotor.setMaxSpeed(maxEncoderTicksPerSecond);
        } while (dcMotor.getMaxSpeed() != maxEncoderTicksPerSecond);

        stoppers.add(new Stopper() {
            @Override
            public void stop() {
                do {
                    dcMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
                } while (dcMotor.getMode() != DcMotor.RunMode.RUN_WITHOUT_ENCODER);
                do {
                    dcMotor.setPower(0);
                } while (dcMotor.getPower() != 0);
            }
        });

        return new MotorEnc() {
            private int encoderZero = 0, encoderPosition = 0;
            private Mode mode = initMode, lastMode = initMode;
            private double power = 0;
            private int encoderTarget = 0;

            @Override
            public void setPower(double power) {
                mode = Mode.POWER;
                this.power = power;
            }

            @Override
            public void setSpeed(double speed) {
                mode = Mode.SPEED;
                power = speed;
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                mode = Mode.POSITION;
                this.encoderTarget = encoderTarget;
                power = maxCorrectionPower;
            }

            @Override
            public void resetEncoder() {
                encoderZero = encoderPosition;
            }

            @Override
            public int getEncoderPosition() {
                return encoderPosition - encoderZero;
            }

            @Override
            public Mode getMode() {
                return mode;
            }

            @Override
            public void update() {
                encoderPosition = dcMotor.getCurrentPosition();

                if (mode != lastMode) {
                    dcMotor.setMode(motorModeToDcMotorRunMode(mode));
                    lastMode = dcMotorRunModeToMotorMode(dcMotor.getMode());
                }

                switch (mode) {
                    case POWER:
                        break;
                    case SPEED:
                        break;
                    case POSITION:
                        dcMotor.setTargetPosition(encoderTarget);
                        break;
                }
                dcMotor.setPower(Utility.motorLimit(power));
            }
        };
    }

    /**
     * Wraps a continuous rotation servo as a normal motor
     *
     * @param crServo  the servo to be wrapped as a motor
     * @param reversed true if the servo should be reversed
     * @return the Motor wrapper class
     */
    public static Motor continuousServo(final CRServo crServo, boolean reversed) {
        DcMotorSimple.Direction direction;
        if (reversed) {
            direction = DcMotorSimple.Direction.REVERSE;
        } else {
            direction = DcMotorSimple.Direction.FORWARD;
        }

        do {
            crServo.setDirection(direction);
        } while (crServo.getDirection() != direction);

        return new Motor() {
            private double power = 0;

            @Override
            public void setPower(double power) {
                this.power = power;
            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {
                crServo.setPower(power);
            }
        };
    }

    /**
     * Scale a motor's power by a constant
     *
     * @param motor the motor to scale
     * @param scale the scaling factor
     * @return the created MotorEnc
     */
    public static Motor scale(final Motor motor, final double scale) {
        return new Motor() {
            @Override
            public void setPower(double power) {
                motor.setPower(power * scale);
            }

            @Override
            public Mode getMode() {
                return motor.getMode();
            }

            @Override
            public void update() {
                motor.update();
            }

        };
    }

    /**
     * Scale a motor's power and speed by a constant
     *
     * @param motorEnc the motor to scale
     * @param scale    the scaling factor
     * @return the created MotorEnc
     */
    public static Motor scale(final MotorEnc motorEnc, final double scale) {
        return new MotorEnc() {
            @Override
            public void setSpeed(double speed) {
                motorEnc.setSpeed(speed * scale);
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                motorEnc.setPosition(encoderTarget, maxCorrectionPower);
            }

            @Override
            public void resetEncoder() {
                motorEnc.resetEncoder();
            }

            @Override
            public int getEncoderPosition() {
                return motorEnc.getEncoderPosition();
            }

            @Override
            public void setPower(double power) {
                motorEnc.setPower(power * scale);
            }

            @Override
            public Mode getMode() {
                return motorEnc.getMode();
            }

            @Override
            public void update() {
                motorEnc.update();
            }

        };
    }


    /**
     * Scale a motor's power by a function
     *
     * @param motor    the motor to scale
     * @param function the function to scale by
     * @return the created MotorEnc
     */
    public static Motor scale(final Motor motor, final Function function) {
        return new Motor() {
            @Override
            public void setPower(double power) {
                motor.setPower(function.f(power));
            }

            @Override
            public Mode getMode() {
                return motor.getMode();
            }

            @Override
            public void update() {
                motor.update();
            }

        };
    }

    /**
     * Scale a motor's power and speed by a function
     *
     * @param motorEnc the motor to scale
     * @param function the function to scale by
     * @return the created MotorEnc
     */
    public static Motor scale(final MotorEnc motorEnc, final Function function) {
        return new MotorEnc() {
            @Override
            public void setSpeed(double speed) {
                motorEnc.setSpeed(function.f(speed));
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                motorEnc.setPosition(encoderTarget, maxCorrectionPower);
            }

            @Override
            public void resetEncoder() {
                motorEnc.resetEncoder();
            }

            @Override
            public int getEncoderPosition() {
                return motorEnc.getEncoderPosition();
            }

            @Override
            public void setPower(double power) {
                motorEnc.setPower(function.f(power));
            }

            @Override
            public Mode getMode() {
                return motorEnc.getMode();
            }

            @Override
            public void update() {
                motorEnc.update();
            }

        };
    }

    /**
     * @return a motor with an encoder that does nothing
     */
    public static MotorEnc dummyWithEncoder() {
        return new MotorEnc() {
            private Mode mode = Mode.POWER;

            @Override
            public void setSpeed(double speed) {
                mode = Mode.SPEED;
            }

            @Override
            public void setPosition(int encoderTarget, double maxCorrectionPower) {
                mode = Mode.POSITION;
            }

            @Override
            public void resetEncoder() {

            }

            @Override
            public int getEncoderPosition() {
                return 0;
            }

            @Override
            public void setPower(double power) {
                mode = Mode.POWER;
            }

            @Override
            public Mode getMode() {
                return mode;
            }

            @Override
            public void update() {

            }
        };
    }

    /**
     * @return a motor that does nothing
     */
    public static Motor dummyWithoutEncoder() {
        return new Motor() {
            @Override
            public void setPower(double power) {

            }

            @Override
            public Mode getMode() {
                return Mode.POWER;
            }

            @Override
            public void update() {

            }
        };
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Before you read this, it is helpful to read about the <a href="evlib/Motor-and-MotorEnc.html">Motor and MotorEnc</a> interfaces and also how to <a href="evlib/Creating-Motors.html">create motors</a>.</p>
<p>The following class groups any number of motors and can run them all at once with a list of powers.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/NMotors.java">ftc/evlib/hardware/motors/NMotors.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import ftc.electronvolts.util.Utility;
import ftc.electronvolts.util.units.Velocity;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * A general controller for a collection of N motors.
 * Knows how to run the motors given a list of Doubles.
 * Can normalize the powers/speeds before running if requested.
 * Subclasses can have fixed numbers of motors
 *
 * @see Motor
 * @see MotorEnc
 * @see OneMotors
 * @see TwoMotors
 * @see ThreeMotors
 * @see FourMotors
 * @see FiveMotors
 * @see SixMotors
 */
public class NMotors {
    /**
     * the list of motors that are grouped
     */
    private final List&lt;? extends Motor&gt; motors;

    /**
     * whether or not to use speed mode on the motors
     */
    private final boolean useSpeedMode;

    /**
     * the measured maximum speed of the robot
     */
    private final Velocity maxRobotSpeed;

    /**
     * the values most recently sent to the motors
     */
    private final double[] values;
    private final int[] encoders;

    /**
     * @param motors        the list of motors
     * @param useSpeedMode  true if encoder-regulated speed mode is desired
     * @param maxRobotSpeed the measured maximum speed of the robot
     */
    public NMotors(List&lt;? extends Motor&gt; motors, boolean useSpeedMode, Velocity maxRobotSpeed) {
        //if using speed mode, the motors need to have encoders
        if (useSpeedMode) {
            for (int i = 0; i &lt; motors.size(); i++) {
                if (!(motors.get(i) instanceof MotorEnc)) {
                    throw new IllegalArgumentException(&quot;Argument 'motors' must be of type List&lt;MotorEnc&gt; if speed mode is to be used.&quot;);
                }
            }
        }
        this.motors = motors;
        this.useSpeedMode = useSpeedMode;
        this.maxRobotSpeed = maxRobotSpeed.abs();
        values = new double[motors.size()];
        encoders = new int[motors.size()];
    }

    /**
     * @return the measured maximum speed of the robot
     */
    public Velocity getMaxRobotSpeed() {
        return maxRobotSpeed;
    }

    /**
     * Allows different stop behaviors for different operations
     *
     * @param stopBehavior what to do when the power/speed is 0
     */

    /**
     * scale all the motor values if any one power is above the maximum of 1
     *
     * @param values the powers/speeds to be scaled and then run
     */
    public void runNormalized(List&lt;Double&gt; values) {
        if (values.size() != motors.size()) {
            throw new IllegalArgumentException(&quot;Argument 'values' must have the same length as the number of motors.&quot;);
        }

        //if the inputs are too high, scale them
        double highest = 0;

        //find the magnitude of the number with the highest magnitude
        for (double n : values) {
            if (Math.abs(n) &gt; highest) {
                highest = Math.abs(n);
            }
        }

        if (highest &lt; 1) { //only normalize if the values are too high
            highest = 1;
        }

        //rescale the values by the highest value
        List&lt;Double&gt; valuesScaled = new ArrayList&lt;&gt;();
        for (double power : values) {
            valuesScaled.add(power / highest);
        }

        run(valuesScaled);
    }

    /**
     * run the motors with raw power/speed
     *
     * @param values the raw values to send to the motors
     */
    public void run(List&lt;Double&gt; values) {
        if (values.size() != motors.size()) {
            throw new IllegalArgumentException(&quot;Argument 'values' must have the same length as the number of motors.&quot;);
        }

        //set the motor powers/speeds of each motor
        for (int i = 0; i &lt; motors.size(); i++) {
            Double value = Utility.motorLimit(values.get(i));
            if (useSpeedMode) {
                MotorEnc motorEnc = ((MotorEnc) motors.get(i));
                motorEnc.setSpeed(value);
                encoders[i] = motorEnc.getEncoderPosition();
            } else {
                motors.get(i).setPower(value);
            }
            this.values[i] = value;
        }
    }

    /**
     * @param i the index of the motor to read the value from
     * @return the values most recently sent to the motors
     */
    public double getValue(int i) {
        return values[i];
    }

    /**
     * @param i the index of the motor to read the encoder value from
     * @return the values of the motor encoders. All encoder values will be 0 if useSpeedMode is false
     */
    public int getEncoder(int i) {
        return encoders[i];
    }

    /**
     * stop all the motors
     */
    public void stop() {
        //create a list of the same length as motors filled with zeroes
        run(new ArrayList&lt;&gt;(Collections.nCopies(motors.size(), 0.0)));
    }

    /**
     * Send the motor commands to the motor controller
     */
    public void update() {
        for (int i = 0; i &lt; motors.size(); i++) {
            motors.get(i).update();
        }
    }
}
</code></pre>
<p>There are also similar classes for every other number of motors up to 6. (for example: <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/FourMotors.java">FourMotors</a>). If you need more than 6 motors, you can extend the class yourself. (You never know when you might need 800 motors for some reason.)</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This class has been found to have logic errors, though the source of these has not been pinpointed. We are currently working on an alternative</p>
</blockquote>
<p>Before you read this, it might be helpful to read about the <a href="evlib/NMotors.html">NMotors</a> class first.</p>
<p>Mecanum wheels use diagonal forces to move in any direction. Here is a diagram of the direction of the force of each wheel when moving forward:</p>
<p><img src="https://github.com/FTC7393/EVLib/blob/master/images/mecanum.png?raw=true" alt="mecanum force diagram" /></p>
<p>To drive forward/backward, you just power all the wheels forward/backward.
To turn right, you power the right wheels backward and the left wheels forward, just like normal wheels.
(Turning left is the same idea.)</p>
<p>To move sideways right, move the front-left and back-right wheels forward, and the others backward.</p>
<p>Now we have this table:</p>
<pre><code>            FORWARD(+x)   SIDEWAYS RIGHT(+y)   TURN RIGHT(+r)
front left      +                 +                  +
front right     +                 -                  -
back left       +                 -                  +
back right      +                 +                  -
</code></pre>
<p>And we can convert this table to an algorithm:</p>
<pre><code>inputs: x, y, and r

flPower = + x + y + r
frPower = + x - y - r
blPower = + x - y + r
brPower = + x + y - r
</code></pre>
<p>This converts the desired motion of the robot into the power for the wheels.</p>
<p>The next thing to worry about is scaling to make sure the motors do not get sent a power that is greater than 1 or less than -1. Fortunately, the scaling is already implemented in the <a href="evlib/NMotors.html">NMotors</a> class.</p>
<p>This is the MecanumMotors class, which extends FourMotors, which in turn extends NMotors. So all MecanumMotors has to do is convert the velocity in X, Y, and R to motor powers using the algorithm we found above. It also has various setters for X, y, and R, as well as functions to convert polar (direction and distance) coordinates to cartesian (x and y) coordinates.</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/motors/MecanumMotors.java">ftc/evlib/hardware/motors/MecanumMotors.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.motors;

import com.google.common.collect.ImmutableList;

import java.util.ArrayList;
import java.util.List;

import ftc.electronvolts.util.Utility;
import ftc.electronvolts.util.units.Angle;
import ftc.electronvolts.util.units.Velocity;

import static ftc.evlib.driverstation.Telem.telemetry;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 12/27/15
 *
 * A subclass of FourMotors that contains algorithms for controlling mecanum wheels.
 * It stores the X, Y, and R velocities and sends them to the motors when it is updated.
 *
 * @see FourMotors
 * @see ftc.evlib.hardware.control.MecanumControl
 */
public class MecanumMotors extends FourMotors {

    public enum MecanumDriveMode {
        NORMALIZED, TRANSLATION_NORMALIZED
    }

    //the stored velocities
    private double velocityX = 0;
    private double velocityY = 0;
    private double velocityR = 0;

    //the drive mode
    private MecanumDriveMode driveMode = MecanumDriveMode.NORMALIZED;

    /**
     * @param frontLeftMotor  the front left motor
     * @param frontRightMotor the front right motor
     * @param backLeftMotor   the back left motor
     * @param backRightMotor  the back right motor
     * @param useSpeedMode    whether or not to use speed control on the motors
     * @param maxRobotSpeed   the measured speed of the robot at 100% power
     */
    public MecanumMotors(Motor frontLeftMotor, Motor frontRightMotor, Motor backLeftMotor, Motor backRightMotor, boolean useSpeedMode, Velocity maxRobotSpeed) {
        super(frontLeftMotor, frontRightMotor, backLeftMotor, backRightMotor, useSpeedMode, maxRobotSpeed);
    }

    /**
     * @param mode the drive mode
     */
    public void setDriveMode(MecanumDriveMode mode) {
        driveMode = mode;
    }

    /**
     * Update the motor powers
     */
    public void mecanumDrive() {
        switch (driveMode) {
            case NORMALIZED:
                mecanumDriveNormalized();
                break;
            case TRANSLATION_NORMALIZED:
                mecanumDriveTranslationNormalized();
                break;
        }
    }

    /**
     * run the motors based on the xyr velocities
     * normalize if any motor power is too large
     */
    private void mecanumDriveNormalized() {
        //calculate motor powers
        runMotorsNormalized(
                velocityX + velocityY - velocityR,
                velocityX - velocityY + velocityR,
                velocityX - velocityY - velocityR,
                velocityX + velocityY + velocityR
        );
    }

    /**
     * Calculate rotational velocity first, and use remaining headway for translation.
     */
    private void mecanumDriveTranslationNormalized() {
        //calculate motor powers
        List&lt;Double&gt; translationValues = ImmutableList.of(
                velocityX + velocityY,
                velocityX - velocityY,
                velocityX - velocityY,
                velocityX + velocityY);

        List&lt;Double&gt; rotationValues = ImmutableList.of(
                -velocityR,
                velocityR,
                -velocityR,
                velocityR);

        double scaleFactor = 1;
        double tmpScale = 1;

        // Solve this equation backwards:
        // MotorX = TranslationX * scaleFactor + RotationX
        // to find scaleFactor that ensures -1 &lt;= MotorX &lt;= 1 and 0 &lt; scaleFactor &lt;= 1

        for (int i = 0; i &lt; 4; i++) {
            if (Math.abs(translationValues.get(i) + rotationValues.get(i)) &gt; 1) {
                tmpScale = (1 - rotationValues.get(i)) / translationValues.get(i);
            } else if (translationValues.get(i) + rotationValues.get(i) &lt; -1) {
                tmpScale = (rotationValues.get(i) - 1) / translationValues.get(i);
            }
            if (tmpScale &lt; scaleFactor) {
                scaleFactor = tmpScale;
            }
        }

        telemetry.addData(&quot;driveMode&quot;, driveMode.toString());
        telemetry.addData(&quot;scaleFactor&quot;, scaleFactor);

        List&lt;Double&gt; valuesScaled = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 4; i++) {
            valuesScaled.add(translationValues.get(i) * scaleFactor + rotationValues.get(i));
            telemetry.addData(&quot;valuesScaled(&quot; + i + &quot;)&quot;, valuesScaled.get(i));
        }

        run(valuesScaled);
    }

    /**
     * @param velocityX the x velocity
     */
    public void setVelocityX(double velocityX) {
        this.velocityX = Utility.motorLimit(velocityX);
    }

    /**
     * @param velocityY the y velocity
     */
    public void setVelocityY(double velocityY) {
        this.velocityY = Utility.motorLimit(velocityY);
    }

    /**
     * @param velocityR the rotational velocity
     */
    public void setVelocityR(double velocityR) {
        this.velocityR = Utility.motorLimit(velocityR);
    }

    /**
     * set the x and y velocities at the same time
     *
     * @param velocityX the x velocity
     * @param velocityY the y velocity
     */
    public void setVelocityXY(double velocityX, double velocityY) {
        setVelocityX(velocityX);
        setVelocityY(velocityY);
    }

    /**
     * set the x, y, and rotational velocities at the same time
     *
     * @param velocityX the x velocity
     * @param velocityY the y velocity
     * @param velocityR the rotational velocity
     */
    public void setVelocityXYR(double velocityX, double velocityY, double velocityR) {
        setVelocityX(velocityX);
        setVelocityY(velocityY);
        setVelocityR(velocityR);
    }

    /**
     * set the x and y velocities using polar coordinates
     *
     * @param velocity  the velocity (r of the polar coordinate)
     * @param direction the direction (theta of the polar coordinate)
     */
    public void setVelocityPolar(double velocity, Angle direction) {
        double directionRadians = direction.radians();
        setVelocityX(velocity * Math.cos(directionRadians));
        setVelocityY(velocity * Math.sin(directionRadians));
    }

    /**
     * set the x and y velocities using polar coordinates, and also set the rotational velocity
     *
     * @param velocity  the velocity (r of the polar coordinate)
     * @param direction the direction (theta of the polar coordinate)
     * @param velocityR the rotational velocity
     */
    public void setVelocityPolarR(double velocity, Angle direction, double velocityR) {
        setVelocityPolar(velocity, direction);
        setVelocityR(velocityR);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This class has been found to have logic errors, though the source of these has not been pinpointed. We are currently working on an alternative</p>
</blockquote>
<p>Using the <a href="evlib/Mecanum-Wheels.html">MecanumMotors</a> class that converts velocity in the X, Y, and R directions, we need a way to add control algorithms, such as gyro stabilization or line following.</p>
<p>The gyro algorithm would look like:</p>
<pre><code>Loop:
  get current heading from gyro
  calculate heading error from desired heading
  adjust ROTATION based on heading error
</code></pre>
<p>And the line following would look like:
(The x axis is the forward/backward movement of the robot)</p>
<pre><code>Loop:
  get values from line sensors
  calculate position on the line (LEFT, MIDDLE, or RIGHT)
  if LEFT: y = positive
  if middle: y = 0
  if RIGHT: y = negative
  x is defined by the input
  set the TRANSLATION to (x, y)
</code></pre>
<p>As you can see, the gyro stabilization controls the rotation, and the line following controls the translation.</p>
<p>Now the challenge is to make a class that can accept different types of translation/rotation controllers.</p>
<p>First, we create interfaces TranslationControl and RotationControl to define what they have output:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/TranslationControl.java">ftc/evlib/hardware/control/TranslationControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.Vector2D;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/19/16
 * 
 * Controls the translation of a mecanum robot
 *
 * @see TranslationControls
 * @see Vector2D
 */
public interface TranslationControl {
    /**
     * update the velocity x and velocity y values
     *
     * @return true if there were no problems
     */
    boolean act();

    /**
     * @return the translational velocity
     */
    Vector2D getTranslation();
}
</code></pre>
<p>As you can see, the translation control returns a Vector2D (x and y).</p>
<p>RotationControl is more complicated, because it not only has to find the angular velocity, but also apply a correction of a certain angle to the translation.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/RotationControl.java">ftc/evlib/hardware/control/RotationControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.units.Angle;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/19/16
 * 
 * Controls the rotation of a mecanum robot
 *
 * @see RotationControls
 * @see Angle
 */
public interface RotationControl {
    double DEFAULT_MAX_ANGULAR_SPEED = 0.5;
//    double DEFAULT_MAX_ANGULAR_SPEED = 0.8;

    /**
     * update the rotational velocity
     *
     * @return true if there were no problems
     */
    boolean act();

    /**
     * @return the rotational velocity
     */
    double getVelocityR();

    /**
     * accounts for the robot's rotation being off when translating
     *
     * @return correction to the translation direction
     */
    Angle getPolarDirectionCorrection();
}
</code></pre>
<p>There are factory classes for the TranslationControl and RotationControl:
<a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/TranslationControls.java">ftc/evlib/hardware/control/TranslationControls.java</a>
<a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/RotationControls.java">ftc/evlib/hardware/control/RotationControls.java</a></p>
<p>They create the controllers such as the gyro stabilization, line following, and also controllers that return constant values for dead reckoning.</p>
<p>For controllers that control the rotation and translation, there is an abstract class called XYRControl that combines both the RotationControl and TranslationControl interfaces.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/XYRControl.java">ftc/evlib/hardware/control/XYRControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.units.Angle;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 12/14/16
 *
 * Controls both the translation (x and y) and the rotation (r) of a robot with mecanum wheels
 *
 * @see RotationControl
 * @see TranslationControl
 * @see XYRControls
 */
public abstract class XYRControl implements RotationControl, TranslationControl {
    @Override
    public Angle getPolarDirectionCorrection() {
        return Angle.zero();
    }
}
</code></pre>
<p>The factory class for XYRControl is <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/XYRControls.java">ftc/evlib/hardware/control/XYRControls.java</a></p>
<p>Now we need to take the value from the TranslationControl and RotationControl and pass them to the MecanumMotors. This is done by MecanumControl:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/MecanumControl.java">ftc/evlib/hardware/control/MecanumControl.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.control;

import ftc.electronvolts.util.Vector2D;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.motors.MecanumMotors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/19/16
 * 
 * Manages what algorithms control the rotation and translation of the mecanum wheels
 * This allows you to mix and match rotation and translation (x and y) controllers and change them whenever you want
 *
 * @see MecanumMotors
 * @see RotationControl
 * @see RotationControls
 * @see TranslationControl
 * @see TranslationControls
 */
public class MecanumControl {
    /**
     * the motors to be controlled
     */
    private final MecanumMotors mecanumMotors;

    //the controllers for the rotation and translation
    private RotationControl rotationControl;
    private TranslationControl translationControl;

    /**
     * the velocity in the x, y, and rotation directions
     */
    private double velocityX, velocityY, velocityR;

    /**
     * stores whether or not the translation/rotation worked
     * for example, translationWorked will be false if the line following lost the line
     */
    private boolean translationWorked = true, rotationWorked = false;

    /**
     * create a MecanumControl that is not moving
     *
     * @param mecanumMotors the motors to control
     */
    public MecanumControl(MecanumMotors mecanumMotors) {
        this(mecanumMotors, XYRControls.ZERO);
    }

    /**
     * create a MecanumControl and immediately start using an XYR control
     *
     * @param mecanumMotors the motors to control
     * @param xyrControl    how to command the motors' rotation and translation
     */
    public MecanumControl(MecanumMotors mecanumMotors, XYRControl xyrControl) {
        this(mecanumMotors, xyrControl, xyrControl);
    }

    /**
     * create a MecanumControl and immediately start using TranslationControl and RotationControl
     *
     * @param mecanumMotors      the motors to control
     * @param rotationControl    how to command the motors' rotation
     * @param translationControl how to command the motors' translation
     */
    public MecanumControl(MecanumMotors mecanumMotors, RotationControl rotationControl, TranslationControl translationControl) {
        this.rotationControl = rotationControl;
        this.mecanumMotors = mecanumMotors;
        this.translationControl = translationControl;
    }

    /**
     * @return the robot's speed when the power is set to 100%
     */
    public Velocity getMaxRobotSpeed() {
        return mecanumMotors.getMaxRobotSpeed();
    }

    /**
     * @param rotationControl the controller that determines the robot's rotation
     */
    public void setRotationControl(RotationControl rotationControl) {
        this.rotationControl = rotationControl;
    }

    /**
     * @param translationControl the controller that determines the robot's translation (x and y)
     */
    public void setTranslationControl(TranslationControl translationControl) {
        this.translationControl = translationControl;
    }

    /**
     * set both translation and rotation controls at once
     *
     * @param translationControl the controller that determines the robot's translation (x and y)
     * @param rotationControl    the controller that determines the robot's rotation
     */
    public void setControl(TranslationControl translationControl, RotationControl rotationControl) {
        this.translationControl = translationControl;
        this.rotationControl = rotationControl;
    }

    /**
     * set both translation and rotation controls at once
     *
     * @param rotationControl    the controller that determines the robot's rotation
     * @param translationControl the controller that determines the robot's translation (x and y)
     */
    public void setControl(RotationControl rotationControl, TranslationControl translationControl) {
        this.translationControl = translationControl;
        this.rotationControl = rotationControl;
    }

    /**
     * Set both translation and rotation controls to the same object
     *
     * @param xyrControl the controller that determines both the translation and rotation
     */
    public void setControl(XYRControl xyrControl) {
        this.translationControl = xyrControl;
        this.rotationControl = xyrControl;
    }

    /**
     * stop the motors
     */
    public void stop() {
        translationControl = TranslationControls.ZERO;
        rotationControl = RotationControls.ZERO;
        mecanumMotors.stop();
    }

    /**
     * set the drive mode to turn on or off translation normalizing
     *
     * @param mode the drive mode
     */
    public void setDriveMode(MecanumMotors.MecanumDriveMode mode) {
        mecanumMotors.setDriveMode(mode);
    }

    /**
     * update the motor powers based on the output of the translationControl and rotationControl
     */
    public void act() {
        translationWorked = translationControl.act();

        //in case the same object is passed in that implements both controllers
        if (translationControl == rotationControl) {
            rotationWorked = translationWorked;
        } else {
            rotationWorked = rotationControl.act();
        }

        Vector2D translation = translationControl.getTranslation();

        double velocity = translation.getLength();
        double directionRads = translation.getDirection().radians() +
                rotationControl.getPolarDirectionCorrection().radians();

        velocityX = velocity * Math.cos(directionRads);
        velocityY = velocity * Math.sin(directionRads);

        velocityR = rotationControl.getVelocityR();

        mecanumMotors.setVelocityXYR(
                velocityX,
                velocityY,
                velocityR
        );

        mecanumMotors.mecanumDrive();
        mecanumMotors.update();
    }

    /**
     * @return whether or not the translation worked
     */
    public boolean translationWorked() {
        return translationWorked;
    }

    /**
     * @return whether or not the rotation worked
     */
    public boolean rotationWorked() {
        return rotationWorked;
    }

    /**
     * @return the robot's x velocity
     */
    public double getVelocityX() {
        return velocityX;
    }

    /**
     * @return the robot's y velocity
     */
    public double getVelocityY() {
        return velocityY;
    }

    /**
     * @return the robot's rotational velocity
     */
    public double getVelocityR() {
        return velocityR;
    }

    public RotationControl getRotationControl() {
        return rotationControl;
    }

    public TranslationControl getTranslationControl() {
        return translationControl;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>EVLib has its own interface for Analog sensors. It extends <a href="https://github.com/FTC7393/state-machine-framework/wiki/InputExtractor">InputExtractor</a> (from the state-machine-framework) of type Double, which means that every AnalogSensor has to have a method that returns a Double: <code>Double getValue()</code>.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/AnalogSensor.java">ftc/evlib/hardware/sensors/AnalogSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

import ftc.electronvolts.util.InputExtractor;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/11/16
 * 
 * Interface for any type of analog sensor
 * examples: light sensor, distance sensor, potentiometer
 *
 * @see InputExtractor
 * @see Sensors
 */
public interface AnalogSensor extends InputExtractor&lt;Double&gt; {
}
</code></pre>
<p>To create an AnalogSensor from an AnalogInput (which is part of the FTC libraries), you can use the <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/Sensors.java">ftc/evlib/hardware/sensors/Sensors.java</a> factory class:</p>
<pre><code class="language-java">AnalogInput analogInput = hardwareMap.analogInput.get(&quot;lightSensor&quot;);
AnalogSensor lightSensor = Sensors.analog(analogInput);

//To combine on one line:
AnalogSensor lightSensor = Sensors.analog(hardwareMap, &quot;lightSensor&quot;);
</code></pre>
<p>To get the value of a sensor, call the getValue() method:</p>
<pre><code class="language-java">telemetry.addData(&quot;light sensor&quot;, lightSensor.getValue());
</code></pre>
<p>See also: <a href="evlib/DistanceSensor.html">DistanceSensor</a>, <a href="evlib/Digital-Sensors.html">Digital Sensors</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>AveragedSensor takes an <a href="evlib/Analog-Sensors.html">AnalogSensor</a> and averages the last N values to get the current value. The act() method should be called exactly once every time through the loop, but getValue() can be called whenever you need the value. The isReady() method will return true if the sensor is done collecting the first N values. If the sensor is not ready, the value will not be accurate.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/AveragedSensor.java">ftc/evlib/hardware/sensors/AveragedSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/16/16
 * 
 * report the average of the last N values of a sensor as the value
 *
 * @see AnalogSensor
 */
public class AveragedSensor implements AnalogSensor {
    private final AnalogSensor sensor;
    private final double readings[];
    private int index = 0;
    private boolean ready = false;
    private final int numReadings;
    private double average = 0;

    /**
     * @param sensor      the sensor to average
     * @param numReadings the number of readings to average
     */
    public AveragedSensor(AnalogSensor sensor, int numReadings) {
        this.sensor = sensor;
        this.numReadings = numReadings;
        readings = new double[numReadings];
    }

    /**
     * @return true once the first numReadings have been read
     */
    public boolean isReady() {
        return ready;
    }

    @Override
    public Double getValue() {
        return average;
    }

    /**
     * read the sensor and update the average
     */
    public void act() {
        double reading = sensor.getValue();
        readings[index] = reading;
        index++;
        if (index &gt;= numReadings) {
            index = 0;
            ready = true;
        }
        if (ready) {
            average = 0;
            for (int i = 0; i &lt; numReadings; i++) {
                average += readings[i];
            }
            average /= numReadings;
        } else {
            average = reading;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>EVLib has its own interface for Digital sensors. It extends InputExtractor of type Boolean, which means that every DigitalSensor has to have a getValue method that returns a Boolean.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/DigitalSensor.java">ftc/evlib/hardware/sensors/DigitalSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

import ftc.electronvolts.util.InputExtractor;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 * 
 * Interface for any type of digital sensor
 * examples: touch sensor, digital line sensor, magnetic reed switch
 *
 * @see InputExtractor
 * @see Sensors
 */
public interface DigitalSensor extends InputExtractor&lt;Boolean&gt; {
}
</code></pre>
<p>You can create a DigitalSensor from a DigitalChannel or TouchSensor using the <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/Sensors.java">Sensors</a> factory class:</p>
<pre><code class="language-java">DigitalInput digitalInput = hardwareMap.touchSensor.get(&quot;limitSwitch&quot;);
DigitalSensor limitSwitch = Sensors.digitalSensor(digitalInput);

//To combine on one line:
DigitalSensor button = Sensors.digitalSensor(hardwareMap, &quot;button&quot;);
</code></pre>
<p>To get the value of a DigitalSensor, call the getValue() method which returns a Boolean.</p>
<pre><code class="language-java">teletry.addData(&quot;limit switch pressed?&quot;, limitSwitch.getValue());
</code></pre>
<p>See also: <a href="evlib/Analog-Sensors.html">Analog Sensors</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>CalibratedLineSensor takes an <a href="evlib/Analog-Sensors.html">analog</a> line sensor and turns it into a <a href="evlib/Digital-Sensors.html">DigitalSensor</a> by finding a threshold between light and dark. The getValue() method will return true if the sensor sees a line. Note: the act method must be called every loop to update the sensor values for averaging. This class is used in <a href="evlib/DoubleLineSensor.html">DoubleLineSensor</a>.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/CalibratedLineSensor.java">ftc/evlib/hardware/sensors/CalibratedLineSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/8/16
 * 
 * manages threshold calculation for the line sensor
 *
 * @see AnalogSensor
 */
public class CalibratedLineSensor implements DigitalSensor {
    private boolean ready = true;
    private final AnalogSensor lineSensor;
    private static final int NUM_CALIBRATIONS = 100;
    private int numReadings;
    private double average, deviation, threshold = 80;
    private final double readings[] = new double[NUM_CALIBRATIONS];
    private boolean seeingLine = false;
    private double value;

    /**
     * @param lineSensor the raw line sensor
     */
    public CalibratedLineSensor(AnalogSensor lineSensor) {
        this.lineSensor = lineSensor;
    }

    /**
     * start calibrating the sensor
     */
    public void calibrate() {
        ready = false;
        average = 0;
        numReadings = 0;
        deviation = 0;
    }

    /**
     * @return true when done calibrating
     */
    public boolean isReady() {
        return ready;
    }

    /**
     * @return true if the sensor is over the line
     */
    @Override
    public Boolean getValue() {
        return seeingLine;
    }

    /**
     * read the sensor value and use it to calibrate/update the average
     */
    public void act() {
        value = lineSensor.getValue();
        if (!ready) {
            if (numReadings &lt; NUM_CALIBRATIONS) {
                //add a value
                readings[numReadings] = value;
                numReadings++;

                //update the average
                average = (average * (numReadings - 1) + value) / (numReadings);

            } else {
                //find deviation
                for (double reading : readings) {
                    deviation += (reading - average) * (reading - average);
                }
                deviation /= Math.sqrt(numReadings);

                threshold = (average - deviation) * (average - deviation) / average;
                ready = true;
            }
        }
        seeingLine = value &lt; threshold;
    }

    /**
     * @return the raw value of the line sensor
     */
    public double getRawValue() {
        return value;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>This takes two <a href="evlib/CalibratedLineSensor.html">CalibratedLineSensor</a> objects and combines them. It reports the robot's position relative to the line. It is used in <a href="evlib/LineFinder.html">LineFinder</a> along with a <a href="evlib/ColorSensor.html">ColorSensor</a> to find different colored lines.</p>
<p>It is be used in <a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/control/TranslationControls.java">ftc/evlib/hardware/control/TranslationControls.java</a> to do line following. See: <a href="evlib/Mecanum-Control.html">Mecanum Control</a></p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/DoubleLineSensor.java">ftc/evlib/hardware/sensors/DoubleLineSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/8/16
 * 
 * Manages two line sensors to tell where the robot is relative to the line
 *
 * @see CalibratedLineSensor
 * @see DigitalSensor
 */
public class DoubleLineSensor implements DigitalSensor {

    public enum LinePosition {
        LEFT,
        MIDDLE,
        RIGHT,
        OFF_UNKNOWN,
        OFF_LEFT,
        OFF_RIGHT
    }

    private LinePosition position = LinePosition.OFF_UNKNOWN;

    private final CalibratedLineSensor leftSensor, rightSensor;

    public DoubleLineSensor(AnalogSensor leftSensor, AnalogSensor rightSensor) {
        this.leftSensor = new CalibratedLineSensor(leftSensor);
        this.rightSensor = new CalibratedLineSensor(rightSensor);
    }

    public void calibrate() {
        leftSensor.calibrate();
        rightSensor.calibrate();
    }

    public boolean isReady() {
        return leftSensor.isReady() &amp;&amp; rightSensor.isReady();
    }

    public LinePosition getPosition() {
        return position;
    }

    public void reset() {
        position = LinePosition.MIDDLE;
    }

    /**
     * @return true if either sensor is on the line
     */
    @Override
    public Boolean getValue() {
        return leftSensor.getValue() || rightSensor.getValue();
    }

    /**
     * determine where the robot is relative to the line
     */
    public void act() {
        leftSensor.act();
        rightSensor.act();

        if (leftSensor.getValue()) {
            if (rightSensor.getValue()) {
                position = LinePosition.MIDDLE;
            } else {
                position = LinePosition.LEFT;
            }
        } else {
            if (rightSensor.getValue()) {
                position = LinePosition.RIGHT;
            } else {
                //if neither sensor detects the line, the position is determined by the previous position
                if (position == LinePosition.LEFT) {
                    position = LinePosition.OFF_LEFT;
                } else if (position == LinePosition.RIGHT) {
                    position = LinePosition.OFF_RIGHT;
                } else {
                    position = LinePosition.OFF_UNKNOWN;
                }
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ColorSensor uses a red LED, a blue LED, and a photoresistor to detect the color of a line on the mat. It has 4 methods for setting the color: red, blue, magenta, and off. It implements <a href="evlib/Digital-Sensors.html">DigitalSensor</a>, returning whether or not it is seeing the color specified. It is used in <a href="evlib/LineFinder.html">LineFinder</a> along with <a href="evlib/DoubleLineSensor.html">DoubleLineSensor</a> to more accurately find colored lines.</p>
<p>Fun fact: last year when connecting LEDs, we guessed on the resistor values and it burnt out 2 of our digital outputs. Always calculate the current before you plug LEDs in to the Core Device Interface Module.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/ColorSensor.java">ftc/evlib/hardware/sensors/ColorSensor.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;

import com.qualcomm.robotcore.hardware.LED;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 3/22/16
 * 
 * Uses LEDs and a photoresistor to detect the color of a line on the mat
 * 
 * --- light red blue
 * mat    35 250 250
 * red
 * blue
 * white 145 640 550
 *
 * @see DigitalSensor
 */
public class ColorSensor implements DigitalSensor {
    private static final int THRESHOLD = 500;
    private final LED redLight, blueLight;
    private final AveragedSensor lightSensor;
    private String ledColorString = &quot;unknown&quot;;

    /**
     * @param redLight    the red LED
     * @param blueLight   the blue LED
     * @param lightSensor the photoresistor
     */
    public ColorSensor(LED redLight, LED blueLight, AveragedSensor lightSensor) {
        this.redLight = redLight;
        this.blueLight = blueLight;
        this.lightSensor = lightSensor;
    }

    /**
     * turn off both LEDs
     */
    public void turnOff() {
        redLight.enable(true);
        blueLight.enable(true);
        ledColorString = &quot;blank&quot;;
    }

    /**
     * turn on the red LED and turn off the blue LED
     */
    public void setColorRed() {
        redLight.enable(false);
        blueLight.enable(true);
        ledColorString = &quot;red&quot;;
    }

    /**
     * turn on the blue LED and turn off the red LED
     */
    public void setColorBlue() {
        redLight.enable(true);
        blueLight.enable(false);
        ledColorString = &quot;blue&quot;;
    }

    /**
     * turn on both LEDs
     */
    public void setColorMagenta() {
        redLight.enable(false);
        blueLight.enable(false);
        ledColorString = &quot;magenta&quot;;
    }

    /**
     * @return the name of the current color for telemetry purposes
     */
    public String getLedColorString() {
        return ledColorString;
    }

    /**
     * update the light sensor
     */
    public void act() {
        lightSensor.act();
    }

    /**
     * @return true if it is seeing the color requested
     */
    @Override
    public Boolean getValue() {
        return lightSensor.getValue() &gt; THRESHOLD;
    }

    /**
     * @return the raw value of the light sensor
     */
    public double getRawValue() {
        return lightSensor.getValue();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>LineFinder uses a <a href="evlib/DoubleLineSensor.html">DoubleLineSensor</a> and a <a href="evlib/ColorSensor.html">ColorSensor</a> to find lines of different colors. You use it by setting the color you are looking for, then calling getValue() to see if it is seeing the line color you requested.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/hardware/sensors/LineFinder.java">ftc/evlib/hardware/sensors/LineFinder.java</a></p>
<pre><code class="language-java">package ftc.evlib.hardware.sensors;


import static ftc.evlib.driverstation.Telem.telemetry;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 4/10/16
 * 
 * Combines two line sensors and an LED-powered color sensor to detect the color of lines
 *
 * @see ColorSensor
 * @see DoubleLineSensor
 */
public class LineFinder implements DigitalSensor {
    public enum LineColor {
        RED,
        BLUE,
        WHITE_RED_TEAM,
        WHITE_BLUE_TEAM
    }

    private final ColorSensor colorSensor;
    private final DoubleLineSensor doubleLineSensor;
    private LineColor lookingFor = LineColor.WHITE_RED_TEAM;
    private boolean justStarted = true;


    public LineFinder(ColorSensor colorSensor, DoubleLineSensor doubleLineSensor) {
        this.colorSensor = colorSensor;
        this.doubleLineSensor = doubleLineSensor;
    }

    /**
     * start looking for a line of a certain color by turning the LEDs to a certain color
     *
     * @param lineColor the color of the line to look for
     */
    public void startLookingFor(LineColor lineColor) {
        lookingFor = lineColor;
        justStarted = true;
        if (lookingFor == LineColor.RED) {
            colorSensor.setColorBlue();
        } else if (lookingFor == LineColor.BLUE) {
            colorSensor.setColorRed();
        } else if (lookingFor == LineColor.WHITE_RED_TEAM) {
            colorSensor.setColorBlue();
        } else if (lookingFor == LineColor.WHITE_BLUE_TEAM) {
            colorSensor.setColorRed();
        }
    }

    /**
     * note: it skips the first loop because the LEDs take 1 loop to turn on
     *
     * @return true if the line of the requested color was found
     */
    @Override
    public Boolean getValue() {
        if (justStarted) {
            justStarted = false;
            telemetry.addData(&quot;Just started line finder&quot;, &quot;&quot;);
        } else {
            if (lookingFor == LineColor.RED) {
                return doubleLineSensor.getValue() &amp;&amp; !colorSensor.getValue();
            } else if (lookingFor == LineColor.BLUE) {
                return doubleLineSensor.getValue() &amp;&amp; !colorSensor.getValue();
            } else if (lookingFor == LineColor.WHITE_RED_TEAM) {
                return doubleLineSensor.getValue() &amp;&amp; colorSensor.getValue();
            } else if (lookingFor == LineColor.WHITE_BLUE_TEAM) {
                return doubleLineSensor.getValue() &amp;&amp; colorSensor.getValue();
            }
        }
        return false;
    }

    public void act() {
        doubleLineSensor.act();
        colorSensor.act();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>The GamepadManager adds edge detection to all the gamepad buttons and analog scaling to the joysticks and left/right triggers.</p>
<p>You can use it by first creating a new GamepadManager. You have to pass in the gamepad and a Function to scale the analog values with.</p>
<pre><code class="language-java">driver1 = new GamepadManager(gamepad1, Functions.squared());
</code></pre>
<p>Then to use it, for example to tell if button &quot;a&quot; has just been pressed:</p>
<pre><code class="language-java">if (driver1.a.justPressed()){
    //do something
}
</code></pre>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/driverstation/GamepadManager.java">java/ftc/evlib/driverstation/GamepadManager.java</a></p>
<pre><code class="language-java">package ftc.evlib.driverstation;

import com.qualcomm.robotcore.hardware.Gamepad;

import ftc.electronvolts.util.AnalogInputScaler;
import ftc.electronvolts.util.DigitalInputEdgeDetector;
import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 1/9/16
 * 
 * This class wraps a gamepad and adds:
 * Edge detection to the digital inputs (buttons and dpad) {@see DigitalInputEdgeDetector}
 * Scaling to the analog inputs (joysticks and triggers) {@see AnalogInputScaler}
 */
public class GamepadManager {
    //this stores all the wrapped digital inputs
    public final DigitalInputEdgeDetector a, b, x, y, left_bumper, right_bumper,
            dpad_up, dpad_down, dpad_left, dpad_right,
            left_stick_button, right_stick_button, back, start;

    //this stores all the wrapped analog inputs
    public final AnalogInputScaler left_stick_x, left_stick_y, right_stick_x, right_stick_y,
            left_trigger, right_trigger;


    //use this constructor for no joystick scaling
    public GamepadManager(Gamepad gamepad) {
        this(gamepad, Functions.none());
    }

    //use this constructor for custom joystick scaling
    public GamepadManager(Gamepad gamepad, Function scalingFunction) {
        //create all the DigitalInputEdgeDetector objects
        a = new DigitalInputEdgeDetector(GamepadIEFactory.a(gamepad));
        b = new DigitalInputEdgeDetector(GamepadIEFactory.b(gamepad));
        x = new DigitalInputEdgeDetector(GamepadIEFactory.x(gamepad));
        y = new DigitalInputEdgeDetector(GamepadIEFactory.y(gamepad));
        left_bumper = new DigitalInputEdgeDetector(GamepadIEFactory.left_bumper(gamepad));
        right_bumper = new DigitalInputEdgeDetector(GamepadIEFactory.right_bumper(gamepad));
        dpad_up = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_up(gamepad));
        dpad_down = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_down(gamepad));
        dpad_left = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_left(gamepad));
        dpad_right = new DigitalInputEdgeDetector(GamepadIEFactory.dpad_right(gamepad));
        left_stick_button = new DigitalInputEdgeDetector(GamepadIEFactory.left_stick_button(gamepad));
        right_stick_button = new DigitalInputEdgeDetector(GamepadIEFactory.right_stick_button(gamepad));
        back = new DigitalInputEdgeDetector(GamepadIEFactory.back(gamepad));
        start = new DigitalInputEdgeDetector(GamepadIEFactory.start(gamepad));

        //create all the AnalogInputScaler objects
        left_stick_x = new AnalogInputScaler(GamepadIEFactory.left_stick_x(gamepad), scalingFunction);
        left_stick_y = new AnalogInputScaler(GamepadIEFactory.left_stick_y(gamepad), scalingFunction);
        right_stick_x = new AnalogInputScaler(GamepadIEFactory.right_stick_x(gamepad), scalingFunction);
        right_stick_y = new AnalogInputScaler(GamepadIEFactory.right_stick_y(gamepad), scalingFunction);
        left_trigger = new AnalogInputScaler(GamepadIEFactory.left_trigger(gamepad), scalingFunction);
        right_trigger = new AnalogInputScaler(GamepadIEFactory.right_trigger(gamepad), scalingFunction);
    }

    public void update() {
        //update all the values
        a.update();
        b.update();
        x.update();
        y.update();

        left_bumper.update();
        right_bumper.update();

        left_trigger.update();
        right_trigger.update();

        dpad_up.update();
        dpad_down.update();
        dpad_left.update();
        dpad_right.update();

        left_stick_button.update();
        right_stick_button.update();

        back.update();
        start.update();

        left_stick_x.update();
        left_stick_y.update();

        right_stick_x.update();
        right_stick_y.update();


        /*telemetry.addData(&quot;a&quot;, a.isPressed());
        telemetry.addData(&quot;b&quot;, b.isPressed());
        telemetry.addData(&quot;x&quot;, x.isPressed());
        telemetry.addData(&quot;y&quot;, y.isPressed());
        telemetry.addData(&quot;LB&quot;, left_bumper.isPressed());
        telemetry.addData(&quot;RB&quot;, right_bumper.isPressed());
        telemetry.addData(&quot;DU&quot;, dpad_up.isPressed());
        telemetry.addData(&quot;DD&quot;, dpad_down.isPressed());
        telemetry.addData(&quot;DL&quot;, dpad_left.isPressed());
        telemetry.addData(&quot;DR&quot;, dpad_right.isPressed());
        telemetry.addData(&quot;LSB&quot;, left_stick_button.isPressed());
        telemetry.addData(&quot;RSB&quot;, right_stick_button.isPressed());
        telemetry.addData(&quot;Back&quot;, back.isPressed());
        telemetry.addData(&quot;Start&quot;, start.isPressed());

        telemetry.addData(&quot;Left X&quot;, left_stick_x.isPressed());
        telemetry.addData(&quot;Left Y&quot;, left_stick_y.isPressed());
        telemetry.addData(&quot;Right X&quot;, right_stick_x.isPressed());
        telemetry.addData(&quot;Right Y&quot;, right_stick_y.isPressed());
        telemetry.addData(&quot;Left Trigger&quot;, left_trigger.isPressed());
        telemetry.addData(&quot;Right Trigger&quot;, right_trigger.isPressed());
        */
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>Angle</strong> | <a href="state_machine_framework/Distance.html">Distance</a> | <a href="state_machine_framework/Time.html">Time</a> | <a href="state_machine_framework/Velocity.html">Velocity</a> | <a href="state_machine_framework/AngularVelocity.html">AngularVelocity</a></p>
<hr />
<p><strong>Units: radians, degrees, rotations</strong></p>
<p>The Angle class stores an angle. It can be created from any of the units above, and you can get the value from it in any of the units above. Once the Angle is created, the value cannot be changed.</p>
<p>Angle has a few math functions: abs (absolute value), signum (returns the sign), add, subtract, multiply, and divide.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/units/Angle.java">ftc/electronvolts/util/units/Angle.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.units;


/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 2/2/16
 */
public class Angle {
    /*
     * Constants to relate various units to radians
     * The reciprocal of each constant is calculated once to be used multiple
     * times later
     */
    private static double RAD_PER_DEG = Math.PI / 180;
    private static double RAD_PER_ROT = 2 * Math.PI;

    private static double DEG_PER_RAD = 1 / RAD_PER_DEG;
    private static double ROT_PER_RAD = 1 / RAD_PER_ROT;
    
    private static Angle zero = new Angle(0);

    // holds the angle's value in radians
    private final double radians;

    /**
     * private constructor to make an Angle object from a value in radians
     *
     * @param radians the angle's value in radians
     */
    private Angle(double radians) {
        this.radians = radians;
    }

    /**
     * 
     * @return the absolute value of the angle
     */
    public Angle abs() {
        return new Angle(Math.abs(radians));
    }

    /**
     * 
     * @return the sign of the angle
     */
    public double signum() {
        return Math.signum(radians);
    }

    /**
     * Adds two Angles together
     *
     * @param angle1 one Angle
     * @param angle2 another Angle
     * @return the resulting Angle
     */
    public static Angle add(Angle angle1, Angle angle2) {
        return new Angle(angle1.radians + angle2.radians);
    }

    /**
     * Subtracts angle2 from angle1
     * 
     * @param angle1 one Angle
     * @param angle2 another Angle
     * @return the resulting Angle
     */
    public static Angle subtract(Angle angle1, Angle angle2) {
        return new Angle(angle1.radians - angle2.radians);
    }

    /**
     * Multiplies an Angle by a number
     * 
     * @param angle the Angle to be multiplied
     * @param number the number to multiply by
     * @return the resulting Angle
     */
    public static Angle multiply(Angle angle, double number) {
        return new Angle(angle.radians * number);
    }

    /**
     * Divides an Angle by a number
     * 
     * @param angle the Angle to be multiplied
     * @param number the number to divided by
     * @return the resulting Angle
     */
    public static Angle divide(Angle angle, double number) {
        return new Angle(angle.radians / number);
    }

    /**
     * Creates an Angle that has a value of 0 (in all units)
     * 
     * @return the created Angle
     */
    public static Angle zero() {
        return zero;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(radians);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        Angle other = (Angle) obj;
        if (Double.doubleToLongBits(radians) != Double.doubleToLongBits(other.radians)) return false;
        return true;
    }

    /**
     * Creates an Angle class from a value in radians
     *
     * @param v the value in radians
     * @return the Angle class
     */
    public static Angle fromRadians(double v) {
        return new Angle(v);
    }

    /**
     * Creates an Angle class from a value in degrees
     *
     * @param v the value in degrees
     * @return the Angle class
     */
    public static Angle fromDegrees(double v) {
        return new Angle(v * RAD_PER_DEG);
    }

    /**
     * Creates an Angle class from a value in rotations
     *
     * @param v the value in rotations
     * @return the Angle class
     */
    public static Angle fromRotations(double v) {
        return new Angle(v * RAD_PER_ROT);
    }

    /**
     * 
     * @return the value of the Angle in radians
     */
    public double radians() {
        return radians;
    }

    /**
     * 
     * @return the value of the Angle in degrees
     */
    public double degrees() {
        return radians * DEG_PER_RAD;
    }

    /**
     * 
     * @return the value of the Angle in rotations
     */
    public double rotations() {
        return radians * ROT_PER_RAD;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="state_machine_framework/Angle.html">Angle</a> | <strong>Distance</strong> | <a href="state_machine_framework/Time.html">Time</a> | <a href="state_machine_framework/Velocity.html">Velocity</a> | <a href="state_machine_framework/AngularVelocity.html">AngularVelocity</a></p>
<hr />
<p><strong>Units: meters, (kilo|centi|milli|micro|nano)meters, feet, inches, yards, miles, nautical miles</strong></p>
<p>The Distance class stores an amount of distance. It can be created from any of the units above, and you can get the value from it in any of the units above. Once the Distance is created, the value cannot be changed.</p>
<p>Distance has a few math functions: abs (absolute value), signum (returns the sign), add, subtract, multiply, and divide.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/units/Distance.java">ftc/electronvolts/util/units/Distance.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.units;


/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/4/16
 */

public class Distance {
    /*
     * Constants to relate various units to meters
     * The reciprocal of each constant is calculated once to be used multiple
     * times later
     */
    private static final double M_PER_KM = 1e+3;
    private static final double M_PER_CM = 1e-2;
    private static final double M_PER_MM = 1e-3;
    private static final double M_PER_UM = 1e-6;
    private static final double M_PER_NM = 1e-9;
    private static final double M_PER_FT = 0.3048;
    private static final double M_PER_IN = 0.0254;
    private static final double M_PER_YD = 0.9144;
    private static final double M_PER_MI = 1609.344;
    private static final double M_PER_NAUT_MI = 1852;

    private static final double KM_PER_M = 1 / M_PER_KM;
    private static final double CM_PER_M = 1 / M_PER_CM;
    private static final double MM_PER_M = 1 / M_PER_MM;
    private static final double UM_PER_M = 1 / M_PER_UM;
    private static final double NM_PER_M = 1 / M_PER_NM;
    private static final double FT_PER_M = 1 / M_PER_FT;
    private static final double IN_PER_M = 1 / M_PER_IN;
    private static final double YD_PER_M = 1 / M_PER_YD;
    private static final double MI_PER_M = 1 / M_PER_MI;
    private static final double NAUT_MI_PER_M = 1 / M_PER_NAUT_MI;
    
    private static final Distance zero = new Distance(0);

    // The distance in meters
    private final double meters;

    /**
     * Private constructor to create a Distance object from meters
     * 
     * @param meters the number of meters
     */
    private Distance(double meters) {
        this.meters = meters;
    }

    /**
     * 
     * @return the absolute value of the distance
     */
    public Distance abs() {
        return new Distance(Math.abs(meters));
    }

    /**
     * 
     * @return the sign of the distance
     */
    public double signum() {
        return Math.signum(meters);
    }

    /**
     * Adds two Distances together
     * 
     * @param distance1 the first Distance
     * @param distance2 the second Distance
     * @return the resulting Distance
     */
    public static Distance add(Distance distance1, Distance distance2) {
        return new Distance(distance1.meters + distance2.meters);
    }

    /**
     * Subtracts distance2 from distance1
     * 
     * @param distance1 the first Distance
     * @param distance2 the second Distance
     * @return the resulting Distance
     */
    public static Distance subtract(Distance distance1, Distance distance2) {
        return new Distance(distance1.meters - distance2.meters);
    }

    /**
     * Multiplies a Distance by a number
     * 
     * @param distance the Distance
     * @param number the number to multiply by
     * @return the resulting Distance
     */
    public static Distance multiply(Distance distance, double number) {
        return new Distance(distance.meters * number);
    }

    /**
     * Divides a Distance by a number
     * 
     * @param distance the Distance
     * @param number the number to divide by
     * @return the resulting Distance
     */
    public static Distance divide(Distance distance, double number) {
        return new Distance(distance.meters / number);
    }

    /**
     * Create a Distance that has a value of 0
     * 
     * @return the created Distance
     */
    public static Distance zero() {
        return zero;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(meters);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        Distance other = (Distance) obj;
        if (Double.doubleToLongBits(meters) != Double.doubleToLongBits(other.meters)) return false;
        return true;
    }

    // Create Distance objects from various units
    public static Distance fromMeters(double v) {
        return new Distance(v);
    }

    public static Distance fromKilometers(double v) {
        return new Distance(v * M_PER_KM);
    }

    public static Distance fromCentimeters(double v) {
        return new Distance(v * M_PER_CM);
    }

    public static Distance fromMillimeters(double v) {
        return new Distance(v * M_PER_MM);
    }

    public static Distance fromMicrometers(double v) {
        return new Distance(v * M_PER_UM);
    }

    public static Distance fromNanoMeters(double v) {
        return new Distance(v * M_PER_NM);
    }

    public static Distance fromFeet(double v) {
        return new Distance(v * M_PER_FT);
    }

    public static Distance fromInches(double v) {
        return new Distance(v * M_PER_IN);
    }

    public static Distance fromYards(double v) {
        return new Distance(v * M_PER_YD);
    }

    public static Distance fromMiles(double v) {
        return new Distance(v * M_PER_MI);
    }

    public static Distance fromNauticalMiles(double v) {
        return new Distance(v * M_PER_NAUT_MI);
    }

    // get distance in various units
    public double meters() {
        return meters;
    }

    public double kilometers() {
        return meters * KM_PER_M;
    }

    public double centimeters() {
        return meters * CM_PER_M;
    }

    public double millimeters() {
        return meters * MM_PER_M;
    }

    public double micrometers() {
        return meters * UM_PER_M;
    }

    public double nanometers() {
        return meters * NM_PER_M;
    }

    public double feet() {
        return meters * FT_PER_M;
    }

    public double inches() {
        return meters * IN_PER_M;
    }

    public double yards() {
        return meters * YD_PER_M;
    }

    public double miles() {
        return meters * MI_PER_M;
    }

    public double nauticalMiles() {
        return meters * NAUT_MI_PER_M;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="state_machine_framework/Angle.html">Angle</a> | <a href="state_machine_framework/Distance.html">Distance</a> | <strong>Time</strong> | <a href="state_machine_framework/Velocity.html">Velocity</a> | <a href="state_machine_framework/AngularVelocity.html">AngularVelocity</a></p>
<hr />
<p><strong>Units: seconds, (nano|micro|milli)seconds, minutes, hours, days, weeks, months, years</strong></p>
<p>The Time class stores an amount of Time. It can be created from any of the units above, and you can get the value from it in any of the units above. Once the Time is created, the value cannot be changed.</p>
<p>Time has a few math functions: abs (absolute value), signum (returns the sign), add, subtract, multiply, and divide.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/units/Time.java">ftc/electronvolts/util/units/Time.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.units;


/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/5/16
 */

public class Time {
    /*
     * Constants to relate various units to seconds
     * The reciprocal of each constant is calculated once to be used multiple
     * times later
     */
    private static final double S_PER_NS = 1e-9;
    private static final double S_PER_US = 1e-6;
    private static final double S_PER_MS = 0.001;
    private static final double S_PER_MIN = 60;
    private static final double S_PER_HR = 3600;
    private static final double S_PER_DAY = 86400;
    private static final double S_PER_WEEK = 604800;
    private static final double S_PER_MONTH = 2.628e+6;
    private static final double S_PER_YEAR = 3.154e+7;

    private static final double NS_PER_S = 1 / S_PER_NS;
    private static final double US_PER_S = 1 / S_PER_US;
    private static final double MS_PER_S = 1 / S_PER_MS;
    private static final double MIN_PER_S = 1 / S_PER_MIN;
    private static final double HR_PER_S = 1 / S_PER_HR;
    private static final double DAY_PER_S = 1 / S_PER_DAY;
    private static final double WEEK_PER_S = 1 / S_PER_WEEK;
    private static final double MONTH_PER_S = 1 / S_PER_MONTH;
    private static final double YEAR_PER_S = 1 / S_PER_YEAR;

    private static final Time zero = new Time(0);

    // The time in seconds
    private final double seconds;

    /**
     * private constructor to create a Time object from a value in seconds
     * 
     * @param seconds the time in seconds
     */
    private Time(double seconds) {
        this.seconds = seconds;
    }

    /**
     * 
     * @return the absolute value of the time
     */
    public Time abs() {
        return new Time(Math.abs(seconds));
    }

    /**
     * 
     * @return the sign of the angle
     */
    public double signum() {
        return Math.signum(seconds);
    }

    /**
     * Adds two Times together
     * 
     * @param time1 the first Time object
     * @param time2 the second Time object
     * @return the resulting Time
     */
    public static Time add(Time time1, Time time2) {
        return new Time(time1.seconds + time2.seconds);
    }

    /**
     * Subtracts time2 from time1
     * 
     * @param time1 the first Time object
     * @param time2 the second Time object
     * @return the resulting Time
     */
    public static Time subtract(Time time1, Time time2) {
        return new Time(time1.seconds - time2.seconds);
    }

    /**
     * Multiplies a Time object by a number
     * 
     * @param time the Time object
     * @param number the number to multiply by
     * @return the resulting Time
     */
    public static Time multiply(Time time, double number) {
        return new Time(time.seconds * number);
    }

    /**
     * Divides a Time object by a number
     * 
     * @param time the Time object
     * @param number the number to divide by
     * @return the resulting Time
     */
    public static Time divide(Time time, double number) {
        return new Time(time.seconds / number);
    }

    /**
     * Create a Time that has a value of 0
     * 
     * @return the created Time
     */
    public static Time zero() {
        return zero;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(seconds);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        Time other = (Time) obj;
        if (Double.doubleToLongBits(seconds) != Double.doubleToLongBits(other.seconds)) return false;
        return true;
    }

    // create Time objects from various units
    public static Time fromSeconds(double v) {
        return new Time(v);
    }

    public static Time fromNanoseconds(double v) {
        return new Time(v * S_PER_NS);
    }

    public static Time fromMicroseconds(double v) {
        return new Time(v * S_PER_US);
    }

    public static Time fromMilliseconds(double v) {
        return new Time(v * S_PER_MS);
    }

    public static Time fromMinutes(double v) {
        return new Time(v * S_PER_MIN);
    }

    public static Time fromHours(double v) {
        return new Time(v * S_PER_HR);
    }

    public static Time fromDays(double v) {
        return new Time(v * S_PER_DAY);
    }

    public static Time fromWeeks(double v) {
        return new Time(v * S_PER_WEEK);
    }

    public static Time fromMonths(double v) {
        return new Time(v * S_PER_MONTH);
    }

    public static Time fromYears(double v) {
        return new Time(v * S_PER_YEAR);
    }

    // get time in various units
    public double seconds() {
        return seconds;
    }

    public double nanoseconds() {
        return seconds * NS_PER_S;
    }

    public double microseconds() {
        return seconds * US_PER_S;
    }

    public double milliseconds() {
        return seconds * MS_PER_S;
    }

    public double minutes() {
        return seconds * MIN_PER_S;
    }

    public double hours() {
        return seconds * HR_PER_S;
    }

    public double days() {
        return seconds * DAY_PER_S;
    }

    public double weeks() {
        return seconds * WEEK_PER_S;
    }

    public double months() {
        return seconds * MONTH_PER_S;
    }

    public double years() {
        return seconds * YEAR_PER_S;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="state_machine_framework/Angle.html">Angle</a> | <a href="state_machine_framework/Distance.html">Distance</a> | <a href="state_machine_framework/Time.html">Time</a> | <strong>Velocity</strong> | <a href="state_machine_framework/AngularVelocity.html">AngularVelocity</a></p>
<hr />
<p><strong>Units: meters, (kilo|centi|milli|micro|nano)meters, feet, inches, yards, miles, nautical miles <em>PER</em> second, (nano|micro|milli)second, minute, hour, day, week, month, year</strong></p>
<p>The Velocity class stores an amount of velocity. It can be created from a <a href="state_machine_framework/Distance.html">Distance</a> class and a <a href="state_machine_framework/Time.html">Time</a> class, and you can get the value from it in any of the units above. Once the Velocity is created, the value cannot be changed.</p>
<p>Velocity has a few math functions: abs (absolute value), signum (returns the sign), add, subtract, multiply, and divide.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/units/Velocity.java">ftc/electronvolts/util/units/Velocity.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.units;


/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/5/16
 */

public class Velocity {
    private static final Velocity zero = new Velocity(Distance.zero());
    
    private final Distance distance;
    private final Time time;

    /**
     * Distance per Time
     * 
     * @param distance the Distance object
     * @param time the Time object
     */
    public Velocity(Distance distance, Time time) {
        this.distance = distance;
        this.time = time;
    }

    /**
     * Distance per 1 second
     * 
     * @param distance the Distance object
     */
    private Velocity(Distance distance) {
        this(distance, Time.fromSeconds(1));
    }

    /**
     * @return a Velocity with a value of 0
     */
    public static Velocity zero() {
        return zero;
    }

    public Distance getDistance(Time time) {
        // distance = velocity * time
        return Distance.fromMeters(metersPerSecond() * time.seconds());
    }

    public Time getTime(Distance distance) {
        // time = distance / velocity
        return Time.fromSeconds(distance.meters() / metersPerSecond());
    }

    public AngularVelocity getAngularVelocity(Distance radius) {
        //angular velocity = velocity / radius
        return new AngularVelocity(Angle.fromRadians(metersPerSecond() / radius.meters()), Time.fromSeconds(1));
    }

    public Velocity abs() {
        return new Velocity(distance.abs(), time.abs());
    }

    public double signum() {
        return Math.signum(metersPerSecond());
    }

    /**
     * Adds two Velocities together
     * 
     * @param velocity1 the first Velocity
     * @param velocity2 the second Velocity
     * @return the resulting Velocity
     */
    public static Velocity add(Velocity velocity1, Velocity velocity2) {
        return new Velocity(Distance.fromMeters(velocity1.metersPerSecond() + velocity2.metersPerSecond()));
    }

    /**
     * Subtracts velocity2 from velocity1
     * 
     * @param velocity1 the first Velocity
     * @param velocity2 the second Velocity
     * @return the resulting Velocity
     */
    public static Velocity subtract(Velocity velocity1, Velocity velocity2) {
        return new Velocity(Distance.fromMeters(velocity1.metersPerSecond() - velocity2.metersPerSecond()));
    }

    /**
     * Multiplies a Velocity by a number
     * 
     * @param velocity the Velocity
     * @param number the number to multiply by
     * @return the resulting Velocity
     */
    public static Velocity multiply(Velocity velocity, double number) {
        return new Velocity(Distance.fromMeters(velocity.metersPerSecond() * number));
    }

    /**
     * Divides a Velocity by a number
     * 
     * @param velocity the Velocity
     * @param number the number to divide by
     * @return the resulting Velocity
     */
    public static Velocity divide(Velocity velocity, double number) {
        return new Velocity(Distance.fromMeters(velocity.metersPerSecond() * number));
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(metersPerSecond());
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        Velocity other = (Velocity) obj;
        if (Double.doubleToLongBits(metersPerSecond()) != Double.doubleToLongBits(other.metersPerSecond())) return false;
        return true;
    }

    // get velocity in various units
    public double metersPerNanosecond() {
        return distance.meters() / time.nanoseconds();
    }

    public double metersPerMicrosecond() {
        return distance.meters() / time.microseconds();
    }

    public double metersPerMillisecond() {
        return distance.meters() / time.milliseconds();
    }

    public double metersPerSecond() {
        return distance.meters() / time.seconds();
    }

    public double metersPerMinute() {
        return distance.meters() / time.minutes();
    }

    public double metersPerHour() {
        return distance.meters() / time.hours();
    }

    public double metersPerDay() {
        return distance.meters() / time.days();
    }

    public double metersPerWeek() {
        return distance.meters() / time.weeks();
    }

    public double metersPerMonth() {
        return distance.meters() / time.months();
    }

    public double metersPerYear() {
        return distance.meters() / time.years();
    }

    public double kilometersPerNanosecond() {
        return distance.kilometers() / time.nanoseconds();
    }

    public double kilometersPerMicrosecond() {
        return distance.kilometers() / time.microseconds();
    }

    public double kilometersPerMillisecond() {
        return distance.kilometers() / time.milliseconds();
    }

    public double kilometersPerSecond() {
        return distance.kilometers() / time.seconds();
    }

    public double kilometersPerMinute() {
        return distance.kilometers() / time.minutes();
    }

    public double kilometersPerHour() {
        return distance.kilometers() / time.hours();
    }

    public double kilometersPerDay() {
        return distance.kilometers() / time.days();
    }

    public double kilometersPerWeek() {
        return distance.kilometers() / time.weeks();
    }

    public double kilometersPerMonth() {
        return distance.kilometers() / time.months();
    }

    public double kilometersPerYear() {
        return distance.kilometers() / time.years();
    }

    public double centimetersPerNanosecond() {
        return distance.centimeters() / time.nanoseconds();
    }

    public double centimetersPerMicrosecond() {
        return distance.centimeters() / time.microseconds();
    }

    public double centimetersPerMillisecond() {
        return distance.centimeters() / time.milliseconds();
    }

    public double centimetersPerSecond() {
        return distance.centimeters() / time.seconds();
    }

    public double centimetersPerMinute() {
        return distance.centimeters() / time.minutes();
    }

    public double centimetersPerHour() {
        return distance.centimeters() / time.hours();
    }

    public double centimetersPerDay() {
        return distance.centimeters() / time.days();
    }

    public double centimetersPerWeek() {
        return distance.centimeters() / time.weeks();
    }

    public double centimetersPerMonth() {
        return distance.centimeters() / time.months();
    }

    public double centimetersPerYear() {
        return distance.centimeters() / time.years();
    }

    public double millimetersPerNanosecond() {
        return distance.millimeters() / time.nanoseconds();
    }

    public double millimetersPerMicrosecond() {
        return distance.millimeters() / time.microseconds();
    }

    public double millimetersPerMillisecond() {
        return distance.millimeters() / time.milliseconds();
    }

    public double millimetersPerSecond() {
        return distance.millimeters() / time.seconds();
    }

    public double millimetersPerMinute() {
        return distance.millimeters() / time.minutes();
    }

    public double millimetersPerHour() {
        return distance.millimeters() / time.hours();
    }

    public double millimetersPerDay() {
        return distance.millimeters() / time.days();
    }

    public double millimetersPerWeek() {
        return distance.millimeters() / time.weeks();
    }

    public double millimetersPerMonth() {
        return distance.millimeters() / time.months();
    }

    public double millimetersPerYear() {
        return distance.millimeters() / time.years();
    }

    public double micrometersPerNanosecond() {
        return distance.micrometers() / time.nanoseconds();
    }

    public double micrometersPerMicrosecond() {
        return distance.micrometers() / time.microseconds();
    }

    public double micrometersPerMillisecond() {
        return distance.micrometers() / time.milliseconds();
    }

    public double micrometersPerSecond() {
        return distance.micrometers() / time.seconds();
    }

    public double micrometersPerMinute() {
        return distance.micrometers() / time.minutes();
    }

    public double micrometersPerHour() {
        return distance.micrometers() / time.hours();
    }

    public double micrometersPerDay() {
        return distance.micrometers() / time.days();
    }

    public double micrometersPerWeek() {
        return distance.micrometers() / time.weeks();
    }

    public double micrometersPerMonth() {
        return distance.micrometers() / time.months();
    }

    public double micrometersPerYear() {
        return distance.micrometers() / time.years();
    }

    public double nanometersPerNanosecond() {
        return distance.nanometers() / time.nanoseconds();
    }

    public double nanometersPerMicrosecond() {
        return distance.nanometers() / time.microseconds();
    }

    public double nanometersPerMillisecond() {
        return distance.nanometers() / time.milliseconds();
    }

    public double nanometersPerSecond() {
        return distance.nanometers() / time.seconds();
    }

    public double nanometersPerMinute() {
        return distance.nanometers() / time.minutes();
    }

    public double nanometersPerHour() {
        return distance.nanometers() / time.hours();
    }

    public double nanometersPerDay() {
        return distance.nanometers() / time.days();
    }

    public double nanometersPerWeek() {
        return distance.nanometers() / time.weeks();
    }

    public double nanometersPerMonth() {
        return distance.nanometers() / time.months();
    }

    public double nanometersPerYear() {
        return distance.nanometers() / time.years();
    }

    public double feetPerNanosecond() {
        return distance.feet() / time.nanoseconds();
    }

    public double feetPerMicrosecond() {
        return distance.feet() / time.microseconds();
    }

    public double feetPerMillisecond() {
        return distance.feet() / time.milliseconds();
    }

    public double feetPerSecond() {
        return distance.feet() / time.seconds();
    }

    public double feetPerMinunte() {
        return distance.feet() / time.minutes();
    }

    public double feetPerHour() {
        return distance.feet() / time.hours();
    }

    public double feetPerDay() {
        return distance.feet() / time.days();
    }

    public double feetPerWeek() {
        return distance.feet() / time.weeks();
    }

    public double feetPerMonth() {
        return distance.feet() / time.months();
    }

    public double feetPerYear() {
        return distance.feet() / time.years();
    }

    public double inchesPerNanosecond() {
        return distance.inches() / time.nanoseconds();
    }

    public double inchesPerMicrosecond() {
        return distance.inches() / time.microseconds();
    }

    public double inchesPerMillisecond() {
        return distance.inches() / time.milliseconds();
    }

    public double inchesPerSecond() {
        return distance.inches() / time.seconds();
    }

    public double inchesPerMinute() {
        return distance.inches() / time.minutes();
    }

    public double inchesPerHour() {
        return distance.inches() / time.hours();
    }

    public double inchesPerDay() {
        return distance.inches() / time.days();
    }

    public double inchesPerWeek() {
        return distance.inches() / time.weeks();
    }

    public double inchesPerMonth() {
        return distance.inches() / time.months();
    }

    public double inchesPerYear() {
        return distance.inches() / time.years();
    }

    public double yardsPerNanosecond() {
        return distance.yards() / time.nanoseconds();
    }

    public double yardsPerMicrosecond() {
        return distance.yards() / time.microseconds();
    }

    public double yardsPerMillisecond() {
        return distance.yards() / time.milliseconds();
    }

    public double yardsPerSecond() {
        return distance.yards() / time.seconds();
    }

    public double yardsPerMinute() {
        return distance.yards() / time.minutes();
    }

    public double yardsPerHour() {
        return distance.yards() / time.hours();
    }

    public double yardsPerDay() {
        return distance.yards() / time.days();
    }

    public double yardsPerWeek() {
        return distance.yards() / time.weeks();
    }

    public double yardsPerMonth() {
        return distance.yards() / time.months();
    }

    public double yardsPerYear() {
        return distance.yards() / time.years();
    }

    public double milesPerNanosecond() {
        return distance.miles() / time.nanoseconds();
    }

    public double milesPerMicrosecond() {
        return distance.miles() / time.microseconds();
    }

    public double milesPerMillisecond() {
        return distance.miles() / time.milliseconds();
    }

    public double milesPerSecond() {
        return distance.miles() / time.seconds();
    }

    public double milesPerMinute() {
        return distance.miles() / time.minutes();
    }

    public double milesPerHour() {
        return distance.miles() / time.hours();
    }

    public double milesPerDay() {
        return distance.miles() / time.days();
    }

    public double milesPerWeek() {
        return distance.miles() / time.weeks();
    }

    public double milesPerMonth() {
        return distance.miles() / time.months();
    }

    public double milesPerYear() {
        return distance.miles() / time.years();
    }

    public double nauticalMilesPerNanosecond() {
        return distance.nauticalMiles() / time.nanoseconds();
    }

    public double nauticalMilesPerMicrosecond() {
        return distance.nauticalMiles() / time.microseconds();
    }

    public double nauticalMilesPerMillisecond() {
        return distance.nauticalMiles() / time.milliseconds();
    }

    public double nauticalMilesPerSecond() {
        return distance.nauticalMiles() / time.seconds();
    }

    public double nauticalMilesPerMinute() {
        return distance.nauticalMiles() / time.minutes();
    }

    public double nauticalMilesPerHour() {
        return distance.nauticalMiles() / time.hours();
    }

    public double nauticalMilesPerDay() {
        return distance.nauticalMiles() / time.days();
    }

    public double nauticalMilesPerWeek() {
        return distance.nauticalMiles() / time.weeks();
    }

    public double nauticalMilesPerMonth() {
        return distance.nauticalMiles() / time.months();
    }

    public double nauticalMilesPerYear() {
        return distance.nauticalMiles() / time.years();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="state_machine_framework/Angle.html">Angle</a> | <a href="state_machine_framework/Distance.html">Distance</a> | <a href="state_machine_framework/Time.html">Time</a> | <a href="state_machine_framework/Velocity.html">Velocity</a> | <strong>AngularVelocity</strong></p>
<hr />
<p><strong>Units: radians, degrees, rotations <em>PER</em> second, (nano|micro|milli)second, minute, hour, day, week, month, year</strong></p>
<p>The AngularVelocity class stores an amount of angular velocity. It can be created from an <a href="state_machine_framework/Angle.html">Angle</a> class and a <a href="state_machine_framework/Time.html">Time</a> class, and you can get the value from it in any of the units above. Once the AngularVelocity is created, the value cannot be changed.</p>
<p>AngularVelocity has a few math functions: abs (absolute value), signum (returns the sign), add, subtract, multiply, and divide.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/units/AngularVelocity.java">ftc/electronvolts/util/units/AngularVelocity.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.units;


/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 11/16/16
 */

public class AngularVelocity {
    private static final AngularVelocity zero = new AngularVelocity(Angle.zero());
    
    private final Angle angle;
    private final Time time;

    /**
     * Angle per Time
     * 
     * @param angle the Angle object
     * @param time the Time object
     */
    public AngularVelocity(Angle angle, Time time) {
        this.angle = angle;
        this.time = time;
    }

    /**
     * Angle per 1 second
     * 
     * @param angle the Angle object
     */
    private AngularVelocity(Angle angle) {
        this(angle, Time.fromSeconds(1));
    }

    public static AngularVelocity zero() {
        return zero;
    }

    public Angle getAngle(Time time) {
        // angle = angular velocity * time
        return Angle.fromRadians(radiansPerSecond() * time.seconds());
    }

    public Time getTime(Angle angle) {
        // time = angle / angular velocity
        return Time.fromSeconds(angle.radians() / radiansPerSecond());
    }

    public Velocity getVelocity(Distance radius) {
        //velocity = radius * angular velocity
        return new Velocity(Distance.fromMeters(radius.meters() * radiansPerSecond()), Time.fromSeconds(1));
    }

    public AngularVelocity abs() {
        return new AngularVelocity(angle.abs(), time.abs());
    }

    public double signum() {
        return Math.signum(radiansPerSecond());
    }

    /**
     * Adds two AngularVelocity objects together
     * 
     * @param angularVelocity1 the first AngularVelocity
     * @param angularVelocity2 the second AngularVelocity
     * @return the resulting AngularVelocity
     */
    public static AngularVelocity add(AngularVelocity angularVelocity1, AngularVelocity angularVelocity2) {
        return new AngularVelocity(Angle.fromRadians(angularVelocity1.radiansPerSecond() + angularVelocity2.radiansPerSecond()));
    }

    /**
     * Subtracts velocity2 from velocity1
     * 
     * @param angularVelocity1 the first AngularVelocity
     * @param angularVelocity2 the second AngularVelocity
     * @return the resulting AngularVelocity
     */
    public static AngularVelocity subtract(AngularVelocity angularVelocity1, AngularVelocity angularVelocity2) {
        return new AngularVelocity(Angle.fromRadians(angularVelocity1.radiansPerSecond() - angularVelocity2.radiansPerSecond()));
    }

    /**
     * Multiplies an AngularVelocity by a number
     * 
     * @param angularVelocity the AngularVelocity
     * @param number the number to multiply by
     * @return the resulting AngularVelocity
     */
    public static AngularVelocity multiply(AngularVelocity angularVelocity, double number) {
        return new AngularVelocity(Angle.fromRadians(angularVelocity.radiansPerSecond() * number));
    }

    /**
     * Divides an AngularVelocity by a number
     * 
     * @param angularVelocity the AngularVelocity
     * @param number the number to divide by
     * @return the resulting AngularVelocity
     */
    public static AngularVelocity divide(AngularVelocity angularVelocity, double number) {
        return new AngularVelocity(Angle.fromRadians(angularVelocity.radiansPerSecond() * number));
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(radiansPerSecond());
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        AngularVelocity other = (AngularVelocity) obj;
        if (Double.doubleToLongBits(radiansPerSecond()) != Double.doubleToLongBits(other.radiansPerSecond())) return false;
        return true;
    }

    // get angular velocity in various units
    public double radiansPerNanosecond() {
        return angle.radians() / time.nanoseconds();
    }

    public double radiansPerMicrosecond() {
        return angle.radians() / time.microseconds();
    }

    public double radiansPerMillisecond() {
        return angle.radians() / time.milliseconds();
    }

    public double radiansPerSecond() {
        return angle.radians() / time.seconds();
    }

    public double radiansPerMinute() {
        return angle.radians() / time.minutes();
    }

    public double radiansPerHour() {
        return angle.radians() / time.hours();
    }

    public double radiansPerDay() {
        return angle.radians() / time.days();
    }

    public double radiansPerWeek() {
        return angle.radians() / time.weeks();
    }

    public double radiansPerMonth() {
        return angle.radians() / time.months();
    }

    public double radiansPerYear() {
        return angle.radians() / time.years();
    }

    public double degreesPerNanosecond() {
        return angle.degrees() / time.nanoseconds();
    }

    public double degreesPerMicrosecond() {
        return angle.degrees() / time.microseconds();
    }

    public double degreesPerMillisecond() {
        return angle.degrees() / time.milliseconds();
    }

    public double degreesPerSecond() {
        return angle.degrees() / time.seconds();
    }

    public double degreesPerMinute() {
        return angle.degrees() / time.minutes();
    }

    public double degreesPerHour() {
        return angle.degrees() / time.hours();
    }

    public double degreesPerDay() {
        return angle.degrees() / time.days();
    }

    public double degreesPerWeek() {
        return angle.degrees() / time.weeks();
    }

    public double degreesPerMonth() {
        return angle.degrees() / time.months();
    }

    public double degreesPerYear() {
        return angle.degrees() / time.years();
    }

    public double rotationsPerNanosecond() {
        return angle.rotations() / time.nanoseconds();
    }

    public double rotationsPerMicrosecond() {
        return angle.rotations() / time.microseconds();
    }

    public double rotationsPerMillisecond() {
        return angle.rotations() / time.milliseconds();
    }

    public double rotationsPerSecond() {
        return angle.rotations() / time.seconds();
    }

    public double rotationsPerMinute() {
        return angle.rotations() / time.minutes();
    }

    public double rotationsPerHour() {
        return angle.rotations() / time.hours();
    }

    public double rotationsPerDay() {
        return angle.rotations() / time.days();
    }

    public double rotationsPerWeek() {
        return angle.rotations() / time.weeks();
    }

    public double rotationsPerMonth() {
        return angle.rotations() / time.months();
    }

    public double rotationsPerYear() {
        return angle.rotations() / time.years();
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Vector2D | <a href="state_machine_framework/Vector3D.html">Vector3D</a></p>
<hr />
<p>Vector2D stores a mathematical vector in 2 dimensions. You can create it from cartesian (x, y) with <code>new Vector2D(x, y)</code> or polar (r, θ) with <code>Vector2D.fromPolar2D(r, theta)</code>, where &quot;theta&quot; is an <a href="state_machine_framework/Angle.html">Angle</a> object.</p>
<p>Vector2D has 4 getters:</p>
<ul>
<li><code>double getX()</code></li>
<li><code>double getY()</code></li>
<li><code>double getLength()</code></li>
<li><a href="state_machine_framework/Angle.html">Angle</a><code> getDirection()</code></li>
</ul>
<p>A static method to compute the dot product of two Vector2D objects.</p>
<pre><code class="language-java">public static double dotProduct(Vector2D v1, Vector2D v2)
</code></pre>
<p>And a static method to find the signed separation between vectors.</p>
<pre><code class="language-java">public static Angle signedAngularSeparation(Vector2D ref, Vector2D vector)
</code></pre>
<p>signedAngularSeparation can be very useful when dealing with a gyro sensor that can wrap around from 360 to 0. It returns an <a href="state_machine_framework/Angle.html">Angle</a> object.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/Vector2D.java">ftc/electronvolts/util/Vector2D.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

import ftc.electronvolts.util.units.Angle;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/1/16
 */

public class Vector2D {
    /*
     * the 2 components of the vector
     */
    private final double x;
    private final double y;
    
    /*
     * the polar coordinates
     */
    private final double l;
    private final Angle theta;

    /**
     * create a vector using polar coordinates
     *
     * @param magnitude the magnitude of the 2-D vector
     * @param theta the direction of the 2-D vector
     * @return the created vector
     */
    public Vector2D(double magnitude, Angle theta) {
        double thetaRads = theta.radians();
        this.x = magnitude * Math.cos(thetaRads);
        this.y = magnitude * Math.sin(thetaRads);
        
        this.l = magnitude;
        this.theta = theta;
    }

    /**
     * create a vector using x and y
     *
     * @param x x component
     * @param y y component
     */
    public Vector2D(double x, double y) {
        this.x = x;
        this.y = y;
        
        //Pythagorean theorem
        this.l = Math.sqrt(x * x + y * y);
        this.theta = Angle.fromRadians(Math.atan2(y, x));
    }

    /**
     * @return the x component of the vector
     */
    public double getX() {
        return x;
    }

    /**
     * @return the y component of the vector
     */
    public double getY() {
        return y;
    }

    /**
     * @return the length or magnitude of the vector
     */
    public double getLength() {
        return l;
    }

    /**
     * @return a new vector that is normalized (length = 1)
     */
    public Vector2D normalized() {
        return new Vector2D(x / l, y / l);
    }

    /**
     * The order does not matter for the dot product
     *
     * @param v1 one vector
     * @param v2 another vector
     * @return the dot product of the two vectors
     */
    public static double dotProduct(Vector2D v1, Vector2D v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }

    /**
     * @return the direction of the vector
     */
    public Angle getDirection() {
        return theta;
    }
    

    private final static double closeToZero = 1.0e-3;

    /**
     * This helps when using a gyro sensor or any type of 360 degree rotation
     * mechanism
     *
     * @param ref the reference direction, assumed to have no z component
     * @param vector the vector to be measured against the reference to find the
     *            angular separation, also assumed to have no z component
     * @return angular separation between -pi and pi. If vector is to the right
     *         of reference, then it is positive.
     */
    public static Angle signedAngularSeparation(Vector2D ref, Vector2D vector) {
        Vector3D ref3D = Vector3D.from2D(ref);
        Vector3D vector3D = Vector3D.from2D(vector);
        
        Vector3D cross = Vector3D.crossProduct(ref3D, vector3D);
        // If the vectors are too closely aligned, then return zero for
        // separation.
        if (Math.abs(cross.getZ()) &lt; closeToZero) {
            return Angle.zero();
        }
        // To get the angle:
        // a dot b = a * b * cos(angle)
        // so angle = acos[ (a dot b) / (a * b) ]
        // Make sure a * b is not too close to zero 0
        double lengths = ref3D.getLength() * vector3D.getLength();
        if (lengths &lt; closeToZero) {
            // this is really an error, but to keep the robot from crashing,
            // just return 0
            return Angle.zero();
        }
        double dot = Vector3D.dotProduct(ref3D, vector3D);

        return Angle.fromRadians(Math.signum(cross.getZ()) * Math.acos(dot / lengths));
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(x);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        temp = Double.doubleToLongBits(y);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        Vector2D other = (Vector2D) obj;
        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x)) return false;
        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y)) return false;
        return true;
    }

    @Override
    public String toString() {
        return &quot;(&quot; + x + &quot;, &quot; + y + &quot;)&quot;;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="state_machine_framework/Vector2D.html">Vector2D</a> | Vector3D</p>
<hr />
<p>Vector3D stores a mathematical vector in 3 dimensions. You can create it from cartesian (x, y, z) with <code>new Vector3D(x, y, z)</code>, spherical (r, θ, φ) using <code>Vector3D(magnitude, theta, phi)</code>, or polar (r, θ) using only 2 dimensions with <code>Vector2D.fromPolar2D(r, theta)</code>, where &quot;theta&quot; is an <a href="state_machine_framework/Angle.html">Angle</a> object.</p>
<p>Vector3D has 6 getters:</p>
<ul>
<li><code>double getX()</code></li>
<li><code>double getY()</code></li>
<li><code>double getZ()</code></li>
<li><code>double getLength()</code></li>
<li><a href="state_machine_framework/Angle.html">Angle</a><code>getTheta()</code></li>
<li><a href="state_machine_framework/Angle.html">Angle</a><code>getPhi()</code></li>
</ul>
<p>And static methods to compute the dot product, cross product, and separation of two Vector3D objects.</p>
<pre><code class="language-java">public static double dotProduct(Vector3D v1, Vector3D v2)
public static Vector3D crossProduct(Vector3D v1, Vector3D v2)
public static Angle angularSeparation(Vector3D ref, Vector3D vector)
</code></pre>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/Vector3D.java">ftc/electronvolts/util/Vector3D.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

import ftc.electronvolts.util.units.Angle;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/30/16
 */
public class Vector3D {
    /*
     * the 3 components of the vector
     */
    private final double x;
    private final double y;
    private final double z;

    /*
     * the spherical coordinates
     */
    private final double l;
    private final Angle theta;
    private final Angle phi;

    /**
     * create a vector using polar coordinates with z = 0
     *
     * @param magnitude the magnitude of the Vector2D
     * @param theta the direction of the Vector2D
     * @return the created Vector3D
     */
    public static Vector3D fromPolar2D(double magnitude, Angle theta) {
        return from2D(new Vector2D(magnitude, theta));
    }

    /**
     * create a vector from a Vector2D with z = 0
     * 
     * @param vector2D the 2D vector to use
     * @return the created Vector3D
     */
    public static Vector3D from2D(Vector2D vector2D) {
        return new Vector3D(vector2D.getX(), vector2D.getY(), 0);
    }

    /**
     * Create a vector using spherical coordinates
     * 
     * @param magnitude the magnitude of the 3D vector
     * @param theta the direction in the x-y plane
     * @param phi the z direction
     * @return
     */
    public Vector3D(double magnitude, Angle theta, Angle phi) {
        double thetaRads = theta.radians();
        double phiRads = phi.radians();

        // http://mathinsight.org/spherical_coordinates
        // x = ρ sinϕ cosθ
        // y = ρ sinϕ sinθ
        // z = ρ cosϕ
        
        this.x = magnitude * Math.sin(phiRads) * Math.cos(thetaRads);
        this.y = magnitude * Math.sin(phiRads) * Math.sin(thetaRads);
        this.z = magnitude * Math.cos(phiRads);
        
        this.l = magnitude;
        this.theta = theta;
        this.phi = phi;
    }

    /**
     * create a vector using x, y, and z
     *
     * @param x x component
     * @param y y component
     * @param z z component
     */
    public Vector3D(double x, double y, double z) {
        this.x = x;
        this.y = y;
        this.z = z;
        
        //Pythagorean theorem
        this.l = Math.sqrt(x * x + y * y + z * z);
        
        //compute spherical coordinates
        phi = Angle.fromRadians(Math.acos(z / l));
        theta = Angle.fromRadians(Math.atan2(y, x));
    }


    /**
     * @return the x component of the vector
     */
    public double getX() {
        return x;
    }

    /**
     * @return the y component of the vector
     */
    public double getY() {
        return y;
    }

    /**
     * @return the z component of the vector
     */
    public double getZ() {
        return z;
    }

    /**
     * @return the length or magnitude of the vector
     */
    public double getLength() {
        return l;
    }

    /**
     * @return the z direction
     */
    public Angle getPhi() {
        return phi;
    }

    /**
     * @return the x-y direction
     */
    public Angle getTheta() {
        return theta;
    }

    /**
     * @return a new vector that is normalized (length = 1)
     */
    public Vector3D normalized() {
        return new Vector3D(x / l, y / l, z / l);
    }

    /**
     * Order matters for the cross product
     *
     * @param v1 the first vector
     * @param v2 the second vector
     * @return the first vector crossed with the second vector
     */
    public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {
        double x = v1.y * v2.z - v1.z * v2.y;
        double y = v1.z * v2.x - v1.x * v2.z;
        double z = v1.x * v2.y - v1.y * v2.x;
        return new Vector3D(x, y, z);
    }

    /**
     * The order does not matter for the dot product
     *
     * @param v1 one vector
     * @param v2 another vector
     * @return the dot product of the two vectors
     */
    public static double dotProduct(Vector3D v1, Vector3D v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }
    
    /**
     * 
     * @param v1 one vector
     * @param v2 another vector
     * @return the angle between the two vectors
     */
    public static Angle angularSeparation(Vector3D v1, Vector3D v2){
        //             a dot b
        //cos theta = ---------
        //            |a| * |b|
        return Angle.fromRadians(Math.acos(dotProduct(v1, v2) / (v1.l * v2.l)));
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        long temp;
        temp = Double.doubleToLongBits(x);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        temp = Double.doubleToLongBits(y);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        temp = Double.doubleToLongBits(z);
        result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        Vector3D other = (Vector3D) obj;
        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x)) return false;
        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y)) return false;
        if (Double.doubleToLongBits(z) != Double.doubleToLongBits(other.z)) return false;
        return true;
    }

    @Override
    public String toString() {
        return &quot;(&quot; + x + &quot;, &quot; + y + &quot;, &quot; + z + &quot;)&quot;;
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Are the values from your methods out of range?  Have you ever wanted to limit a number? The <strong>Utility(TM)</strong> class is for you! Limit a value before sending it to a motor or servo with <code>motorLimit(v)</code> and <code>servoLimit(v)</code>! Limit a value to ±N with <code>mirrorLimit(v, N)</code>! Or go plain and simple with a good old <code>limit(v, A, B)</code> function. The possibilities are <strong>limitless</strong>!</p>
<p>But wait -- there's more! Now <strong>joining</strong> us are some new methods! These methods are great for joining arrays OR lists of ANY type! Just pass in the array or list and a delimiter and you are good to go. Don't wait to sign up --  if you <strong>join</strong> today, you get a FREE 2-week trial -- for FREE!</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/Utility.java">ftc/electronvolts/util/Utility.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

import java.util.Collection;

/**
 * This file was made by the electronVolts, FTC team 7393 Date Created: 2/17/16
 */
public class Utility {
    /**
     * limits the value to be between a and b
     *
     * @param input the value to be limited
     * @param a one end of the range
     * @param b the other end of the range
     * @return the input limited to the range between a and b
     */
    public static double limit(double input, double a, double b) {
        if (a == b) return a; // if the ends of the range are equal

        // set min and max to a and b, making sure that min &lt; max
        double min = a, max = b;
        if (a &gt; b) {
            min = b;
            max = a;
        }

        // limit the input to be min &lt; input &lt; max
        if (input &gt; max) return max;
        if (input &lt; min) return min;
        return input;
    }

    /**
     * a limit function where min = -max
     *
     * @param input the value to be limited
     * @param max the max absolute value
     * @return the input limited to be between -max to max
     */
    public static double mirrorLimit(double input, double max) {
        return limit(input, -max, max);
    }

    /**
     * Limiting function for motor power
     *
     * @param input the value to be limited
     * @return the input limited to the range from -1 to 1
     */
    public static double motorLimit(double input) {
        return mirrorLimit(input, 1);
    }

    /**
     * Limiting function for servo positions
     *
     * @param input the value to be limited
     * @return the input limited to the range from 0 to 1
     */
    public static double servoLimit(double input) {
        return limit(input, 0, 1);
    }

    /**
     * Join a list of objects with a separator
     * 
     * @param list the list of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static &lt;T&gt; String join(Collection&lt;T&gt; list, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (T item : list) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of booleans with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(boolean[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (boolean item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of bytes with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(byte[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (byte item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of chars with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(char[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (char item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of shorts with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(short[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (short item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of ints with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(int[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (int item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of longs with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(long[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (long item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of floats with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(float[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (float item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

    /**
     * Join an array of doubles with a separator
     * 
     * @param array the array of values
     * @param separator the String to put between the values
     * @return a String of the joined items
     */
    public static String join(double[] array, String separator) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (double item : array) {
            if (first) {
                first = false;
            } else {
                sb.append(separator);
            }
            sb.append(item);
        }
        return sb.toString();
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>In order for all the classes to have easy access to the telemetry object, we decided to make it global. It is set inside AbstractOp so any opmode that extends AbstractOp automatically sets it up. If you use normal opmodes, you can still set it up with <code>Telem.telemetry = telemetry;</code></p>
<p>To use it, you can add a static import:</p>
<pre><code class="language-java">import static ftc.evlib.driverstation.Telem.telemetry;
</code></pre>
<p>Then access it later in the class:</p>
<pre><code class="language-java">telemtry.addData(&quot;Test&quot;, 3);

//this displays whether or not the gyro is calibrated on the driver phone
Telem.displayGyroIsCalibrated(gyro);
</code></pre>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/driverstation/Telem.java">ftc/evlib/driverstation/Telem.java</a></p>
<pre><code class="language-java">package ftc.evlib.driverstation;

import com.qualcomm.robotcore.hardware.GyroSensor;

import org.firstinspires.ftc.robotcore.external.Telemetry;

import ftc.electronvolts.util.ResultReceiver;
import ftc.evlib.Fake;
import ftc.evlib.vision.framegrabber.VuforiaFrameFeeder;
import ftc.evlib.vision.processors.BeaconColorResult;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 9/12/16
 *
 * This class gives everything access to the telemetry
 * Put this in your opmode:
 *
 * Telem.telemetry = telemetry;
 *
 * To set the telemetry variable for anything to use.
 *
 * @see Telemetry
 */
public class Telem {
    //this will fail silently and move on if you write to it before it is set by the opmode
    public static Telemetry telemetry = Fake.TELEMETRY;

    //this will cause errors if you write to it before it is set by the opmode
//    public static Telemetry telemetry = null;

    /**
     * Display whether or not a ResultReceiver is ready on the driver station telemetry
     *
     * @param receiver the ResultReceiver
     * @param caption  the caption of the telemetry item
     * @param ready    the value of the telemetry item if ready
     * @param notReady the value of the telemetry item if not ready
     */
    public static void displayReceiverReadiness(ResultReceiver receiver, String caption, String ready, String notReady) {
        if (receiver.isReady()) {
            telemetry.addData(caption, ready);
        } else {
            telemetry.addData(caption, notReady);
        }
    }

    /**
     * Display whether or not a Vuforia ResultReceiver is ready on the driver station telemetry
     *
     * @param receiver the ResultReceiver of the VuforiaFrameFeeder type
     */
    public static void displayVuforiaReadiness(ResultReceiver&lt;VuforiaFrameFeeder&gt; receiver) {
        displayReceiverReadiness(receiver, &quot;vuforia&quot;, &quot;ready&quot;, &quot;NOT INITIALIZED!!!&quot;);
    }

    /**
     * Display a BeaconColorResult on the telemetry
     *
     * @param receiver the ResultReceiver that contains the BeaconColorResult
     */
    public static void displayBeaconColorResult(ResultReceiver&lt;BeaconColorResult&gt; receiver) {
        if (receiver.isReady()) {
            BeaconColorResult result = receiver.getValue();
            telemetry.addData(&quot;leftColor&quot;, result.getLeftColor());
            telemetry.addData(&quot;rightColor&quot;, result.getRightColor());
        } else {
            telemetry.addData(&quot;receiver not ready&quot;, &quot;&quot;);
        }
    }


    /**
     * Display a BeaconColor on the telemetry
     *
     * @param receiver the ResultReceiver that contains the BeaconColor
     */
    public static void displayBeaconColor(ResultReceiver&lt;BeaconColorResult.BeaconColor&gt; receiver) {
        if (receiver.isReady()) {
            telemetry.addData(&quot;color&quot;, receiver.getValue());
        } else {
            telemetry.addData(&quot;receiver not ready&quot;, &quot;&quot;);
        }
    }

    /**
     * Display whether or not a gyro sensor is calibrated on the telemetry screen
     *
     * @param gyro the gyro sensor
     */
    public static void displayGyroIsCalibrated(GyroSensor gyro) {
        if (gyro.isCalibrating()) {
            telemetry.addData(&quot;Gyro state&quot;, &quot;CALIBRATING&quot;);
        } else {
            telemetry.addData(&quot;Gyro state&quot;, &quot;ready&quot;);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>StepTimer keeps track of how long it takes for something to execute. For example:</p>
<pre><code class="language-java">StepTimer stepTimer = new StepTimer(&quot;MATH&quot;);
stepTimer.start();
double result = doComplexMathCalculation(1, 2, 3); //replace this with your actual code.
stepTimer.log(&quot;Complex math calculation&quot;);
</code></pre>
<p>The output in the Android monitor would be:</p>
<pre><code>01-02 03:04:05.678      901-234/? I/MATH: TIME: Complex math calculation: 567 ms
</code></pre>
<p>Here is an example from the <a href="evlib/OpenCV-Image-Processing.html">image processing code</a>:</p>
<pre><code class="language-java">stepTimer.start();
//save the raw camera image for logging
ImageUtil.saveImage(TAG, rgbaFrame, Imgproc.COLOR_RGBA2BGR, &quot;00_camera&quot;, startTime);
stepTimer.log(&quot;save 00&quot;);
</code></pre>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/util/StepTimer.java">ftc/evlib/util/StepTimer.java</a></p>
<pre><code class="language-java">package ftc.evlib.util;

import android.util.Log;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 8/26/16
 *
 * Records and logs the time it takes to complete a certain step in an algorithm
 */
public class StepTimer {
    private final String tag;
    private long timer;

    /**
     * @param tag the tag to give to the android logging
     *            You can search for the tag in the logs to find messages generated by your code
     */
    public StepTimer(String tag) {
        this.tag = tag;
        start();
    }

    /**
     * Start a step
     */
    public void start() {
        timer = System.nanoTime();
    }

    /**
     * Log the name of the step and the time since it started
     *
     * @param message the name of the step
     */
    public void log(String message) {
        Log.i(tag, &quot;TIME: &quot; + message + &quot;: &quot; + String.valueOf(get()) + &quot; ms&quot;);
    }

    /**
     * @return the time since the step started
     */
    public double get() {
        return (System.nanoTime() - timer) / 1000000.0;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>FileUtil manages a directory structure on the robot controller phone:</p>
<ul>
<li>root/sdcard/FTC
<ul>
<li>pictures - outputs of [[ImageProcessor]] operations</li>
<li>logs - outputs of the logging from any opmode</li>
<li>options - storage for autonomous options</li>
<li>configs - storage for servo preset values
<ul>
<li>inside configs is a directory for each [[Robot Configuration]] with its servos' presets</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FileUtil can return a reference to any of these directories, or a new File in any of these directories.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/EVLib/src/main/java/ftc/evlib/util/FileUtil.java">ftc/evlib/util/FileUtil.java</a></p>
<pre><code class="language-java">package ftc.evlib.util;

import android.os.Environment;

import java.io.File;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/2/16
 *
 * Utilities to get files and directories on the phone storage
 * All files will be under the &quot;FTC&quot; directory in the phone's root directory
 */

public class FileUtil {
    private static final String APP_DIR_NAME = &quot;FTC&quot;;

    /**
     * @return a reference to the root phone directory
     */
    public static File getRootDir() {
        return Environment.getExternalStorageDirectory();
    }

    /**
     * @return a reference to the root phone directory
     */
    public static File getAppDir() {
        File dir = new File(getRootDir(), &quot;/&quot; + APP_DIR_NAME);
        mkdirsOrThrowException(dir);
        return dir;
    }

    /**
     * Get a reference to a file in the app directory
     *
     * @param filename the name of the file
     * @return the File
     */
    public static File getAppFile(String filename) {
        return new File(getAppDir(), filename);
    }

    public static File getDir(String dirname) {
        File dir = new File(getAppDir(), dirname);
        mkdirsOrThrowException(dir);
        return dir;
    }

    public static File getFile(String dirname, String filename) {
        return new File(getDir(dirname), filename);
    }

    public static File getPicturesDir() {
//        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
        return getDir(&quot;pictures&quot;);
    }

    public static File getPicturesFile(String filename) {
        return new File(getPicturesDir(), filename);
    }

    public static File getLogsDir() {
        return getDir(&quot;logs&quot;);
    }

    public static File getLogsFile(String filename) {
        return new File(getLogsDir(), filename);
    }

    public static File getOptionsDir() {
        return getDir(&quot;options&quot;);
    }

    public static File getOptionsFile(String filename) {
        return new File(getOptionsDir(), filename);
    }

    public static File getConfigsDir() {
        return getDir(&quot;configs&quot;);
    }

    public static File getConfigsFile(String filename) {
        return new File(getConfigsDir(), filename);
    }

    public static void mkdirsOrThrowException(File dir) {
        //noinspection ResultOfMethodCallIgnored
        dir.mkdirs();
        if (!dir.exists() || !dir.isDirectory()) {
            throw new IllegalArgumentException(&quot;Error creating directory \&quot;&quot; + dir + '&quot;');
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Logger logs values in a text file with columns separated by tabs. This file can later be downloaded to your computer and read by a spreadsheet program to graph the values.</p>
<p>When you create it, you pass in:</p>
<ul>
<li>The file's name (e.g. <code>&quot;log&quot;</code>)</li>
<li>The file's extension (e.g. <code>&quot;.csv&quot;</code>)</li>
<li>A list of <code>Logger.Column</code> objects, which contain
<ul>
<li>A column title to be put at the top of the file</li>
<li>An <a href="state_machine_framework/InputExtractor.html">InputExtractor</a> of any type</li>
</ul>
</li>
</ul>
<p>Another column is automatically added at the beginning that logs the time in milliseconds</p>
<p>When the <code>start(File dir)</code> method is called, a file is created named <code>&lt;filename&gt;&lt;timestamp&gt;&lt;file extension&gt;</code> in the specified directory, for example <code>log1234567890.txt</code>. The timestamp is in milliseconds (System.currentTimeMillis()). Then the first line containing the column headers is written.</p>
<p>When the act() method is called, the InputExtractor for each Column is read, the results are connected with tabs, and the joined text is written to a new line in the file.</p>
<p>When the stop() method is called, the file is closed.</p>
<p>The getFileName() method returns the name of the log file.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/files/Logger.java">ftc/electronvolts/util/files/Logger.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.files;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.List;

import ftc.electronvolts.util.InputExtractor;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A logger that takes a list of Columns, which have a header and an
 * InputExtractor, and logs each of them to a column in a file
 */
public class Logger {
    public static class Column {
        private final String header;
        private final InputExtractor&lt;?&gt; input;

        public Column(String header, InputExtractor&lt;?&gt; input) {
            this.header = header;
            this.input = input;
        }
    }

    private static final DecimalFormat df = new DecimalFormat(&quot;#.#####&quot;);
    static {
        df.setRoundingMode(RoundingMode.HALF_UP);
    }

    private long logStart;
    private PrintStream fileStream;
    private final String fileName, fileExtension;
    private String titles;
    private String fullFileName;
    private final List&lt;Column&gt; columns;

    /**
     * @param fileName the name of the file
     * @param fileExtension the file's extension (.txt for example)
     * @param columns the columns that will be written to the file
     */
    public Logger(String fileName, String fileExtension, List&lt;Column&gt; columns) {
        this.fileName = fileName;
        this.fileExtension = fileExtension;
        StringBuilder sb = new StringBuilder(&quot;time&quot;);
        for (Column column : columns) {
            sb.append(&quot;\t&quot;).append(column.header);
        }
        titles = sb.append(&quot;\n&quot;).toString();
        this.columns = columns;
    }

    /**
     * write the column titles to the file
     */
    public boolean start(File dir) {
        logStart = System.nanoTime();

        fullFileName = fileName + System.currentTimeMillis() + fileExtension;
        File file = new File(dir, fullFileName);
        try {
            fileStream = new PrintStream(new FileOutputStream(file));

            fileStream.printf(titles);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    /**
     * write the input columns to the file
     */
    public void act() {
        if (fileStream != null) {
            long now = System.nanoTime();
            StringBuilder line = new StringBuilder(df.format(1e-6 * (now - logStart)));
            for (Column column : columns) {
                line.append(&quot;\t&quot;).append(column.input.getValue());
            }
            fileStream.printf(line.append(&quot;\n&quot;).toString());
        }
    }

    /**
     * close the file
     */
    public void stop() {
        if (fileStream != null) {
            fileStream.close();
        }
    }

    public String getFileName() {
        return fullFileName;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>OptionsFile is used to store values in a file and manage the conversions of those values to certain types. You can create an OptionsFile in three ways. In all three, a <a href="state_machine_framework/Converters.html">Converters</a> object is required.</p>
<pre><code class="language-java">OptionsFile opts = new OptionsFile(UtilConverters.getInstance(), File file); //from an existing file
OptionsFile opts = new OptionsFile(UtilConverters.getInstance(), Map&lt;String, String&gt; map); //from a map of String to String
OptionsFile opts = new OptionsFile(UtilConverters.getInstance()); //from thin air!
</code></pre>
<p>Then you can add items to it:</p>
<pre><code class="language-java">String name = &quot;Mr. Prof. Dr. Adm. Rev. Sir Gerald Archibald Edgar Shelby Bartholomew Reginald Eggbert Mortimer Alphonso Smith XLII, Jr.&quot;;
int age = 83; //shoutout to my octogenarians
double height = 98.8; //inches
TeamColor teamColor = TeamColor.BLUE;

opts.set(&quot;name&quot;, name);
opts.set(&quot;age&quot;, age);
opts.set(&quot;height&quot;, height);
opts.set(&quot;teamColor&quot;, teamColor);
</code></pre>
<p>Or get items from it:</p>
<pre><code class="language-java">String name = opts.get(&quot;name&quot;, String.class); //get the name
Integer age = opts.get(&quot;age&quot;, 0); //get the age. If not found, use 0.
Double height = opts.get(&quot;height&quot;, 0.0); //get the height. If not found, use 0.0.
TeamColor teamColor = opts.get(&quot;teamColor&quot;, null); //get the teamColor. If not found, use null.
</code></pre>
<p>Or save it to a file:</p>
<pre><code class="language-java">if (opts.writeToFile(new File(&quot;person.txt&quot;))) {
    System.out.println(&quot;Save success!&quot;);
} else {
    System.out.println(&quot;File not found!&quot;);
}
</code></pre>
<p>You can also set and get arrays of values of any type supported by the given <a href="state_machine_framework/Converters.html">Converters</a>.</p>
<pre><code class="language-java">Integer[] array1 = { 1, 2, 3 };
opts.setArray(&quot;array&quot;, array1);
Integer[] array2 = opts.getArray(&quot;array&quot;, Integer.class);

TeamColor[] array3 = { TeamColor.RED, TeamColor.RED, TeamColor.BLUE };
opts.setArray(&quot;array&quot;, array3);
TeamColor[] array4 = opts.getArray(&quot;array&quot;, TeamColor.class);
</code></pre>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/OptionsFile.java">ftc/electronvolts/util/OptionsFile.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.files;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.IllegalFormatConversionException;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.regex.Pattern;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * This class stores and retrieves values from a file. It should probably be
 * replaced by an XML or JSON interpreter.
 */
public class OptionsFile {
    private static final String DEFAULT_ARRAY_SEPARATOR = &quot;,&quot;;
    private static final String DEFAULT_SEPARATOR = &quot;=&quot;;

    /**
     * converts objects to and from strings
     */
    private final Converters converters;

    /**
     * stores the strings that are read to and written from files
     */
    private Map&lt;String, String&gt; values;

    /**
     * @param converters the utilities that convert strings to and from objects
     */
    public OptionsFile(Converters converters) {
        this.converters = converters;
        values = new HashMap&lt;&gt;();
    }

    /**
     * @param converters the utilities that convert strings to and from objects
     * @param values the map of values to be loaded
     */
    public OptionsFile(Converters converters, Map&lt;String, String&gt; values) {
        this.converters = converters;
        this.values = values;
    }

    /**
     * retrieve an OptionsFile from a file
     *
     * @param converters the utilities that convert strings to and from objects
     * @param file the file to read from
     * @return the OptionsFile
     */
    public OptionsFile(Converters converters, File file) {
        this.converters = converters;
        values = new HashMap&lt;&gt;();
        BufferedReader br = null;
        try {
            //read each line of the file
            br = new BufferedReader(new FileReader(file));
            String separator = br.readLine();
            if (separator == null) return;
            String line;
            while ((line = br.readLine()) != null) {
                try {
                    //split the line at the &quot;=&quot;
                    String[] elements = line.split(separator);

                    //extract the key and value from the split line
                    String key = elements[0].trim();
                    String value = elements[1].trim();

                    //put the key and value into the map
                    values.put(key, value);
                } catch (IndexOutOfBoundsException e) {
                    e.printStackTrace();
                }
            }
        } catch (FileNotFoundException e1) {
            e1.printStackTrace();
        } catch (IOException e1) {
            e1.printStackTrace();
        } finally {
            try {
                if (br != null) {
                    br.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * store the values to a file
     *
     * @param file the file
     * @return whether or not it worked
     */
    public boolean writeToFile(File file) {
        try {
            FileWriter fw = new FileWriter(file);

            String separator = DEFAULT_SEPARATOR;
            boolean done = false;
            while (!done) {
                done = true;
                for (Map.Entry&lt;String, String&gt; entry : values.entrySet()) {
                    if (entry.getKey().contains(separator) || entry.getValue().contains(separator)) {
                        done = false;
                        separator += DEFAULT_SEPARATOR;
                        break;
                    }
                }
            }

            fw.write(separator + &quot;\n&quot;);
            for (Map.Entry&lt;String, String&gt; entry : values.entrySet()) {
                fw.write(entry.getKey() + separator + entry.getValue() + &quot;\n&quot;);
            }
            fw.close();
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * @return A map of all the values from the file
     */
    public Map&lt;String, String&gt; getValues() {
        return values;
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a boolean
     */
    public void set(String tag, boolean value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Boolean.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a byte
     */
    public void set(String tag, byte value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Byte.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a char
     */
    public void set(String tag, char value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Character.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a short
     */
    public void set(String tag, short value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Short.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value an int
     */
    public void set(String tag, int value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Integer.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a long
     */
    public void set(String tag, long value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Long.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a float
     */
    public void set(String tag, float value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Float.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param value a double
     */
    public void set(String tag, double value) {
        //convert the value to a string and add the key-value pair to the values map
        values.put(tag, Double.toString(value));
    }

    /**
     * set a value in the map
     *
     * @param tag the name of the value
     * @param object the Object to put into the map
     */
    public &lt;T&gt; void set(String tag, T object) {

        //if the object is null, add a null value to the map
        if (object == null) {
            values.put(tag, null);
            return;
        }

        //get the class to convert to
        Class&lt;T&gt; clazz = (Class&lt;T&gt;) object.getClass();

        //get the converter for the specified class
        Converter&lt;T&gt; converter = converters.getConverter(clazz);

        //throw an error if there is no converter for the class
        if (converter == null) {
            throw new MissingResourceException(&quot;No converter given.&quot;, converters.getClass().getName(), clazz.getName());
        }

        //convert the value to a string
        String string = converter.toString(object);

        //if the result is null, throw an exception
        if (string == null) throw new IllegalFormatConversionException((char) 0, clazz);

        //add the key-value pair to the values map
        values.put(tag, string);
    }

    /**
     * set an array of values in a map
     * 
     * @param tag the name of the value
     * @param objects the array of objects to put in the map
     */
    public &lt;T&gt; void setArray(String tag, T[] objects) {
        setArray(tag, objects, DEFAULT_ARRAY_SEPARATOR);
    }

    /**
     * set an array of values in a map
     * 
     * @param tag the name of the value
     * @param objects the array of objects to put in the map
     * @param separator the string to join the array elements with. Cannot be in
     *            the output of the conversion for any item of the array
     */
    public &lt;T&gt; void setArray(String tag, T[] objects, String separator) {
        //if the object is null, add a null value to the map
        if (objects == null) {
            values.put(tag, null);
            return;
        }

        //get the class to convert to
        Class&lt;T&gt; clazz = (Class&lt;T&gt;) objects.getClass().getComponentType();

        //get the converter for the specified class
        Converter&lt;T&gt; converter = converters.getConverter(clazz);

        //throw an error if there is no converter for the class
        if (converter == null) {
            throw new MissingResourceException(&quot;No converter given for \&quot;&quot; + clazz.getName() + &quot;\&quot;.&quot;, converters.getClass().getName(), clazz.getName());
        }

        StringBuilder stringBuilder = new StringBuilder();

        boolean first = true;
        for (T object : objects) {
            if (!first) stringBuilder.append(separator);
            first = false;

            //convert the value to a string
            String string = converter.toString(object);

            //if the result is null, throw an exception
            if (string == null) throw new IllegalFormatConversionException((char) 0, clazz);
            if (string.contains(separator)) {
                throw new IllegalArgumentException(&quot;Converted input \&quot;&quot; + string + &quot;\&quot; cannot contain separator \&quot;&quot; + separator + &quot;\&quot;.&quot;);
            }

            //append it to the string builder
            stringBuilder.append(string);
        }

        //build the string
        String string = stringBuilder.toString();

        //add the key-value pair to the values map
        values.put(tag, string);
    }

    /**
     * 
     * @param tag the name of the value
     * @param clazz the class to convert to
     * @return an array of the specified type
     * @throws IllegalArgumentException if there is no converter for the given
     *             type
     */
    public &lt;T&gt; T[] getArray(String tag, Class&lt;T&gt; clazz) {
        return getArray(tag, clazz, DEFAULT_ARRAY_SEPARATOR);
    }

    /**
     * 
     * @param tag the name of the value
     * @param clazz the class to convert to
     * @param separator the string to separate the array elements with (not a
     *            regex)
     * @return an array of the specified type
     * @throws IllegalArgumentException if there is no converter for the given
     *             type
     */
    public &lt;T&gt; T[] getArray(String tag, Class&lt;T&gt; clazz, String separator) {
        //get the converter for the specified class
        Converter&lt;T&gt; converter = converters.getConverter(clazz);

        //throw an error if there is no converter for the class
        if (converter == null) {
            throw new MissingResourceException(&quot;No converter given.&quot;, converters.getClass().getName(), clazz.getName());
        }

        if (!values.containsKey(tag)) {
            throw new IllegalArgumentException();
        }

        //get the value from the map
        String string = values.get(tag);

        //if the input is null, return null
        if (string == null) return null;

        //separate the string into parts. use the separator as a literal string, not a regex
        String[] parts = string.split(Pattern.quote(separator));

        T[] results = (T[]) Array.newInstance(clazz, parts.length);
        for (int i=0; i&lt;parts.length; i++) {
            String part = parts[i];

            //convert the string to the object
            T result = converter.fromString(part);

            //if the result is null, throw an exception
            if (result == null) throw new IllegalFormatConversionException((char) 0, clazz);

            results[i] = result;
        }

        return results;
    }

    /**
     * @param tag the name of the value
     * @param clazz the class to convert to
     * @return the value converted to the specified type
     * @throws MissingResourceException if there is no converter for the given
     *             type
     * @throws IllegalArgumentException if there is no value with the given tag
     * @throws IllegalFormatConversionException if the string could not be
     *             converted to the specified object
     */
    public &lt;T&gt; T get(String tag, Class&lt;T&gt; clazz) {
        if (clazz == null) {
            throw new IllegalArgumentException(&quot;clazz cannot be null.&quot;);
        }

        //get the converter for the specified class
        Converter&lt;T&gt; converter = converters.getConverter(clazz);

        //throw an error if there is no converter for the class
        if (converter == null) {
            throw new MissingResourceException(&quot;No converter given.&quot;, converters.getClass().getName(), clazz.getName());
        }

        if (!values.containsKey(tag)) {
            throw new IllegalArgumentException();
        }

        //get the value from the map
        String string = values.get(tag);

        //if the input is null, return null
        if (string == null) return null;

        //convert the string to the object
        T result = converter.fromString(string);

        //if the result is null, throw an exception
        if (result == null) throw new IllegalFormatConversionException((char) 0, clazz);

        return result;
    }

    /**
     * @param tag the name of the value
     * @param clazz the class to convert to
     * @param fallback the value to use if the conversion fails
     * @return the value converted to the specified type
     */
    public &lt;T&gt; T get(String tag, Class&lt;T&gt; clazz, T fallback) {
        //try to convert, otherwise return the fallback
        try {
            return get(tag, clazz);
        } catch (IllegalArgumentException e) {
            return fallback;
        }
    }

    /**
     * @param tag the name of the value
     * @param fallback the value to use if none is found
     * @return the value converted to the specified type
     * @throws IllegalArgumentException if there is no converter for the given
     *             type
     */
    public &lt;T&gt; T get(String tag, T fallback) {
        //get the class to convert to
        Class&lt;T&gt; clazz = (Class&lt;T&gt;) fallback.getClass();

        return get(tag, clazz, fallback);
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>InputExtractor is an interface that can be any type. It has one method, getValue(), that returns a value of that type. It is used where an input must be passed in, but that input needs to be generic.</p>
<p>InputExtractor is used to get inputs for a variety of uses:</p>
<ul>
<li><a href="state_machine_framework/Logger.html">Logging</a></li>
<li><a href="state_machine_framework/DigitalInputEdgeDetector.html">Digital edge detection</a></li>
<li><a href="state_machine_framework/AnalogInputScaler.html">Analog scaling</a></li>
<li>Comparing inputs in <a href="state_machine_framework/EndConditions.html">EndConditions</a></li>
</ul>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/InputExtractor.java">ftc/electronvolts/util/InputExtractor.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * This class is used to extract a static method and store it in an object
 */
public interface InputExtractor&lt;Type&gt; {
    /**
     * @return the value from wherever the InputExtractor got it
     */
    Type getValue();
}
</code></pre>
<p>The InputExtractors factory class has methods for adding, subtracting, multiplying, dividing, etc. two InputExtractor objects or one InputExtractor object and a constant. It also has methods for boolean operators such as and, or, xor, etc.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/InputExtractors.java">ftc/electronvolts/util/InputExtractors.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 * 
 * This is the factory class for InputExtractor
 */
public class InputExtractors {
    private static final InputExtractor&lt;Double&gt; ZERO = constant(0.0);

    /**
     * @return an InputExtractor&lt;Double&gt; that always returns 0
     */
    public static InputExtractor&lt;Double&gt; zero() {
        return ZERO;
    }

    /**
     * @param value the value to return
     * @return an InputExtractor that always returns the specified value
     */
    public static &lt;T&gt; InputExtractor&lt;T&gt; constant(final T value) {
        return new InputExtractor&lt;T&gt;() {
            @Override
            public T getValue() {
                return value;
            }
        };
    }

    /**
     * Multiply an InputExtractor&lt;Double&gt; by a constant
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt; to multiply
     * @param value the constant to multiply by
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; multiply(final InputExtractor&lt;Double&gt; inputExtractor, final double value) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return inputExtractor.getValue() * value;
            }
        };
    }

    /**
     * Multiply an InputExtractor&lt;Double&gt; by a constant
     * 
     * @param value the constant to multiply by
     * @param inputExtractor the InputExtractor&lt;Double&gt; to multiply
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; multiply(final double value, final InputExtractor&lt;Double&gt; inputExtractor) {
        return multiply(value, inputExtractor);
    }

    /**
     * Multiply an InputExtractor&lt;Double&gt; by another InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor1 the first InputExtractor&lt;Double&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; multiply(final InputExtractor&lt;Double&gt; inputExtractor1, final InputExtractor&lt;Double&gt; inputExtractor2) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return inputExtractor1.getValue() * inputExtractor2.getValue();
            }
        };
    }

    /**
     * Divide an InputExtractor&lt;Double&gt; by a constant. Equivalent to multiplying
     * by the reciprocal of the constant
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @param value the constant
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; divide(final InputExtractor&lt;Double&gt; inputExtractor, final double value) {
        return multiply(inputExtractor, 1 / value);
    }

    /**
     * Divide an InputExtractor&lt;Double&gt; by another InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor1 the numerator
     * @param inputExtractor2 the denominator
     * @return
     */
    public static InputExtractor&lt;Double&gt; divide(final InputExtractor&lt;Double&gt; inputExtractor1, final InputExtractor&lt;Double&gt; inputExtractor2) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return inputExtractor1.getValue() / inputExtractor2.getValue();
            }
        };
    }

    /**
     * Divide a constant by an InputExtractor&lt;Double&gt;
     * 
     * @param value the constant
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; divide(final double value, final InputExtractor&lt;Double&gt; inputExtractor) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return value / inputExtractor.getValue();
            }
        };
    }

    /**
     * Add a constant to an InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @param value the constant
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; add(final InputExtractor&lt;Double&gt; inputExtractor, final double value) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return inputExtractor.getValue() + value;
            }
        };
    }

    /**
     * Add a constant to an InputExtractor&lt;Double&gt;
     * 
     * @param value the constant
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; add(final double value, final InputExtractor&lt;Double&gt; inputExtractor) {
        return add(inputExtractor, value);
    }

    /**
     * Add two InputExtractor&lt;Double&gt; objects together
     * 
     * @param inputExtractor1 the first InputExtractor&lt;Double&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; add(final InputExtractor&lt;Double&gt; inputExtractor1, final InputExtractor&lt;Double&gt; inputExtractor2) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return inputExtractor1.getValue() + inputExtractor2.getValue();
            }
        };
    }

    /**
     * Subtract a constant from an InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @param value the constant to subtract
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; subtract(final InputExtractor&lt;Double&gt; inputExtractor, final double value) {
        return add(inputExtractor, -value);
    }

    /**
     * Subtract one InputExtractor&lt;Double&gt; from another InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor1 the first InputExtractor&lt;Double&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Double&gt; (will be
     *            subtracted from the first)
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; subtract(final InputExtractor&lt;Double&gt; inputExtractor1, final InputExtractor&lt;Double&gt; inputExtractor2) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return inputExtractor1.getValue() - inputExtractor2.getValue();
            }
        };
    }

    /**
     * Subtract an InputExtractor&lt;Double&gt; from a constant
     * 
     * @param value the constant
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; subtract(final double value, final InputExtractor&lt;Double&gt; inputExtractor) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return value - inputExtractor.getValue();
            }
        };
    }

    /**
     * Get the absolute value of an InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; absolute(final InputExtractor&lt;Double&gt; inputExtractor) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return Math.abs(inputExtractor.getValue());
            }
        };
    }

    /**
     * Get the negative of an InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; negative(final InputExtractor&lt;Double&gt; inputExtractor) {
        return multiply(inputExtractor, -1);
    }

    /**
     * Apply a scaling function to an InputExtractor&lt;Double&gt;
     * 
     * @param inputExtractor the InputExtractor&lt;Double&gt;
     * @param function the Function to scale by
     * @return the created InputExtractor&lt;Double&gt;
     */
    public static InputExtractor&lt;Double&gt; function(final InputExtractor&lt;Double&gt; inputExtractor, final Function function) {
        return new InputExtractor&lt;Double&gt;() {
            @Override
            public Double getValue() {
                return function.f(inputExtractor.getValue());
            }
        };
    }

    /**
     * Get the inverse of an InputExtractor&lt;Boolean&gt;
     * @param inputExtractor the InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; not(final InputExtractor&lt;Boolean&gt; inputExtractor) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return !inputExtractor.getValue();
            }
        };
    }

    /**
     * Apply the &quot;and&quot; operator to 2 InputExtractor&lt;Boolean&gt; objects
     * @param inputExtractor1 the first InputExtractor&lt;Boolean&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; and(final InputExtractor&lt;Boolean&gt; inputExtractor1, final InputExtractor&lt;Boolean&gt; inputExtractor2) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return inputExtractor1.getValue() &amp;&amp; inputExtractor2.getValue();
            }
        };
    }

    /**
     * Apply the &quot;nand&quot; operator to 2 InputExtractor&lt;Boolean&gt; objects
     * @param inputExtractor1 the first InputExtractor&lt;Boolean&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; nand(final InputExtractor&lt;Boolean&gt; inputExtractor1, final InputExtractor&lt;Boolean&gt; inputExtractor2) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return !(inputExtractor1.getValue() &amp;&amp; inputExtractor2.getValue());
            }
        };
    }

    /**
     * Apply the &quot;or&quot; operator to 2 InputExtractor&lt;Boolean&gt; objects
     * @param inputExtractor1 the first InputExtractor&lt;Boolean&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; or(final InputExtractor&lt;Boolean&gt; inputExtractor1, final InputExtractor&lt;Boolean&gt; inputExtractor2) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return inputExtractor1.getValue() || inputExtractor2.getValue();
            }
        };
    }

    /**
     * Apply the &quot;nor&quot; operator to 2 InputExtractor&lt;Boolean&gt; objects
     * @param inputExtractor1 the first InputExtractor&lt;Boolean&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; nor(final InputExtractor&lt;Boolean&gt; inputExtractor1, final InputExtractor&lt;Boolean&gt; inputExtractor2) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return !(inputExtractor1.getValue() || inputExtractor2.getValue());
            }
        };
    }

    /**
     * Apply the &quot;xor&quot; operator to 2 InputExtractor&lt;Boolean&gt; objects
     * @param inputExtractor1 the first InputExtractor&lt;Boolean&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; xor(final InputExtractor&lt;Boolean&gt; inputExtractor1, final InputExtractor&lt;Boolean&gt; inputExtractor2) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return inputExtractor1.getValue() ^ inputExtractor2.getValue();
            }
        };
    }

    /**
     * Apply the &quot;xnor&quot; operator to 2 InputExtractor&lt;Boolean&gt; objects
     * @param inputExtractor1 the first InputExtractor&lt;Boolean&gt;
     * @param inputExtractor2 the second InputExtractor&lt;Boolean&gt;
     * @return the created InputExtractor&lt;Boolean&gt;
     */
    public static InputExtractor&lt;Boolean&gt; xnor(final InputExtractor&lt;Boolean&gt; inputExtractor1, final InputExtractor&lt;Boolean&gt; inputExtractor2) {
        return new InputExtractor&lt;Boolean&gt;() {
            @Override
            public Boolean getValue() {
                return !(inputExtractor1.getValue() ^ inputExtractor2.getValue());
            }
        };
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>DigitalInputEdgeDetector takes an <a href="state_machine_framework/InputExtractor.html">InputExtractor</a> of type Boolean. It detects changes in state between calls of the update() method.</p>
<ul>
<li>The justPresssed() method returns true if the input has transitioned from false to true between the last two calls of update().</li>
<li>The justReleased() method returns true if the input has transitioned from true to false between the last two calls of update().</li>
<li>The isPressed() method returns the value of the input at the last call of update(), regardless of any transitions.</li>
</ul>
<p>DigitalInputEdgeDetector also implements <a href="state_machine_framework/InputExtractor.html">InputExtractor</a>&lt;Boolean&gt; and returns the value of the input in the getValue() method.</p>
<p>See also: <a href="state_machine_framework/AnalogInputScaler.html">AnalogInputScaler</a></p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/DigitalInputEdgeDetector.java">ftc/electronvolts/util/DigitalInputEdgeDetector.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A class that is very useful for joystick control.
 * It does edge detection for a digital input.
 */
public class DigitalInputEdgeDetector implements InputExtractor&lt;Boolean&gt; {
    private Boolean currentValue = null;
    private Boolean previousValue = null;
    private InputExtractor&lt;Boolean&gt; extractor;

    /**
     * @param extractor the InputExtractor to do edge detection on
     */
    public DigitalInputEdgeDetector(InputExtractor&lt;Boolean&gt; extractor) {
        this.extractor = extractor;
    }

    /**
     * update the current and previous value of the input
     *
     * @return the current value of the input
     */
    public boolean update() {
        // if this is the first call to update()
        if (currentValue == null) {
            // set currentValue and previousValue to the reading so no edges are
            // triggered
            currentValue = extractor.getValue();
            previousValue = currentValue;
        } else {
            previousValue = currentValue;
            currentValue = extractor.getValue();
        }
        return currentValue;
    }

    /**
     * @return whether or not the input is true right now
     */
    @Override
    public Boolean getValue() {
        return currentValue;
    }

    /**
     * @return whether or not the input is true right now
     */
    public boolean isPressed() {
        return currentValue;
    }

    /**
     * @return if the input just turned from false to true
     */
    public boolean justPressed() {
        return currentValue &amp;&amp; !previousValue;
    }

    /**
     * @return if the input just turned from true to false
     */
    public boolean justReleased() {
        return !currentValue &amp;&amp; previousValue;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>AnalogInputScaler takes an <a href="state_machine_framework/InputExtractor.html">InputExtractor</a> of type Double, and a <a href="state_machine_framework/Functions.html">Function</a> to scale the input with.</p>
<ul>
<li>The update() method gets the value from the <a href="state_machine_framework/InputExtractor.html">InputExtractor</a> and feeds it through the <a href="state_machine_framework/Functions.html">Function</a></li>
<li>The getValue() method returns the scaled value as it was computed by the last call to update()</li>
<li>The getRawValue() method returns the raw value as it was retrieved by the last call to update()</li>
</ul>
<p>AnalogInputScaler also implements <a href="state_machine_framework/InputExtractor.html">InputExtractor</a>&lt;Double&gt;, which means it can be passed in to a <a href="state_machine_framework/Logger.html">Logging</a> function, for example.</p>
<p>See also: <a href="state_machine_framework/DigitalInputEdgeDetector.html">DigitalInputEdgeDetector</a></p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/AnalogInputScaler.java">ftc/electronvolts/util/AnalogInputScaler.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * Manages the scaling of an analog input such as a joystick
 */
public class AnalogInputScaler implements InputExtractor&lt;Double&gt; {
    private double rawValue = 0;
    private double value = 0;

    private final InputExtractor&lt;Double&gt; extractor;
    private final Function inputScaler;

    /**
     * @param extractor   the input extractor
     * @param inputScaler the input scaler to use for scaling the input
     */
    public AnalogInputScaler(InputExtractor&lt;Double&gt; extractor, Function inputScaler) {
        this.extractor = extractor;
        this.inputScaler = inputScaler;
    }

    /**
     * updates the output value and raw value
     *
     * @return the scaled value
     */
    public double update() {
    	rawValue = extractor.getValue();
        value = inputScaler.f(rawValue);
        return value;
    }

    /**
     * @return the value
     */
    @Override
    public Double getValue() {
        return value;
    }

    /**
     * @return the raw value of the input
     */
    public double getRawValue() {
        return rawValue;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Functions in the state-machine-framework are defined as interfaces. The interface has one method, <code>double f(double x)</code>, that defines the input and output of the function. Functions are used in <a href="state_machine_framework/AnalogInputScaler.html">AnalogInputScaler</a> to scale inputs such as joystick values.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/Function.java">ftc/electronvolts/util/Function.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * An interface that defines a scaling function
 */
public interface Function {
    double f(double x);
}
</code></pre>
<p>To create Function implementations easily, use the Functions factory class. It has methods for creating Function objects that are polynomial, logarithmic, exponential, etc. Note: the squared() function retains the sign so it can be used for joystick scaling.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/Functions.java">ftc/electronvolts/util/Functions.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * Factory class for InputScaler
 * These can be used for joystick scaling
 */
public class Functions {
    /**
     * A constant function y(x) = c
     * 
     * @param c the constant
     * @return the created Function
     */
    public static Function constant(final double c) {
        return new Function() {
            @Override
            public double f(double x) {
                return c;
            }
        };
    }

    /**
     * A linear function y(x) = mx + b
     * 
     * @param m the slope
     * @param b the y-intercept
     * @return the created Function
     */
    public static Function linear(final double m, final double b) {
        return new Function() {
            @Override
            public double f(double x) {
                return m * x + b;
            }
        };
    }

    /**
     * A quadratic function y(x) = ax^2 + bx + c
     * 
     * @param a the squared coefficient
     * @param b the linear coefficient
     * @param c the constant coefficient
     * @return the created Function
     */
    public static Function quadratic(final double a, final double b, final double c) {
        return new Function() {
            @Override
            public double f(double x) {
                return a * x * x + b * x + c;
            }
        };
    }

    /**
     * A cubic function y(x) = ax^3 + bx^2 + cx + d
     * 
     * @param a the cubed coefficient
     * @param b the squared coefficient
     * @param c the linear coefficient
     * @param d the constant coefficient
     * @return the created Function
     */
    public static Function cubic(final double a, final double b, final double c, final double d) {
        return new Function() {
            @Override
            public double f(double x) {
                return a * x * x * x + b * x * x + c * x + d;
            }
        };
    }

    /**
     * A polynomial function:
     * y(x) = a[n]*x^n + a[n-1]*x^(n-1) + ... + a[2]*x^2 + a[1]*x + a[0]
     * note: the first coefficient is the constant term, not the highest term
     * 
     * @param coefficients the constants for each x term
     * @return the created Function
     */
    public static Function polynomial(final double[] coefficients) {
        return new Function() {
            @Override
            public double f(double x) {
                double output = 0;
                double xPart = 1;
                for (int i = 0; i &lt; coefficients.length; i++) {
                    output += coefficients[i] * xPart;
                    xPart *= x;
                }
                return output;
            }
        };
    }

    /**
     * The output = the input squared with the sign retained
     *
     * @return the created Function
     */
    public static Function squared() {
        return new Function() {
            @Override
            public double f(double x) {
                return x * x * Math.signum(x);
            }
        };
    }

    /**
     * The output = the input cubed
     *
     * @return the created Function
     */
    public static Function cubed() {
        return new Function() {
            @Override
            public double f(double x) {
                return x * x * x;
            }
        };
    }

    /**
     * @param deadZone the deadzone to use
     * @return the created Function
     */
    public static Function deadzone(final DeadZone deadZone) {
        return new Function() {
            @Override
            public double f(double x) {
                if (deadZone.isInside(x)) {
                    return 0;
                } else {
                    return x;
                }
            }
        };
    }

    /**
     * limits the input to between min and max
     *
     * @param min the min value
     * @param max the min value
     * @return the created Function
     */
    public static Function limit(final double min, final double max) {
        return new Function() {
            @Override
            public double f(double x) {
                return Utility.limit(x, min, max);
            }
        };
    }

    /**
     * Combines 2 Functions like a composite function b(a(x))
     *
     * @param inner a(x)
     * @param outer b(x)
     * @return the created Function
     */
    public static Function composite(final Function inner, final Function outer) {
        return new Function() {
            @Override
            public double f(double x) {
                return outer.f(inner.f(x));
            }
        };
    }

    /**
     * No modification to the input
     *
     * @return the created Function
     */
    public static Function none() {
        return new Function() {
            @Override
            public double f(double x) {
                return x;
            }
        };
    }

    /**
     * Multiplies the input by a constant
     *
     * @param m the slope
     * @return the created Function
     */
    public static Function linear(final double m) {
        return linear(m, 0);
    }

    /**
     * Logarithmic scaling
     *
     * @param logBase the base of the logarithm
     * @return the created Function
     */
    public static Function logarithmic(final double logBase) {
        return new Function() {
            @Override
            public double f(double x) {
                if (logBase &gt; 0) {
                    double sign = Math.signum(x);
                    x = Math.abs(x);
                    // a log function including the points (0,0) and (1,1)
                    return sign * Math.log(logBase * x + 1) / Math.log(logBase + 1);
                } else {
                    return x;
                }
            }
        };
    }

    /**
     * e^ax based scaling
     * for a != 0
     * y(x) = signum(x) * (e^abs(ax)-1)/(e^a-1)
     * 
     * for a = 0
     * y(x) = x
     * 
     *
     * @param a constant value that determines how curved the function is
     * @return the created Function
     */
    public static Function eBased(final double a) {
        return new Function() {
            @Override
            public double f(double x) {
                if (a == 0) {
                    return x;
                } else {
                    double sign = Math.signum(x);
                    x = Math.abs(x);
                    // a e-based function including the points (0,0) and (1,1)
                    return sign * Math.expm1(a*x)/Math.expm1(a);
                }
            }
        };
    }

    /**
     * a line from (-1,-1) to (-x,-y) to (0,0) to (x,y) to (1,1)
     *
     * @param pointX x
     * @param pointY y
     * @param maxValue the maximum value of the input
     * @return the created Function
     */
    public static Function piecewise(double pointX, double pointY, double maxValue) {
        final double x = Utility.motorLimit(Math.abs(pointX));
        final double y = Utility.motorLimit(Math.abs(pointY));
        final double max = Utility.motorLimit(Math.abs(maxValue));
        final double slope1;
        if (x == 0) {
            slope1 = 0;
        } else {
            slope1 = y / x;
        }
        final double slope2;
        if (x == 1) {
            slope2 = 0;
        } else {
            slope2 = (y - max) / (x - 1);
        }
        return new Function() {
            public double f(double input) {
                if (Math.abs(input) &lt; x) {
                    return slope1 * input;
                } else {
                    return Utility.motorLimit((slope2 * (Math.abs(input) - x) + y) * Math.signum(input));
                }
            }
        };
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ResultReceiver is an interface that allows you to pass results between threads.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/ResultReceiver.java">ftc/electronvolts/util/ResultReceiver.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * Used to transmit information between threads
 */
public interface ResultReceiver&lt;T&gt; {
    /**
     * @return whether or not the value been stored yet
     */
    boolean isReady();

    /**
     * @return the value
     */
    T getValue();

    /**
     * @param value the value to be set
     */
    void setValue(T value);

    /**
     * reset the value and mark as not ready
     */
    void clear();
}
</code></pre>
<p>BasicResultReceiver is the simplest implementation of the ResultReceiver interface.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/BasicResultReceiver.java">ftc/electronvolts/util/BasicResultReceiver.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * The most basic implementation of ResultReceiver
 */
public class BasicResultReceiver&lt;T&gt; implements ResultReceiver&lt;T&gt; {
    private T value = null;
    private boolean ready = false;

    @Override
    public boolean isReady() {
        return ready;
    }

    @Override
    public T getValue() {
        return value;
    }

    @Override
    public void setValue(T value) {
        this.value = value;
        ready = true;
    }

    @Override
    public void clear() {
        ready = false;
        value = null;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>TeamColor is an enum that represents the alliance a robot is on. It has 3 possible values: <code>RED</code>, <code>BLUE</code>, and <code>UNKNOWN</code>. To convert a string to a TeamColor, use the <code>TeamColor.fromString()</code> method. This method converts the input to capital letters. Then it searches in the string for &quot;RED&quot; and &quot;BLUE&quot;. If it doesn't find either one, it then searches for &quot;R&quot; and &quot;B&quot;.</p>
<p>TeamColor also has the opposite() method, which can be used to get your opponent's color.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/TeamColor.java">ftc/electronvolts/util/TeamColor.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * This is a class that stores which team you are on.
 */
public enum TeamColor {
    RED,
    BLUE,
    UNKNOWN;

    /**
     * This method converts a String to a TeamColor. Neither color has
     * precedence over the other,
     * which means that when it finds both, it will return UNKNOWN.
     * 
     * @param s the input String
     * @return the TeamColor corresponding to that string
     */
    public static TeamColor fromString(String s) {
    	if (s==null)return UNKNOWN;
        s = s.toUpperCase(); // convert the input to upper case

        boolean foundRed = s.contains(&quot;RED&quot;); // look for RED in the input
        boolean foundBlue = s.contains(&quot;BLUE&quot;); // look for BLUE in the input

        if (foundRed &amp;&amp; !foundBlue) return RED; // if it found RED but not BLUE
        if (foundBlue &amp;&amp; !foundRed) return BLUE; // if it found BLUE but not RED
        if (foundBlue &amp;&amp; foundRed) return UNKNOWN; // if it found both

        // only case remaining is that neither were found

        boolean foundR = s.contains(&quot;R&quot;); // look for R in the input
        boolean foundB = s.contains(&quot;B&quot;); // look for B in the input

        if (foundR &amp;&amp; !foundB) return RED; // if it found R but not B
        if (foundB &amp;&amp; !foundR) return BLUE; // if it found B but not R
        return UNKNOWN; // if it found both or neither.
    }
    
    /**
     * @return the opposite color
     */
    public TeamColor opposite() {
        switch (this) {
            case RED:
                return BLUE;
            case BLUE:
                return RED;
            default:
                return UNKNOWN;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>MatchTimer keeps track of the current time relative to the start of a match. When you create it, you pass in the length of the match in milliseconds. Then you call the start() method when the match starts. You have to call the update() method every loop.</p>
<p>There are several useful methods available:</p>
<ul>
<li>getDeltaTime() returns the time since the last update()</li>
<li>getElapsedTime() returns the time since the start()</li>
<li>getTimeLeft() returns the time until the match is over</li>
<li>isMatchOver() returns true if the match is over</li>
<li>isMatchJustOver() returns true the first time the match is over when it is called</li>
<li>getMatchLengthMillis() returns the length of the match in milliseconds</li>
<li>getStartTime() returns the time the start() method was called</li>
<li>getNow() returns the last time update() was called</li>
</ul>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/MatchTimer.java">ftc/electronvolts/util/MatchTimer.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

import ftc.electronvolts.util.units.Time;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A simple class for keeping track of elapsed time
 */
public class MatchTimer {
    private final long matchLengthMillis;
    private long startTime, deltaTime, now;
    private boolean hasStopped = false;

    /**
     * The match-timer needs to know how long the match will last.
     *
     * @param matchLengthMillis the length of the match. If negative, the match
     *            continues indefinitely
     */
    public MatchTimer(long matchLengthMillis) {
        this.matchLengthMillis = matchLengthMillis;
    }

    public MatchTimer(Time matchLength) {
        if (matchLength == null) {
            this.matchLengthMillis = -1;
        } else {
            this.matchLengthMillis = (long) matchLength.milliseconds();
        }
    }

    /**
     * Start the match timer. Should be called in init method of project.
     */
    public void start() {
        startTime = System.currentTimeMillis();
        now = startTime;
        deltaTime = 0;

        hasStopped = false;
    }

    /**
     * Update the match timer. Must be called every loop.
     *
     * @return the time between the last call of update() and now
     */
    public long update() {
        long previousTime = now;
        now = System.currentTimeMillis();
        deltaTime = now - previousTime;
        previousTime = now;
        return deltaTime;
    }

    /**
     * Get the time since the last update.
     *
     * @return time since last update
     */
    public long getDeltaTime() {
        return deltaTime;
    }

    /**
     * Get the total time that the match has been going
     *
     * @return total time that the match has been going
     */
    public long getElapsedTime() {
        return now - startTime;
    }

    /**
     * Get the time left in a match
     *
     * @return the time left in a match
     */
    public long getTimeLeft() {
        return matchLengthMillis - getElapsedTime();
    }

    /**
     * Return if the match is over
     *
     * @return returns true if the match is over
     */
    public boolean isMatchOver() {
        return matchLengthMillis &gt;= 0 &amp;&amp; now - startTime &gt;= matchLengthMillis;
    }

    /**
     * @return if this is the first loop that the match has been over
     */
    public boolean isMatchJustOver() {
        if (isMatchOver() &amp;&amp; !hasStopped) {
            hasStopped = true;
            return true;
        }
        return false;
    }

    /**
     * @return the length of the match in milliseconds
     */
    public long getMatchLengthMillis() {
        return matchLengthMillis;
    }

    /**
     * @return the time the match started in milliseconds
     */
    public long getStartTime() {
        return startTime;
    }

    /**
     * @return the time of the last call to update()
     */
    public long getNow() {
        return now;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>StateTimer is a simple timer that can be used in a simple state machine. It is not used in the current state machine framework, but it is here in case anyone needs it for something. For a timer that is used in the framework, see <a href="state_machine_framework/EndConditions.html">EndConditions</a>.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/StateTimer.java">ftc/electronvolts/util/StateTimer.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util;

/**
 * This file was made by the electronVolts, FTC team 7393
 *
 * A timer that can be used in a simplistic state machine
 */
public class StateTimer {
    private long endTime;

    /**
     * Start the timer
     *
     * @param durationMillis how long the timer will run in milliseconds
     */
    public void init(long durationMillis) {
        this.endTime = durationMillis + System.currentTimeMillis();
    }

    /**
     * @return whether or not the time has elapsed yet
     */
    public boolean isDone() {
        return System.currentTimeMillis() &gt;= endTime;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>The unfortunate part about programming for the FTC robot is that to test code, you must build, download, then run; for large codebases this is often a slow process. Sometimes, there will be numbers which are not necessarily fixed, and rebuilding just before every competition and match is infeasible.</p>
<p>This collection of classes gives you a dynamic solution to this problem:</p>
<ul>
<li><code>ftc.evlib.opmodes.AbstractOptionsOp</code></li>
<li><code>ftc.evlib.util.FileUtil</code></li>
<li><code>ftc.electronvolts.util.OptionsFile</code></li>
<li><code>ftc.electronvolts.util.OptionEntry</code></li>
</ul>
<p>These classes allow you to set variables by running an <code>AbstractOptionsOp</code>, then access them later in an unrelated Opmode.</p>
<blockquote>
<p>NOTE: Option setting is an <strong>opt-in</strong> feature. An opmode for setting options does not show up by default.</p>
</blockquote>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>You'll probably want to orient your driver hub to be landscape to use the interface</p>
<blockquote>
<p>TODO: Add picture of driver hub</p>
</blockquote>
<p>The table on the right shows a list of option names and their current values.</p>
<ul>
<li>To select an option, press dpad-up or dpad-down (navigate up or down) until you reach it (the arrows are on either side of the option).</li>
<li>For discrete variables (e.g. integers), press the left/right bumpers to modify their values (this change will be reflected on the telemetry log).</li>
<li>For approximate continuous variables (e.g. floating-points), press the left/right triggers.
<ul>
<li>The depth of the trigger press will be reflected in the rate at which the option is modified (the heavier the touch, the more the variable goes up).</li>
</ul>
</li>
<li>To save the options, press the start button
<ul>
<li><strong>The options will not save the opmode finishes but the start button is not pressed</strong></li>
</ul>
</li>
<li>To clear changes to the last save, press the reset button
<ul>
<li><strong>This will irrevocably remove all changes that were not saved</strong></li>
</ul>
</li>
</ul>
<h2 id="defining-variables"><a class="header" href="#defining-variables">Defining Variables</a></h2>
<p>You'll first want to set up two classes: An OpMode extending <code>AbstractOptionsOp</code> and an enum class implementing <code>OptionEntry</code>. Here is an example:</p>
<pre><code class="language-java">// ExampleOptions.java

import ftc.electronvolts.util.OptionEntry;

public enum ExampleOptions implements OptionEntry {

    TypeData&lt;?&gt; data;

    @Override
    public TypeData&lt;?&gt; getData {
        return data;
    }

    ExampleOptions(TypeDataBuilder&lt;?&gt; t) {
        data = t.build();
    }

}

// ExampleOptionsOp.java

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import ftc.evlib.opmodes.AbstractOptionsOp;

@TeleOp(name = &quot;Example Options Op&quot;)
public class ExampleOptionsOp extends AbstractOptionsOp {
    @Override
    protected void setImplementationSpecificDetails() {

        filename = &quot;example_options.json&quot;;
        options = ExampleOptions.class;

    }
}
</code></pre>
<p>These classes would run fine by themselves, but if you try running &quot;Example Options Op&quot; you would see nothing. To create options, you would have to define an entry in <code>ExampleOptions</code>. Let's define one that is heavily suited for this task: The alliance color. It's one you'll only know on the field, and will not necessarily have the time to set.</p>
<p>Let's say that you represent your alliance color like so:</p>
<pre><code class="language-java">// AllianceColor.java

public enum AllianceColor {
    RED,
    BLUE,
}
</code></pre>
<p>We'll define an option with these properties:</p>
<ul>
<li>It is called <code>ALLIANCE_COLOR</code></li>
<li>It stores the <code>AllianceColor</code> enum</li>
<li>We somehow tipped off the judge, so we're expecting it to mostly be red</li>
</ul>
<p>Here is the full definition:</p>
<pre><code class="language-java">ALLIANCE_COLOR(TypeDataBuilder
    .enumType(AllianceColor.class)
    .withFallback(AllianceColor.RED)
)
</code></pre>
<p>Here it is inserted into <code>ExampleOptions</code>:</p>
<pre><code class="language-java">public enum ExampleOptions implements OptionEntry {

    ALLIANCE_COLOR(TypeDataBuilder
        .enumType(AllianceColor.class)
        .withFallback(AllianceColor.RED)
    )

    TypeData&lt;?&gt; data;

    @Override
    public TypeData&lt;?&gt; getData {
        return data;
    }

    ExampleOptions(TypeDataBuilder&lt;?&gt; t) {
        data = t.build();
    }

}
</code></pre>
<p>Now if you run &quot;Example Options Op&quot; again, it will show this one option, which you can now change using the bumpers on your controller. Adding more options is as easy as adding more enum variants.</p>
<blockquote>
<p>TODO: add an image</p>
</blockquote>
<h2 id="fetching-options"><a class="header" href="#fetching-options">Fetching Options</a></h2>
<p>After you have set these options, you can programatically access them using the <code>OptionsFile</code> class. Admittedly this is not an easy thing to do, and will be the next thing to improve about the option framework.</p>
<p>To get the object containing the options, use:</p>
<pre><code class="language-java">OptionsFile file = new OptionsFile(FileUtil.getOptionsFile(&quot;example_options.json&quot;));
</code></pre>
<p>The string <code>&quot;example_options.json&quot;</code> comes from the <code>ExampleOptionsOp</code> defined before.</p>
<p>To get out the <code>AllianceColor</code>, access the object like so:</p>
<pre><code class="language-java">AllianceColor color = (AllianceColor) file.load(ExampleOptions.ALLIANCE_COLOR);
</code></pre>
<p>The cast is necessary, without it you will have a compile error.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>This page is out of date</p>
</blockquote>
<p>Converters are the method that <a href="state_machine_framework/OptionsFile.html">OptionsFile</a> uses to convert values to and from strings to store in a file.</p>
<p>Converter defines the interface for actually converting something to and from a string.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/files/Converter.java">ftc/electronvolts/util/files/Converter.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.files;

/**
 * This file was made by the electronVolts, FTC team 7393
 * 
 * This interface defines a conversion from an object of a certain type to a
 * String and back again
 * 
 * @see Converters
 */
public interface Converter&lt;T&gt; {
    /**
     * Convert an object to a String
     * 
     * @param object the object
     * @return a String representing the object
     */
    String toString(T object);

    /**
     * Convert a String to an object
     * 
     * @param string the String
     * @return the object
     */
    T fromString(String string);
}
</code></pre>
<p>Converters defines a group of Converter objects for a variety of types of objects. Implementations of Converters are passed to <a href="state_machine_framework/OptionsFile.html">OptionsFile</a> to allow it to convert different types.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/files/Converters.java">ftc/electronvolts/util/files/Converters.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.files;

/**
 * This file was made by the electronVolts, FTC team 7393
 * 
 * Implementations of this interface hold a Map of Converter objects of
 * different types
 * 
 * @see Converter
 */
public interface Converters {
    /**
     * Get a Converter for a certain class
     * 
     * @param clazz the class that the converter converts
     * @return the Converter
     */
    &lt;T&gt; Converter&lt;T&gt; getConverter(Class&lt;T&gt; clazz);
}
</code></pre>
<p>BasicConverters is the most basic implementation of Converters that has Converter objects for Boolean, Byte, Char, Short, Integer, Long, Float, Double, and String.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/files/BasicConverters.java">ftc/electronvolts/util/files/BasicConverters.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.files;

import java.util.HashMap;
import java.util.Map;

/**
 * This file was made by the electronVolts, FTC team 7393
 * 
 * A basic implementation of Converters that includes Converter objects
 * for all the class versions of the primitive types, and Strings
 * 
 * @see Converters
 * @see Converter
 */
public class BasicConverters implements Converters {
    protected static final Map&lt;Class&lt;? extends Object&gt;, Converter&lt;?&gt;&gt; converterMap = new HashMap&lt;&gt;();
    static {
        converterMap.put(Boolean.class, new Converter&lt;Boolean&gt;() {

            @Override
            public String toString(Boolean object) {
                return object.toString();
            }

            @Override
            public Boolean fromString(String string) {
                return Boolean.valueOf(string);
            }
        });
        converterMap.put(Byte.class, new Converter&lt;Byte&gt;() {

            @Override
            public String toString(Byte object) {
                return object.toString();
            }

            @Override
            public Byte fromString(String string) {
                return Byte.valueOf(string);
            }
        });
        converterMap.put(Character.class, new Converter&lt;Character&gt;() {

            @Override
            public String toString(Character object) {
                return object.toString();
            }

            @Override
            public Character fromString(String string) {
                return string.charAt(0);
            }
        });
        converterMap.put(Short.class, new Converter&lt;Short&gt;() {

            @Override
            public String toString(Short object) {
                return object.toString();
            }

            @Override
            public Short fromString(String string) {
                return Short.valueOf(string);
            }
        });
        converterMap.put(Integer.class, new Converter&lt;Integer&gt;() {

            @Override
            public String toString(Integer object) {
                return object.toString();
            }

            @Override
            public Integer fromString(String string) {
                return Integer.valueOf(string);
            }
        });
        converterMap.put(Long.class, new Converter&lt;Long&gt;() {

            @Override
            public String toString(Long object) {
                return object.toString();
            }

            @Override
            public Long fromString(String string) {
                return Long.valueOf(string);
            }
        });
        converterMap.put(Float.class, new Converter&lt;Float&gt;() {

            @Override
            public String toString(Float object) {
                return object.toString();
            }

            @Override
            public Float fromString(String string) {
                return Float.valueOf(string);
            }
        });
        converterMap.put(Double.class, new Converter&lt;Double&gt;() {

            @Override
            public String toString(Double object) {
                return object.toString();
            }

            @Override
            public Double fromString(String string) {
                return Double.valueOf(string);
            }
        });

        converterMap.put(String.class, new Converter&lt;String&gt;() {

            @Override
            public String toString(String object) {
                return object;
            }

            @Override
            public String fromString(String string) {
                return string;
            }
        });

    }

    private static Converters INSTANCE = new BasicConverters();

    protected BasicConverters() {
    }

    public static Converters getInstance() {
        return INSTANCE;
    }

    @Override
    public &lt;T&gt; Converter&lt;T&gt; getConverter(Class&lt;T&gt; clazz) {
        return (Converter&lt;T&gt;) converterMap.get(clazz);
    }

}
</code></pre>
<p>UtilConverters extends BasicConverters, inheriting all its Converter objects. It adds Converters for TeamColor, Vector2D, and Vector3D.</p>
<p><a href="https://github.com/FTC7393/state-machine-framework/blob/master/src/ftc/electronvolts/util/files/UtilConverters.java">ftc/electronvolts/util/files/UtilConverters.java</a></p>
<pre><code class="language-java">package ftc.electronvolts.util.files;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.Vector2D;
import ftc.electronvolts.util.Vector3D;

/**
 * This file was made by the electronVolts, FTC team 7393
 * 
 * An implementation of Converters that extends BasicConverters and adds
 * Converter objects for some of the utility classes
 * 
 * @see BasicConverters
 */
public class UtilConverters extends BasicConverters {
    private static final String DECIMAL_NUMBER = &quot;([0-9\\.\\-]+)&quot;;
    private static final String COMMA = &quot; *, *&quot;;
    static {
        converterMap.put(TeamColor.class, new Converter&lt;TeamColor&gt;() {

            @Override
            public String toString(TeamColor object) {
                return object.name();
            }

            @Override
            public TeamColor fromString(String string) {
                return TeamColor.fromString(string);
            }
        });
        converterMap.put(Vector2D.class, new Converter&lt;Vector2D&gt;() {

            @Override
            public String toString(Vector2D object) {
                return object.toString();
            }

            @Override
            public Vector2D fromString(String string) {
                Pattern pattern = Pattern.compile(&quot;\\(&quot; + DECIMAL_NUMBER + COMMA + DECIMAL_NUMBER + &quot;\\)&quot;);
                Matcher matcher = pattern.matcher(string);
                if (matcher.find()) {
                    return new Vector2D(Double.valueOf(matcher.group(1)), Double.valueOf(matcher.group(2)));
                } else {
                    return null;
                }
            }
        });
        converterMap.put(Vector3D.class, new Converter&lt;Vector3D&gt;() {

            @Override
            public String toString(Vector3D object) {
                return object.toString();
            }

            @Override
            public Vector3D fromString(String string) {
                Pattern pattern = Pattern.compile(&quot;\\(&quot; + DECIMAL_NUMBER + COMMA + DECIMAL_NUMBER + COMMA + DECIMAL_NUMBER + &quot;\\)&quot;);
                Matcher matcher = pattern.matcher(string);
                if (matcher.find()) {
                    return new Vector3D(Double.valueOf(matcher.group(1)), Double.valueOf(matcher.group(2)), Double.valueOf(matcher.group(3)));
                } else {
                    return null;
                }
            }
        });
    }

    private static final Converters INSTANCE = new UtilConverters();

    public static Converters getInstance() {
        return INSTANCE;
    }

    protected UtilConverters() {
        super();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Welcome to the EVLib wiki!</p>
<p>EVLib is designed to assist in the development of very powerful FTC autonomous programs. It provides helper mechanisms for a variety of hardware, like servo speed control.</p>
<p>For starters, check <a href="evlib/Importing-Into-Your-Project.html">the first chapter</a> for instructions on importing into your project.</p>
<p>This tutorial uses our <a href="https://github.com/FTC7393/state-machine-framework/">state-machine-framework</a> library. Click <a href="https://github.com/FTC7393/state-machine-framework/wiki">here</a> for the state-machine-framework wiki.</p>
<div style="break-before: page; page-break-before: always;"></div><p><del>Importing the library into the ftc-app is extremely simple!</del></p>
<p>Unfortunately right now importing Evlib is not very simple, since the library has been migrated and
releases aren't up to date. We're working on it though!</p>
<ol>
<li>
<p>Download the latest release <code>EVLib-release.aar</code>. You can also click <del><a href="https://github.com/FTC7393/EVLib/raw/master/EVLib-release.aar">here</a></del>.</p>
</li>
<li>
<p>Copy the downloaded library to the <code>(your project root)/libs/</code> directory.</p>
</li>
<li>
<p>Now you need to tell gradle that EVLib is a dependency. In android studio, edit the <code>TeamCode/build.gradle</code> file and add the following lines:</p>
</li>
</ol>
<pre><code class="language-groovy">dependencies {
    implementation files('EVlib-release.aar')
}
</code></pre>
<p>Attaching the source (Optional, out of date):</p>
<ol>
<li>
<p><del><a href="https://github.com/FTC7393/EVLib/archive/master.zip">Download the repository as a zip file</a></del> and extract it.</p>
</li>
<li>
<p>When a yellow bar appears at the top of the screen:</p>
</li>
</ol>
<p><img src="https://github.com/FTC7393/EVLib/blob/master/images/attach.png?raw=true" alt="Decompiled .class file" /></p>
<ol start="3">
<li>Click on the blue link that says &quot;Choose Sources...&quot; and a window will pop up.</li>
</ol>
<p><img src="https://github.com/FTC7393/EVLib/blob/master/images/attach2.png?raw=true" alt="attach sources window" /></p>
<ol start="4">
<li>Choose the &quot;EVLib-master/EVLib/src/main/java directory&quot; from the file you downloaded.</li>
</ol>
<p>You are done! You can look at the next chapter to get you started on using the library.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The sample code is in the repository in the <a href="https://github.com/FTC7393/EVLib/tree/master/sample/">sample/</a> directory. It has a few sub-folders: v0, v1, etc. Each &quot;version&quot; adds more functionality to the code.</p>
<p>The first sample is explained in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><p>If you are just starting out with FTC, using this library to its fullest extend probably seems intimidating. You can, however, use some of the simple functions of the library to save yourself some headaches. The following is an example of a TeleOp program that uses EVLib for 2 things:</p>
<ol>
<li>
<p><a href="evlib/GamepadManager.html">Edge detection on the joystick buttons</a>. It might not seem like a big deal, but we spent too much time with flags and nested if statements before moving the edge detection to a dedicated class.</p>
</li>
<li>
<p><a href="evlib/Creating-Motors.html">Management of the motor commands</a>. The EVLib can &quot;wrap&quot; a DcMotor object into either a Motor object (no encoder) or a MotorEnc object. This wrapper class receives your commands and sends them when you call the update() method.</p>
</li>
</ol>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v0/SampleTeleOp.java">/sample/v0/SampleTeleOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v0;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.Servo;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.Utility;
import ftc.evlib.driverstation.GamepadManager;
import ftc.evlib.hardware.motors.Motor;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.Stoppers;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * Sample TeleOp that uses some of the EVLib functionality
 */

@TeleOp(name = &quot;SampleTeleOp V0&quot;)
public class SampleTeleOp extends OpMode {
    /**
     * Adds edge detection to the gamepad buttons
     * and analog scaling to the joysticks
     */
    private GamepadManager driver1, driver2;

    /**
     * Wraps the motors to easily keep track of motor direction
     */
    private Motor leftMotor, rightMotor;

    /**
     * Servo object from the FTC libraries
     */
    private Servo servo;

    /**
     * The servo's current position from 0 to 1
     */
    private double servoPosition;

    /**
     * Takes care of stopping both motors
     */
    private Stoppers stoppers = new Stoppers();

    @Override
    public void init() {
        //get the motors from the hardwareMap and wrap them with the Motor interface
        //         motor factory class method      hardware name, reversed, brake
        leftMotor = Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers);
        rightMotor = Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers);

        //get the servo from the hardwareMap
        servo = hardwareMap.servo.get(&quot;servo&quot;);
    }

    @Override
    public void start() {
        //use a squared function for the joystick scaling
        Function scalingFunction = Functions.squared();

        //create the two drivers' gamepads
        driver1 = new GamepadManager(gamepad1, scalingFunction);
        driver2 = new GamepadManager(gamepad2, scalingFunction);

        //set the servo's position
        servoPosition = 0.5;
    }

    @Override
    public void loop() {
        //set the left and right motor powers based on the scaled joystick values
        leftMotor.setPower(driver1.left_stick_y.getValue());
        rightMotor.setPower(driver1.right_stick_y.getValue());

        //making use of the edge detection from the GamepadManager

        //if the dpad up was just pressed, increase the servo position
        if (driver1.dpad_up.justPressed()) {
            servoPosition += 0.1;
        }

        //if the dpad down was just pressed, decrease the servo position
        if (driver1.dpad_down.justPressed()) {
            servoPosition -= 0.1;
        }

        //limit the servo position to be in the valid range for servos (0 to 1)
        servoPosition = Utility.servoLimit(servoPosition);

        //send the command to the servo
        servo.setPosition(servoPosition);

        //send the motor powers to the motor controller
        leftMotor.update();
        rightMotor.update();
    }

    @Override
    public void stop() {
        //stop both motors
        stoppers.stop();
    }
}
</code></pre>
<p>If you want, you can stop here, you can check out a <a href="evlib/Logging-Example.html">Logging Example</a> for another simple use of EVLib, or you can move on to <a href="evlib/Robot-Configuration.html">Robot Configuration</a> if you want to learn more in depth about the library.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The following is an example of how the Logger and <a href="evlib/FileUtil.html">FileUtil</a> classes are used together in an OpMode to log values. The logs will appear in the phone storage in the FTC/logs folder.</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.yr2016.opmodes;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.util.FileUtil;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 1/13/17
 */

@TeleOp(name = &quot;LogTestOp&quot;)
public class LogTestOp extends OpMode {
    Logger logger = new Logger(&quot;log&quot;, &quot;.csv&quot;, ImmutableList.of(
            new Logger.Column(&quot;gamepad1.left_stick_y&quot;, new InputExtractor&lt;Float&gt;() {
                @Override
                public Float getValue() {
                    return gamepad1.left_stick_y;
                }
            }),
            new Logger.Column(&quot;gamepad1.right_stick_y&quot;, new InputExtractor&lt;Float&gt;() {
                @Override
                public Float getValue() {
                    return gamepad1.right_stick_y;
                }
            })
    ));

    @Override
    public void init() {

    }

    @Override
    public void start() {
        logger.start(FileUtil.getLogsDir());
    }

    @Override
    public void loop() {
        logger.act();
    }

    @Override
    public void stop() {
        logger.stop();
    }
}
</code></pre>
<p>If you want to learn more about the library, check out the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before you write an OpMode using the EVLib, you have to make a class that will retrieve the devices (such as motors, servos, and sensors) from the hardwareMap.</p>
<p>Here is an example of this configuration class:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleRobotCfg.java">/sample/v1/SampleRobotCfg.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.hardware.HardwareMap;

import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.TwoMotors;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A basic configuration of a robot with 2 motors, and nothing else.
 * Its purpose is to make the same configuration available to multiple opmodes.
 */

public class SampleRobotCfg extends RobotCfg {
    /**
     * the speed of the robot at 100% power
     * you should replace this with a measured value
     */
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));

    /**
     * the drive motors of the robot
     */
    private final TwoMotors twoMotors;

    public SampleRobotCfg(HardwareMap hardwareMap) {
        super(hardwareMap);

        // create the twoMotors object
        twoMotors = new TwoMotors(
                //get the left and right motors and wrap it with the EVLib Motor interface
                Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers),
                Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers),
                false, //true for speed mode, false for power mode
                MAX_SPEED
        );
    }

    /**
     * gives the opmodes access to the drive motors
     *
     * @return the drive motors
     */
    public TwoMotors getTwoMotors() {
        return twoMotors;
    }

    @Override
    public void act() {

    }

    @Override
    public void stop() {

    }
}
</code></pre>
<p>The next step is to bring the robot to life with a Basic TeleOp Program (next chapter)</p>
<div style="break-before: page; page-break-before: always;"></div><p>After you have <a href="evlib/Robot-Configuration.html">set up a RobotCfg</a>, you can now write TeleOp and Autonomous OpModes.</p>
<p>The following is a sample TeleOp program that uses the sample RobotCfg.</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleTeleOp.java">/sample/v1/SampleTeleOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.opmodes.AbstractTeleOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample TeleOp program that will allow you to control 2 motors with the left and right joysticks
 */

@TeleOp(name = &quot;SampleTeleOp V1&quot;)
public class SampleTeleOp extends AbstractTeleOp&lt;SampleRobotCfg&gt; {
    @Override
    protected Function getJoystickScalingFunction() {
        //use an exponentially based function for the joystick scaling to allow fine control
        return Functions.eBased(5);
//        return Functions.squared();
//        return Functions.cubed();
//        return Functions.none();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        //create and return a SampleRobotCfg for the library to use
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup() {

    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {
        //set the motor powers to the joystick values
        robotCfg.getTwoMotors().runMotors(
                driver1.left_stick_y.getValue(),
                driver1.right_stick_y.getValue()
        );
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>The next step is to make a Basic Autonomous Program (next chapter).</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before you can make an autonomous program, add the following field to your RobotCfg:</p>
<pre><code class="language-java">    //the speed of the robot at 100% power
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));
</code></pre>
<p>This represents your robot's speed at 100% power. You can calculate it or determine it by measuring the distance your robot drives in a certain amount of time. The Distance and Time classes support a variety of units (you could <em>technically</em> express you robot's speed in nautical miles per week).</p>
<p>The following is an Autonomous program that drives forward for 2 feet (using the speed defined in the robot config):</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v1/SampleAuto.java">/sample/v1/SampleAuto.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v1;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.opmodes.AbstractAutoOp;
import ftc.evlib.statemachine.EVStates;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample autonomous that drives forward for 2 feet.
 */

@Autonomous(name = &quot;SampleAuto V1&quot;)
public class SampleAuto extends AbstractAutoOp&lt;SampleRobotCfg&gt; {

    /**
     * defines all the possible states for the state machine
     * modify this to have whatever states you want
     */
    private enum S implements StateName {
        DRIVE,
        STOP
    }

    @Override
    public StateMachine buildStates() {
        //create a new builder for the states, starting with the DRIVE state
        StateMachineBuilder b = new StateMachineBuilder(S.DRIVE);

        //define the DRIVE state to drive for 2 feet and move to the STOP state
        b.add(EVStates.drive(S.DRIVE, S.STOP, Distance.fromFeet(2), robotCfg.getTwoMotors(), 0.5));

        //define the STOP state to be empty (and never exit) so the state machine will stop
        b.addStop(S.STOP);

        //build and return the StateMachine
        return b.build();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        return null;
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {

    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>You can simplify this autonomous a bit by customizing the StateMachineBuilder (next chapter).</p>
<div style="break-before: page; page-break-before: always;"></div><p>Currently in the autonomous we have the following:</p>
<pre><code class="language-java">        //define the DRIVE state to drive for 2 feet and move to the STOP state
        b.add(EVStates.drive(S.DRIVE, S.STOP, Distance.fromFeet(2), robotCfg.getTwoMotors(), 0.5));
</code></pre>
<p>It would be nice if we didn't have to specify the robot's max speed and the motors to use for each drive state.
The solution for that is to make a class that extends StateMachineBuilder. This custom builder will store the parameters that appear commonly in the drive state and add a convenience method with fewer arguments.</p>
<p>The line above could be changed to:</p>
<pre><code class="language-java">        //more readable and less tedious to type
        b.addDrive(S.DRIVE, S.STOP, Distance.fromFeet(2), 0.5);
</code></pre>
<p>Here is the subclass to StateMachineBuilder with the convenience method:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v2/SampleStateMachineBuilder.java">/sample/v2/SampleStateMachineBuilder.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v2;

import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.motors.TwoMotors;
import ftc.evlib.statemachine.EVStates;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample extension of the StateMachineBuilder.
 * This subclass adds one convenience method for autonomous opmodes.
 */

public class SampleStateMachineBuilder extends StateMachineBuilder {
    /**
     * The drive motors
     */
    private final TwoMotors twoMotors;

    /**
     * Create a SampleStateMachineBuilder, passing it the drive motors
     * The drive motors will be passed to the drive state every time
     *
     * @param firstStateName the state to start with
     * @param twoMotors      the robot's drive motors
     */
    public SampleStateMachineBuilder(StateName firstStateName, TwoMotors twoMotors) {
        super(firstStateName);
        this.twoMotors = twoMotors;
    }

    /**
     * convenience method for adding a drive state
     *
     * @param stateName     the name of the state
     * @param nextStateName the name of the state to go to after the drive is complete
     * @param distance      the distance to drive
     * @param velocity      the velocity to drive at
     */
    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity) {
        //add the drive state with the motors and speed from sampleRobotCfg
        add(EVStates.drive(stateName, nextStateName, distance, twoMotors, velocity));
    }
}
</code></pre>
<p>We then have to change our creation of the StateMachineBuilder to create this new subclass instead, and then we can simplify the drive state.</p>
<p>Here is the autonomous with both changes:</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v2/SampleAuto.java">/sample/v2/SampleAuto.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v2;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.opmodes.AbstractAutoOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample autonomous that drives forward for 2 feet.
 * This one uses a custom builder
 */

@Autonomous(name = &quot;SampleAuto V2&quot;)
public class SampleAuto extends AbstractAutoOp&lt;SampleRobotCfg&gt; {

    /**
     * defines all the possible states for the state machine
     * modify this to have whatever states you want
     */
    private enum S implements StateName {
        DRIVE,
        STOP
    }

    @Override
    public StateMachine buildStates() {
        //create a new builder for the states, starting with the DRIVE state
        //this time we are using the custom builder and passing it the drive motors from the robotCfg
        SampleStateMachineBuilder b = new SampleStateMachineBuilder(S.DRIVE, robotCfg.getTwoMotors());

        //define the DRIVE state to drive for 2 feet and move to the STOP state

        //the old code without the custom builder:
//        b.add(EVStates.drive(S.DRIVE, S.STOP, Distance.fromFeet(2), robotCfg.getTwoMotors(), 0.5));

        //the new code (more readable and less tedious to type):
        b.addDrive(S.DRIVE, S.STOP, Distance.fromFeet(2), 0.5);

        //define the STOP state to be empty (and never exit) so the state machine will stop
        b.addStop(S.STOP);

        //build and return the StateMachine
        return b.build();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        //it will save logs in /FTC/logs/autonomous[....].csv on the robot controller phone
        return new Logger(&quot;autonomous&quot;, &quot;.csv&quot;, ImmutableList.of(
                //each one of these is a column in the log file
                new Logger.Column(&quot;state&quot;, new InputExtractor&lt;StateName&gt;() {
                    @Override
                    public StateName getValue() {
                        return stateMachine.getCurrentStateName();
                    }
                }),
                new Logger.Column(&quot;leftMotor power&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return robotCfg.getTwoMotors().getValue(0);
                    }
                }),
                new Logger.Column(&quot;rightMotor power&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return robotCfg.getTwoMotors().getValue(1);
                    }
                })
        ));
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {

    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>I might not seem like a big improvement, but it makes a huge difference when you have upwards of 20 drive states you are trying to debug. It can also be applied to states that take more parameters, such as a gyro turn which needs <a href="evlib/NMotors.html">TwoMotors</a>, a GyroSensor, and a rotation speed (which could then be the same for all gyro turns).</p>
<p>The next step is to use <a href="evlib/Servo-Presets.html">Servo Presets</a> to add some features to the servos.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The idea of servo presets is to replace &quot;magic numbers&quot; (numbers whose purpose is not obvious) with named servo positions. For example, instead of <code>7.341</code>, you can write <code>ArmServoPresets.LEFT</code> -- much more readable.</p>
<p>Another feature of the servo presets is that you can modify the preset values without changing the app and re-uploading to the phone.</p>
<p>The way these two features are implemented is that each servo has an enum of presets:</p>
<pre><code class="language-java">    /**
     * all the possible values for the arm servo
     */
    public enum ArmServoPresets {
        LEFT,
        MIDDLE,
        RIGHT
    }
</code></pre>
<p>and each RobotCfg has a list of servos, each of which has a hardware name (such as <code>&quot;armServo&quot;</code>) and a list of presets determined from the enum (such as <code>ArmServoPresets.values()</code>):</p>
<pre><code class="language-java">
    /**
     * defines all the servos on the robot
     */
    public enum SampleServoName implements ServoName {
        //enum name(&quot;hardware name&quot;, preset enum.values()),
        ARM_SERVO(&quot;armServo&quot;, ArmServoPresets.values()),
        LEG_SERVO(&quot;legServo&quot;, LegServoPresets.values());

        private final String hardwareName;
        private final Enum[] presets;

        SampleServoName(String hardwareName, Enum[] presets) {
            this.hardwareName = hardwareName;
            this.presets = presets;
        }

        @Override
        public String getHardwareName() {
            return hardwareName;
        }

        @Override
        public Enum[] getPresets() {
            return presets;
        }

        @Override
        public Class&lt;? extends RobotCfg&gt; getRobotCfg() {
            return SampleRobotCfg.class;
        }


    }
</code></pre>
<p>To actually enter the preset values, you need to make and run a ServoTuneOp:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleServoTuneOp.java">/sample/v3/SampleServoTuneOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.opmodes.AbstractServoTuneOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * This opmode is very short since the superclass, AbstractServoTuneOp does most of the work. It
 * allows you to change your servo presets without changing the code and re-deploying it to the
 * phone. This means that you can swap out a servo and re-tune it without having to go into the
 * program and fix magic numbers. Note:  It only works if you use presets everywhere instead of
 * hardcoded values.
 *
 * How to use:
 * Select this opmode from the TeleOp menu and run it.
 * Use the dpad up and down to cycle through all the servos
 * Use the dpad left and right to move through the presets for that servo.
 * Press start to save the current preset of the current servo to the current value.
 *
 * The presets are saved in files that are retrieved when you run other opmodes to find the value of each preset.
 */

@TeleOp(name = &quot;SampleServoTuneOp V3&quot;)
public class SampleServoTuneOp extends AbstractServoTuneOp {
    @Override
    protected RobotCfg createRobotCfg() {
        //create a new SampleRobotConfig and return it.
        //the superclass will extract the servos and do the rest.
        return new SampleRobotCfg(hardwareMap);
    }
}
</code></pre>
<p>The details of how the servos are initialized are in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Here is the SampleRobotConfig with the servo names and presets added:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleRobotCfg.java">/sample/v3/SampleRobotCfg.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.qualcomm.robotcore.hardware.HardwareMap;

import java.util.Map;

import ftc.electronvolts.util.units.Distance;
import ftc.electronvolts.util.units.Time;
import ftc.electronvolts.util.units.Velocity;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.hardware.motors.Motors;
import ftc.evlib.hardware.motors.TwoMotors;
import ftc.evlib.hardware.servos.ServoCfg;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.hardware.servos.Servos;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A more complicated configuration of a robot with 2 motors and 2 servos.
 */

public class SampleRobotCfg extends RobotCfg {
    /**
     * the speed of the robot at 100% power
     * you should replace this with a measured value
     */
    private static final Velocity MAX_SPEED = new Velocity(Distance.fromInches(50), Time.fromSeconds(5));

    /**
     * the drive motors of the robot
     */
    private final TwoMotors twoMotors;

    /**
     * stores all the servos of the robot
     */
    private final Servos servos;

    /**
     * all the possible values for the arm servo
     */
    public enum ArmServoPresets {
        LEFT,
        MIDDLE,
        RIGHT
    }

    /**
     * all the possible values for the leg servo
     */
    public enum LegServoPresets {
        DOWN,
        MIDDLE,
        UP
    }

    /**
     * defines all the servos on the robot
     */
    public enum SampleServoName implements ServoName {
        //enum name(&quot;hardware name&quot;, preset enum.values()),
        ARM_SERVO(&quot;armServo&quot;, ArmServoPresets.values()),
        LEG_SERVO(&quot;legServo&quot;, LegServoPresets.values());

        private final String hardwareName;
        private final Enum[] presets;

        SampleServoName(String hardwareName, Enum[] presets) {
            this.hardwareName = hardwareName;
            this.presets = presets;
        }

        @Override
        public String getHardwareName() {
            return hardwareName;
        }

        @Override
        public Enum[] getPresets() {
            return presets;
        }

        @Override
        public Class&lt;? extends RobotCfg&gt; getRobotCfg() {
            return SampleRobotCfg.class;
        }


    }

    /**
     * Create the SampleRobotCfg with the default servo starting positions
     *
     * @param hardwareMap the hardwareMap from the opmode
     */
    public SampleRobotCfg(HardwareMap hardwareMap) {
        this(hardwareMap, ServoCfg.defaultServoStartPresetMap(SampleServoName.values()));
    }

    /**
     * Create the SampleRobotCfg with custom servo starting positions
     *
     * @param hardwareMap         the hardwareMap from the opmode
     * @param servoStartPresetMap the custom servo starting positions
     */
    public SampleRobotCfg(HardwareMap hardwareMap, Map&lt;ServoName, Enum&gt; servoStartPresetMap) {
        super(hardwareMap);

        // create the twoMotors object
        twoMotors = new TwoMotors(
                //get the left and right motors and wrap it with the EVLib Motor interface
                Motors.withoutEncoder(hardwareMap, &quot;leftMotor&quot;, false, true, stoppers),
                Motors.withoutEncoder(hardwareMap, &quot;rightMotor&quot;, true, true, stoppers),
                false, //true for speed mode, false for power mode
                MAX_SPEED
        );

        servos = new Servos(ServoCfg.createServoMap(hardwareMap, servoStartPresetMap));
    }

    /**
     * gives the opmodes access to the drive motors
     *
     * @return the drive motors
     */
    public TwoMotors getTwoMotors() {
        return twoMotors;
    }

    /**
     * gives the opmodes access to the servos
     *
     * @return the servos
     */
    @Override
    public Servos getServos() {
        return servos;
    }

    @Override
    public void act() {

    }

    @Override
    public void stop() {

    }
}
</code></pre>
<p>With the servos now configured, we can move on to <a href="evlib/Adding-Servos-to-TeleOp.html">Adding Servos to TeleOp</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>To use the servos in TeleOp, you have to first get the servo from the robotCfg:</p>
<p><code>armServo = robotCfg.getServo(SampleRobotCfg.SampleServoName.ARM_SERVO);</code></p>
<p>Then you can move the servo to a preset with:</p>
<p><code>armServo.goToPreset(SampleRobotCfg.ArmServoPresets.RIGHT); </code></p>
<p>You can also specify the speed if you want the servo to turn more slowly:</p>
<p><code>armServo.goToPreset(SampleRobotCfg.ArmServoPresets.RIGHT, 0.2); </code></p>
<p>The following is the new TeleOp program with the servos added.</p>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleTeleOp.java">/sample/v3/SampleTeleOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import ftc.electronvolts.util.Function;
import ftc.electronvolts.util.Functions;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.files.Logger;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.opmodes.AbstractTeleOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample TeleOp program that will allow you to control 2 motors with the left and right joysticks
 * This one also has controls for 2 servos:
 * arm servo:
 * dpad_left - go to LEFT
 * dpad_down - go to MIDDLE
 * dpad_right - go to RIGHT
 *
 * leg servo:
 * a button - go to DOWN
 * b button - go to MIDDLE
 * x button - go to UP
 *
 * I guess you could say that this opmode cost us ...
 * ... an arm and a leg!
 */

@TeleOp(name = &quot;SampleTeleOp V3&quot;)
public class SampleTeleOp extends AbstractTeleOp&lt;SampleRobotCfg&gt; {
    private ServoControl armServo, legServo;

    @Override
    protected Function getJoystickScalingFunction() {
        //use an exponentially based function for the joystick scaling to allow fine control
        return Functions.eBased(5);
//        return Functions.squared();
//        return Functions.cubed();
//        return Functions.none();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        //create and return a SampleRobotCfg for the library to use
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected Logger createLogger() {
        //it will save logs in /FTC/logs/teleop[....].csv on the robot controller phone
        return new Logger(&quot;teleop&quot;, &quot;.csv&quot;, ImmutableList.of(
                //each one of these is a column in the log file
                new Logger.Column(&quot;driver1.left_stick_y&quot;, driver1.left_stick_y),
                new Logger.Column(&quot;driver1.right_stick_y&quot;, driver1.right_stick_y),
                new Logger.Column(&quot;Accelerometer X&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return robotCfg.getAccelerometer().getX();
                    }
                }),
                new Logger.Column(&quot;ARM_SERVO position&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return armServo.getCurrentPosition();
                    }
                }),
                new Logger.Column(&quot;LEG_SERVO position&quot;, new InputExtractor&lt;Double&gt;() {
                    @Override
                    public Double getValue() {
                        return legServo.getCurrentPosition();
                    }
                })
        ));
    }

    @Override
    protected void setup() {
        //get the arm and leg servos from the SampleRobotCfg
        armServo = robotCfg.getServo(SampleRobotCfg.SampleServoName.ARM_SERVO);
        legServo = robotCfg.getServo(SampleRobotCfg.SampleServoName.LEG_SERVO);
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {
        //set the motor powers to the joystick values
        robotCfg.getTwoMotors().runMotors(
                driver1.left_stick_y.getValue(),
                driver1.right_stick_y.getValue()
        );

        //if the left dpad was just pressed
        if (driver1.dpad_left.justPressed()) {
            //move the servo arm to the LEFT position
            armServo.goToPreset(SampleRobotCfg.ArmServoPresets.LEFT);
        }
        //if the down dpad was just pressed
        if (driver1.dpad_down.justPressed()) {
            //move the servo arm to the MIDDLE position
            armServo.goToPreset(SampleRobotCfg.ArmServoPresets.MIDDLE);
        }
        //if the right dpad was just pressed
        if (driver1.dpad_right.justPressed()) {
            //move the servo arm to the RIGHT position
            armServo.goToPreset(SampleRobotCfg.ArmServoPresets.RIGHT);
        }


        //if the a button was just pressed
        if (driver1.a.justPressed()) {
            //move the leg servo to the DOWN position
            legServo.goToPreset(SampleRobotCfg.LegServoPresets.DOWN);
        }
        //if the b button was just pressed
        if (driver1.b.justPressed()) {
            //move the leg servo to the MIDDLE position
            legServo.goToPreset(SampleRobotCfg.LegServoPresets.MIDDLE);
        }
        //if the x button was just pressed
        if (driver1.x.justPressed()) {
            //move the leg servo to the UP position
            legServo.goToPreset(SampleRobotCfg.LegServoPresets.UP);
        }
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>The next step is <a href="evlib/Adding-Servos-to-Autonomous.html">Adding Servos to Autonomous</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Adding servos to the autonomous is a bit more tricky than adding them to TeleOp.
First we have to add convenience methods in the SampleStateMachineBuilder</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleStateMachineBuilder.java">/sample/v3/SampleStateMachineBuilder.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.hardware.servos.ServoControl;
import ftc.evlib.hardware.servos.ServoName;
import ftc.evlib.statemachine.EVStates;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample extension of the StateMachineBuilder.
 * This subclass adds convenience methods for any opmodes that use the SampleRobotConfig.
 */

public class SampleStateMachineBuilder extends StateMachineBuilder {
    /**
     * The SampleRobotCfg to get the drive motors from
     */
    private final SampleRobotCfg sampleRobotCfg;

    /**
     * Create a SampleStateMachineBuilder, passing it the SampleRobotCfg
     * The SampleRobotCfg's drive motors will be passed to the drive state every time
     *
     * @param firstStateName the state to start with
     * @param sampleRobotCfg the robot's configuration
     */
    public SampleStateMachineBuilder(StateName firstStateName, SampleRobotCfg sampleRobotCfg) {
        super(firstStateName);
        this.sampleRobotCfg = sampleRobotCfg;
    }

    /**
     * convenience method for adding a drive state
     *
     * @param stateName the name of the state
     * @param nextStateName the name of the state to go to after the drive is complete
     * @param distance the distance to drive
     * @param velocity the velocity to drive at
     */
    public void addDrive(StateName stateName, StateName nextStateName, Distance distance, double velocity) {
        //add the drive state with the motors and speed from sampleRobotCfg
        add(EVStates.drive(stateName, nextStateName, distance, SampleRobotCfg.MAX_SPEED, sampleRobotCfg.getTwoMotors(), velocity));
    }

    /**
     * add a servo init state that sets all the servos to their starting positions
     *
     * @param stateName the name of the state
     * @param nextStateName the state to go to after the servos are initialized
     */
    public void addServoInit(StateName stateName, StateName nextStateName) {
        add(EVStates.servoInit(stateName, nextStateName, sampleRobotCfg.getServos()));
    }

    /**
     * turn a servo to a preset
     *
     * @param stateName the name of the state
     * @param nextStateName the state to go to after the servo is done turning
     * @param servoName the name of the servo as defined in SampleRobotCfg.ServoName
     * @param servoPreset the servo preset defined in SampleRobotCfg.ArmServoPresets and SampleRobotCfg.LegServoPresets
     * @param speed the speed to run the servo at
     * @param waitForDone wether or not to wait for the servo to turn to move to the next state
     */
    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum servoPreset, double speed, boolean waitForDone) {
        //get the servo
        ServoControl servoControl = sampleRobotCfg.getServo(servoName);
        //add the state that will run the command
        add(EVStates.servoTurn(stateName, nextStateName, servoControl, servoPreset, speed, waitForDone));
    }

    /**
     * turn a servo to a preset at max speed
     *
     * @param stateName the name of the state
     * @param nextStateName the state to go to after the servo is done turning
     * @param servoName the name of the servo as defined in SampleRobotCfg.ServoName
     * @param servoPreset the servo preset defined in SampleRobotCfg.ArmServoPresets and SampleRobotCfg.LegServoPresets
     * @param waitForDone wether or not to wait for the servo to turn to move to the next state
     */
    public void addServo(StateName stateName, StateName nextStateName, ServoName servoName, Enum servoPreset, boolean waitForDone) {
        //get the servo
        ServoControl servoControl = sampleRobotCfg.getServo(servoName);
        //add the state that will run the command
        add(EVStates.servoTurn(stateName, nextStateName, servoControl, servoPreset, waitForDone));
    }


}
</code></pre>
<p>Then comes the easy part -- adding the servo init and turn states to the autonomous:</p>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleAuto.java">/sample/v3/SampleAuto.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.units.Distance;
import ftc.evlib.opmodes.AbstractAutoOp;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 10/18/16
 *
 * A sample autonomous that:
 * 1. Initializes the servos
 * 2. Drives forward 2 feet
 * 3. Turns a servo arm
 */

@Autonomous(name=&quot;SampleAuto V3&quot;)
public class SampleAuto extends AbstractAutoOp&lt;SampleRobotCfg&gt; {

    /**
     * defines all the possible states for the state machine
     * modify this to have whatever states you want
     */
    private enum S implements StateName {
        SERVO_INIT,
        DRIVE,
        SERVO_ARM,
        STOP
    }

    @Override
    public StateMachine buildStates() {
        //create a new builder for the states, starting with the SERVO_INIT state
        //we are using the custom builder and passing it the robotCfg
        SampleStateMachineBuilder b = new SampleStateMachineBuilder(S.SERVO_INIT, robotCfg);

        //add the servo initialization state
        b.addServoInit(S.SERVO_INIT, S.DRIVE);

        //define the DRIVE state to drive for 2 feet and move to the STOP state
        b.addDrive(S.DRIVE, S.SERVO_ARM, Distance.fromFeet(2), 0.5);

        //add the servo turn state
        b.addServo(S.SERVO_ARM, S.STOP, SampleRobotCfg.SampleServoName.ARM_SERVO, SampleRobotCfg.ArmServoPresets.RIGHT, true);

        //define the STOP state to be empty (and never exit) so the state machine will stop
        b.addStop(S.STOP);

        //build and return the StateMachine
        return b.build();
    }

    @Override
    protected SampleRobotCfg createRobotCfg() {
        return new SampleRobotCfg(hardwareMap);
    }

    @Override
    protected void setup_act() {

    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {

    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>The next step in the tutorial is <a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html">Vuforia and OpenCV Beacon Color Detection</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Vuforia and OpenCV are image processing libraries. <a href="https://www.vuforia.com/">Vuforia</a> is by <a href="http://www.ptc.com/">PTC</a> and is built in to the latest version of the FTC app. It has high-level functions for tracking objects and augmented reality. It is very useful for finding the position of the beacon target images.</p>
<p><a href="http://opencv.org/">OpenCV</a> is an open source library that is more low-level, and because of this it is possible to write the procedures yourself and optimize them for better performance.</p>
<p>Before you can use this example, you have to:</p>
<ul>
<li>Set up OpenCV. A guide is available on our website at <del>http://www.gearbox4h.org/opencv/</del> (no longer exists)</li>
<li>Create a Vuforia developer account and get a license key from https://developer.vuforia.com/license-manager</li>
</ul>
<p>This example uses EVLib functionality to:</p>
<ul>
<li>Initialize Vuforia</li>
<li>Find the &quot;Gears&quot; beacon target image (this is controlled by the TeamColor.RED input)</li>
<li>Crop the beacon out of the frame based on the target image location</li>
<li>Find the beacon's color</li>
</ul>
<blockquote>
<p>This example uses guava to initialize lists, which we have left for alternative methods.</p>
</blockquote>
<p><a href="https://github.com/FTC7393/EVLib/blob/master/sample/v3/SampleVuforiaOp.java">sample/v3/SampleVuforiaOp.java</a></p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode.sample.v3;

import com.google.common.collect.ImmutableList;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import org.firstinspires.ftc.teamcode.R;

import ftc.electronvolts.statemachine.EndConditions;
import ftc.electronvolts.statemachine.StateMachine;
import ftc.electronvolts.statemachine.StateMachineBuilder;
import ftc.electronvolts.statemachine.StateName;
import ftc.electronvolts.util.BasicResultReceiver;
import ftc.electronvolts.util.InputExtractor;
import ftc.electronvolts.util.ResultReceiver;
import ftc.electronvolts.util.TeamColor;
import ftc.electronvolts.util.files.Logger;
import ftc.electronvolts.util.units.Time;
import ftc.evlib.driverstation.Telem;
import ftc.evlib.hardware.config.RobotCfg;
import ftc.evlib.opmodes.AbstractAutoOp;
import ftc.evlib.statemachine.EVStates;
import ftc.evlib.vision.framegrabber.VuforiaFrameFeeder;
import ftc.evlib.vision.processors.BeaconColorResult;

/**
 * This file was made by the electronVolts, FTC team 7393
 * Date Created: 12/15/16
 */
@Autonomous(name = &quot;SampleVuforiaOp V3&quot;)
public class SampleVuforiaOp extends AbstractAutoOp&lt;RobotCfg&gt; {
    //get a key (for free) and paste it below by creating an account at https://developer.vuforia.com/license-manager
    private static final String LICENSE_KEY = &quot;&quot;;

    private static final int FRAME_SIZE = 16;
//    private static final int FRAME_SIZE = 8;
//    private static final int FRAME_SIZE = 64;

    private static final int FRAME_WIDTH = 3 * FRAME_SIZE;
    private static final int FRAME_HEIGHT = 4 * FRAME_SIZE;
//    private static final int FRAME_WIDTH = 11 * FRAME_SIZE;
//    private static final int FRAME_HEIGHT = 9 * FRAME_SIZE;

    private enum S implements StateName {
        WAIT_FOR_VUFORIA_INIT,
        FIND_BEACON_COLOR,
        DISPLAY,
        UNKNOWN_BEACON_COLOR,
        BEACON_COLOR_TIMEOUT
    }

    private ResultReceiver&lt;VuforiaFrameFeeder&gt; vuforiaReceiver;
    private ResultReceiver&lt;BeaconColorResult&gt; beaconColorResult;

    @Override
    public StateMachine buildStates() {
        vuforiaReceiver = VuforiaFrameFeeder.initInNewThread(LICENSE_KEY, R.id.cameraMonitorViewId, FRAME_WIDTH, FRAME_HEIGHT);

        StateMachineBuilder b = new StateMachineBuilder(S.WAIT_FOR_VUFORIA_INIT);
        beaconColorResult = new BasicResultReceiver&lt;&gt;();

        b.addEmpty(S.WAIT_FOR_VUFORIA_INIT, b.ts(EndConditions.receiverReady(vuforiaReceiver), S.FIND_BEACON_COLOR));
        b.add(EVStates.findBeaconColorState(S.FIND_BEACON_COLOR, S.DISPLAY, S.UNKNOWN_BEACON_COLOR, S.BEACON_COLOR_TIMEOUT, Time.fromSeconds(10), vuforiaReceiver, beaconColorResult, TeamColor.RED, 4, true));

        b.add(EVStates.displayBeaconColorResult(S.DISPLAY, beaconColorResult));
        b.add(EVStates.displayBeaconColorResult(S.UNKNOWN_BEACON_COLOR, beaconColorResult));
        b.add(EVStates.displayBeaconColorResult(S.BEACON_COLOR_TIMEOUT, beaconColorResult));

        return b.build();
    }

    @Override
    protected RobotCfg createRobotCfg() {
        return new RobotCfg(hardwareMap) {
            @Override
            public void act() {

            }

            @Override
            public void stop() {

            }
        };
    }

    @Override
    protected Logger createLogger() {
        //it will save logs in /FTC/logs/vuforiaOp[....].csv on the robot controller phone
        return new Logger(&quot;vuforiaOp&quot;, &quot;.csv&quot;, ImmutableList.of(
                //each one of these is a column in the log file
                new Logger.Column(&quot;state&quot;, new InputExtractor&lt;StateName&gt;() {
                    @Override
                    public StateName getValue() {
                        return stateMachine.getCurrentStateName();
                    }
                }),
                new Logger.Column(&quot;beaconColor&quot;, new InputExtractor&lt;BeaconColorResult&gt;() {
                    @Override
                    public BeaconColorResult getValue() {
                        return beaconColorResult.getValue();
                    }
                })
        ));
    }

    @Override
    protected void setup_act() {
        Telem.displayVuforiaReadiness(vuforiaReceiver);
    }

    @Override
    protected void go() {

    }

    @Override
    protected void act() {
        telemetry.addData(&quot;state&quot;, stateMachine.getCurrentStateName());
        Telem.displayVuforiaReadiness(vuforiaReceiver);
    }

    @Override
    protected void end() {

    }
}
</code></pre>
<p>This concludes the tutorial for now. Check back later for more updates and sample code, or go on to
the <a href="evlib/Features.html">Features</a> page for an index of other things you can do with EVLib.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="additional-features"><a class="header" href="#additional-features">Additional Features</a></h2>
<p>EVLib includes the <a href="https://github.com/FTC7393/state-machine-framework/wiki">state-machine-framework</a>, so all the features of the state-machine-framework can be used from EVLib.</p>
<ul>
<li><a href="evlib/Motor-and-MotorEnc.html">the Motor interfaces</a></li>
<li><a href="evlib/Creating-Motors.html">creating motors and continuous servos</a></li>
<li><a href="evlib/NMotors.html">grouping motors</a></li>
<li><a href="evlib/Mecanum-Wheels.html">driving mecanum wheels</a></li>
<li><a href="evlib/Mecanum-Control.html">control of mecanum wheels</a></li>
<li><a href="evlib/Servo-Config.html">servo configuration</a></li>
<li><a href="evlib/Servo-Speed-Control.html">servo speed control</a></li>
<li><a href="evlib/../opmodes/base.html">abstract opmodes</a></li>
<li><a href="evlib/AbstractTeleOp.html">abstract teleop</a></li>
<li><a href="evlib/AbstractAutoOp.html">abstract autonomous</a></li>
<li><a href="evlib/AbstractServoTuneOp.html">tuning the servo presets</a></li>
<li><a href="evlib/AbstractOptionsOp.html">selecting options for autonomous</a></li>
<li><a href="evlib/GamepadManager.html">gamepad button edge detection and joystick scaling</a></li>
<li><a href="evlib/EVStates.html">EVStates factory class</a></li>
<li><a href="evlib/EVEndConditions.html">EVEndConditions factory class</a></li>
<li><a href="evlib/EVStateMachineBuilder.html">EVStateMachineBuilder</a></li>
<li><a href="evlib/Analog-Sensors.html">analog sensors</a></li>
<li><a href="evlib/Digital-Sensors.html">digital sensors</a></li>
<li><a href="evlib/OpenCV-Frame-Grabbing.html">frame grabbing with OpenCV</a></li>
<li><a href="evlib/OpenCV-Image-Processing.html">image processing with OpenCV</a></li>
<li><a href="evlib/CalibratedLineSensor.html">line sensor</a></li>
<li><a href="evlib/DoubleLineSensor.html">double line sensor</a></li>
<li><a href="evlib/ColorSensor.html">color sensor</a></li>
<li><a href="evlib/LineFinder.html">line finder</a></li>
<li><a href="evlib/AveragedSensor.html">averaging analog sensors</a></li>
<li><a href="evlib/Telem.html">global telemetry</a></li>
<li><a href="evlib/StepTimer.html">step timer for logging</a></li>
<li><a href="evlib/FileUtil.html">file utilities</a></li>
<li>[[LineSensorArray]] that uses the i2c <a href="https://www.sparkfun.com/products/13582">SparkFun Line Follower Array</a></li>
<li><a href="evlib/Vuforia-Frame-Grabbing.html">frame grabbing with Vuforia</a></li>
<li><a href="evlib/Vuforia-and-OpenCV-Beacon-Color-Detection.html">image processing with Vuforia</a></li>
<li>[[Joystick Recorder]] for &quot;playback&quot; in autonomous</li>
</ul>
<h2 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h2>
<ul>
<li>[[TaskWeb]] to manage executing and moving between multiple tasks on the field</li>
<li>[[Particle Detection]] for autonomous recollection</li>
<li>[[Position Tracker]] to read encoders for position info and return to a set location after driving</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
